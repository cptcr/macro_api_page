"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/home/Features.tsx":
/*!******************************************!*\
  !*** ./src/components/home/Features.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   comparisonData: function() { return /* binding */ comparisonData; },\n/* harmony export */   featureCategories: function() { return /* binding */ featureCategories; },\n/* harmony export */   features: function() { return /* binding */ features; },\n/* harmony export */   integrationGuides: function() { return /* binding */ integrationGuides; },\n/* harmony export */   keyMetrics: function() { return /* binding */ keyMetrics; },\n/* harmony export */   useCaseExamples: function() { return /* binding */ useCaseExamples; }\n/* harmony export */ });\n// src/data/features.ts\nconst features = [\n    {\n        id: \"unified-interface\",\n        title: \"Unified Interface\",\n        icon: \"Command\",\n        description: \"Access multiple APIs through a consistent and intuitive interface design, reducing learning curves.\",\n        longDescription: \"Our unified interface provides consistent patterns across all API integrations, making it easier to work with multiple services without learning different paradigms for each. Every API follows the same initialization, method naming, and error handling patterns.\",\n        benefits: [\n            \"Consistent method naming across all APIs\",\n            \"Standardized error handling patterns\",\n            \"Unified authentication flows\",\n            \"Shared configuration patterns\",\n            \"Reduced learning curve for new APIs\",\n            \"Faster development time\"\n        ],\n        technicalDetails: [\n            \"Abstract base classes ensure consistency\",\n            \"Standardized response formats\",\n            \"Common error types across all services\",\n            \"Shared middleware and interceptors\",\n            \"Consistent async/await patterns\"\n        ],\n        codeExample: \"// Same pattern for all APIs\\nconst gpt = new ChatGPT({ apiKey: 'your-key' });\\nconst spotify = new SpotifyAPI({ clientId: 'id', clientSecret: 'secret' });\\nconst stripe = new StripeAPI({ secretKey: 'key' });\\n\\n// Consistent error handling\\ntry {\\n  const result = await gpt.chat('Hello');\\n} catch (error) {\\n  console.log(error.service); // 'openai'\\n  console.log(error.code);    // 'rate_limit_exceeded'\\n  console.log(error.retryAfter); // 60 (seconds)\\n}\",\n        category: \"core\",\n        importance: \"high\"\n    },\n    {\n        id: \"typescript-support\",\n        title: \"TypeScript Support\",\n        icon: \"FileCode\",\n        description: \"Built with TypeScript from the ground up, providing robust type definitions for all API operations.\",\n        longDescription: \"Complete TypeScript definitions ensure type safety, better IDE support, and catch errors at compile time rather than runtime. Every method, response, and configuration option is fully typed.\",\n        benefits: [\n            \"Full IntelliSense support in VS Code\",\n            \"Compile-time error detection\",\n            \"Auto-completion for all methods and properties\",\n            \"Type-safe API responses\",\n            \"Better refactoring support\",\n            \"Self-documenting code through types\"\n        ],\n        technicalDetails: [\n            \"Strict TypeScript configuration\",\n            \"Generic types for flexible API responses\",\n            \"Discriminated unions for different response types\",\n            \"Branded types for ID validation\",\n            \"Conditional types for advanced use cases\"\n        ],\n        codeExample: \"// Full type safety\\ninterface ChatResponse {\\n  content: string;\\n  usage: {\\n    prompt_tokens: number;\\n    completion_tokens: number;\\n    total_tokens: number;\\n  };\\n  model: string;\\n  created: number;\\n}\\n\\nconst response: ChatResponse = await gpt.createChatCompletion({\\n  model: 'gpt-4',\\n  messages: [{ role: 'user', content: 'Hello' }],\\n  temperature: 0.7\\n});\\n//    ^-- Fully typed response with IntelliSense\",\n        category: \"developer-experience\",\n        importance: \"high\"\n    },\n    {\n        id: \"comprehensive-coverage\",\n        title: \"Comprehensive Coverage\",\n        icon: \"Layers\",\n        description: \"Support for major platforms and services with detailed method implementations and documentation.\",\n        longDescription: \"We support the most popular APIs with comprehensive method coverage, not just basic operations. Each service includes advanced features like webhooks, streaming, and batch operations.\",\n        benefits: [\n            \"15+ major API services supported\",\n            \"200+ methods across all services\",\n            \"Advanced features like streaming and webhooks\",\n            \"Regular updates for new API features\",\n            \"Complete endpoint coverage\",\n            \"Batch operation support\"\n        ],\n        technicalDetails: [\n            \"Full REST API coverage\",\n            \"WebSocket and Server-Sent Events support\",\n            \"Pagination handling\",\n            \"File upload/download capabilities\",\n            \"Webhook signature verification\",\n            \"Real-time data streaming\"\n        ],\n        category: \"core\",\n        importance: \"high\"\n    },\n    {\n        id: \"error-handling\",\n        title: \"Production-Ready Error Handling\",\n        icon: \"ShieldAlert\",\n        description: \"Robust error management with detailed error information for efficient debugging and troubleshooting.\",\n        longDescription: \"Built-in error handling with retry logic, circuit breakers, and detailed error information helps you build resilient applications. Errors include context, suggestions, and automatic retry strategies.\",\n        benefits: [\n            \"Automatic retry with exponential backoff\",\n            \"Circuit breaker pattern implementation\",\n            \"Detailed error context and suggestions\",\n            \"Rate limit handling and queuing\",\n            \"Custom error types for different scenarios\",\n            \"Error logging and monitoring integration\"\n        ],\n        technicalDetails: [\n            \"Hierarchical error types\",\n            \"Configurable retry strategies\",\n            \"Jitter in backoff calculations\",\n            \"Request timeout handling\",\n            \"Dead letter queue for failed requests\",\n            \"Error metrics collection\"\n        ],\n        codeExample: \"import { RateLimitError, NetworkError, RetryManager } from 'macro_api';\\n\\nconst retryManager = new RetryManager({\\n  maxRetries: 3,\\n  baseDelay: 1000,\\n  maxDelay: 30000\\n});\\n\\ntry {\\n  const result = await retryManager.execute(\\n    () => gpt.chat('Hello'),\\n    'chatgpt-completion'\\n  );\\n} catch (error) {\\n  if (error instanceof RateLimitError) {\\n    console.log(`Rate limited. Retry after: ${error.retryAfter}s`);\\n  } else if (error instanceof NetworkError) {\\n    console.log(`Network issue: ${error.message}`);\\n  }\\n}\",\n        category: \"production\",\n        importance: \"high\"\n    },\n    {\n        id: \"promise-based\",\n        title: \"Modern Promise-Based Architecture\",\n        icon: \"Clock\",\n        description: \"Built on modern promise-based architecture, making it easy to integrate with async/await patterns.\",\n        longDescription: \"Fully async/await compatible with support for streaming, parallel execution, and advanced flow control. All operations return promises and support cancellation.\",\n        benefits: [\n            \"Native async/await support\",\n            \"Promise.all() and Promise.allSettled() compatibility\",\n            \"Streaming support for real-time responses\",\n            \"Cancellable operations with AbortController\",\n            \"Parallel request execution\",\n            \"Generator functions for pagination\"\n        ],\n        technicalDetails: [\n            \"AbortController integration\",\n            \"Stream processing with async iterators\",\n            \"Promise timeout handling\",\n            \"Memory-efficient streaming\",\n            \"Backpressure handling\",\n            \"Connection pooling\"\n        ],\n        codeExample: \"// Modern async/await patterns\\nconst controller = new AbortController();\\n\\n// Parallel execution\\nconst [weather, news, stocks] = await Promise.all([\\n  weatherAPI.getCurrent('London'),\\n  newsAPI.getHeadlines(),\\n  stockAPI.getQuotes(['AAPL', 'GOOGL'])\\n]);\\n\\n// Streaming responses\\nfor await (const chunk of gpt.streamChat('Tell me a story')) {\\n  process.stdout.write(chunk);\\n}\\n\\n// Cancellable operations\\nsetTimeout(() => controller.abort(), 5000);\\nconst result = await api.longRunningOperation({ signal: controller.signal });\",\n        category: \"developer-experience\",\n        importance: \"medium\"\n    },\n    {\n        id: \"caching\",\n        title: \"Intelligent Caching System\",\n        icon: \"CheckCircle\",\n        description: \"Built-in caching system with support for memory, Redis, and hybrid caching strategies.\",\n        longDescription: \"Intelligent caching system with support for memory, Redis, and hybrid caching strategies to optimize performance and reduce API costs. Includes cache warming, invalidation, and analytics.\",\n        benefits: [\n            \"Memory and Redis cache providers\",\n            \"Hybrid caching for optimal performance\",\n            \"Automatic cache invalidation\",\n            \"Configurable TTL policies\",\n            \"Cache warming strategies\",\n            \"Cache hit/miss analytics\"\n        ],\n        technicalDetails: [\n            \"LRU eviction policy\",\n            \"Cache compression support\",\n            \"Distributed caching with Redis Cluster\",\n            \"Cache stampede protection\",\n            \"Probabilistic cache warming\",\n            \"Cache metrics and monitoring\"\n        ],\n        codeExample: \"// Configure intelligent caching\\nconst client = new MacroAPIClient({\\n  cache: {\\n    type: 'hybrid',\\n    ttl: 3600, // 1 hour default\\n    maxSize: 1000, // Memory cache size\\n    redis: { \\n      url: process.env.REDIS_URL,\\n      keyPrefix: 'myapp',\\n      cluster: true\\n    },\\n    compression: true\\n  }\\n});\\n\\n// Automatic caching with custom TTL\\nconst result = await client.execute(\\n  () => spotify.search('Daft Punk', ['track']),\\n  {\\n    service: 'spotify',\\n    method: 'search',\\n    params: { query: 'Daft Punk', types: ['track'] },\\n    cacheTtl: 1800 // 30 minutes\\n  }\\n);\\n\\n// Cache statistics\\nconst stats = await client.getCacheStats();\\nconsole.log(`Hit rate: ${(stats.hitRate * 100).toFixed(2)}%`);\",\n        category: \"performance\",\n        importance: \"high\"\n    },\n    {\n        id: \"circuit-breaker\",\n        title: \"Circuit Breaker Pattern\",\n        icon: \"ShieldAlert\",\n        description: \"Built-in circuit breaker pattern to prevent cascading failures and improve system resilience.\",\n        longDescription: \"Implement the circuit breaker pattern to prevent cascading failures when external services are unavailable. Automatically opens circuits when failure thresholds are reached.\",\n        benefits: [\n            \"Prevents cascading failures\",\n            \"Configurable failure thresholds\",\n            \"Automatic recovery detection\",\n            \"Fallback mechanism support\",\n            \"Real-time circuit state monitoring\",\n            \"Graceful degradation\"\n        ],\n        technicalDetails: [\n            \"Three states: Closed, Open, Half-Open\",\n            \"Configurable failure count and time windows\",\n            \"Success threshold for recovery\",\n            \"Metrics collection for monitoring\",\n            \"Per-service circuit configuration\",\n            \"Integration with monitoring systems\"\n        ],\n        codeExample: \"import { CircuitBreaker } from 'macro_api';\\n\\nconst breaker = new CircuitBreaker({\\n  failureThreshold: 5,\\n  recoveryTimeout: 60000, // 1 minute\\n  successThreshold: 3\\n});\\n\\n// Use with fallback\\nconst result = await breaker.execute(\\n  () => externalAPI.getData(),\\n  () => fallbackService.getCachedData() // Fallback function\\n);\\n\\n// Monitor circuit state\\nconsole.log(`Circuit state: ${breaker.getState()}`);\\nconsole.log(`Failure count: ${breaker.getFailureCount()}`);\",\n        category: \"production\",\n        importance: \"medium\"\n    },\n    {\n        id: \"request-batching\",\n        title: \"Request Batching\",\n        icon: \"Layers\",\n        description: \"Automatically batch multiple requests to reduce API calls and improve performance.\",\n        longDescription: \"Intelligent request batching system that automatically groups similar requests together to reduce API calls and improve performance while respecting rate limits.\",\n        benefits: [\n            \"Reduced API call count\",\n            \"Lower latency for bulk operations\",\n            \"Automatic request grouping\",\n            \"Configurable batch sizes\",\n            \"Rate limit optimization\",\n            \"Cost reduction for paid APIs\"\n        ],\n        technicalDetails: [\n            \"Automatic request deduplication\",\n            \"Time-based and size-based batching\",\n            \"Priority queue for urgent requests\",\n            \"Batch splitting for large requests\",\n            \"Partial failure handling\",\n            \"Metrics for batch efficiency\"\n        ],\n        codeExample: \"// Automatic request batching\\nconst batcher = new RequestBatcher({\\n  maxBatchSize: 100,\\n  maxWaitTime: 1000, // 1 second\\n  deduplicate: true\\n});\\n\\n// These requests will be automatically batched\\nconst promises = userIds.map(id => \\n  batcher.execute('getUser', { id })\\n);\\n\\nconst users = await Promise.all(promises);\\n\\n// Manual batching for specific use cases\\nconst batchResult = await api.batchGetUsers({\\n  ids: [1, 2, 3, 4, 5],\\n  fields: ['name', 'email', 'avatar']\\n});\",\n        category: \"performance\",\n        importance: \"medium\"\n    },\n    {\n        id: \"webhook-verification\",\n        title: \"Webhook Verification\",\n        icon: \"ShieldAlert\",\n        description: \"Built-in webhook signature verification for secure event handling from external services.\",\n        longDescription: \"Secure webhook handling with automatic signature verification, payload validation, and replay attack prevention for all supported services.\",\n        benefits: [\n            \"Automatic signature verification\",\n            \"Replay attack prevention\",\n            \"Payload validation\",\n            \"Multi-service webhook support\",\n            \"Event routing and filtering\",\n            \"Error handling and retries\"\n        ],\n        technicalDetails: [\n            \"HMAC signature verification\",\n            \"Timestamp-based replay protection\",\n            \"Configurable tolerance windows\",\n            \"Event type filtering\",\n            \"Middleware-based processing\",\n            \"Dead letter queue for failed events\"\n        ],\n        codeExample: \"import { WebhookVerifier } from 'macro_api';\\n\\nconst verifier = new WebhookVerifier({\\n  stripe: { secret: process.env.STRIPE_WEBHOOK_SECRET },\\n  github: { secret: process.env.GITHUB_WEBHOOK_SECRET },\\n  slack: { secret: process.env.SLACK_WEBHOOK_SECRET }\\n});\\n\\n// Express.js webhook handler\\napp.post('/webhooks/:service', async (req, res) => {\\n  try {\\n    const event = await verifier.verify(\\n      req.params.service,\\n      req.body,\\n      req.headers\\n    );\\n    \\n    // Process verified event\\n    await processWebhookEvent(event);\\n    res.status(200).send('OK');\\n  } catch (error) {\\n    console.error('Webhook verification failed:', error);\\n    res.status(400).send('Invalid signature');\\n  }\\n});\",\n        category: \"production\",\n        importance: \"medium\"\n    },\n    {\n        id: \"rate-limiting\",\n        title: \"Advanced Rate Limiting\",\n        icon: \"Clock\",\n        description: \"Intelligent rate limiting that respects API quotas and automatically handles backoff strategies.\",\n        longDescription: \"Smart rate limiting system that automatically respects API rate limits, implements backoff strategies, and queues requests to maximize throughput while staying within limits.\",\n        benefits: [\n            \"Automatic rate limit detection\",\n            \"Intelligent request queuing\",\n            \"Per-endpoint rate limiting\",\n            \"Adaptive backoff strategies\",\n            \"Priority-based request handling\",\n            \"Rate limit analytics\"\n        ],\n        technicalDetails: [\n            \"Token bucket algorithm\",\n            \"Sliding window rate limiting\",\n            \"Distributed rate limiting with Redis\",\n            \"Per-user and per-API key limits\",\n            \"Rate limit header parsing\",\n            \"Predictive rate limiting\"\n        ],\n        codeExample: \"import { RateLimiter } from 'macro_api';\\n\\nconst limiter = new RateLimiter({\\n  openai: { requestsPerMinute: 60, tokensPerMinute: 90000 },\\n  stripe: { requestsPerSecond: 25 },\\n  spotify: { requestsPerSecond: 10 }\\n});\\n\\n// Automatic rate limiting\\nconst client = new MacroAPIClient({\\n  rateLimiting: {\\n    enabled: true,\\n    strategy: 'adaptive',\\n    queueSize: 1000,\\n    priorityLevels: 3\\n  }\\n});\\n\\n// High priority request\\nconst urgentResult = await client.execute(\\n  () => api.criticalOperation(),\\n  { priority: 'high' }\\n);\\n\\n// Get rate limit status\\nconst status = await limiter.getStatus('openai');\\nconsole.log(`Remaining requests: ${status.remaining}`);\\nconsole.log(`Reset time: ${status.resetTime}`);\",\n        category: \"production\",\n        importance: \"high\"\n    },\n    {\n        id: \"monitoring-observability\",\n        title: \"Monitoring & Observability\",\n        icon: \"CheckCircle\",\n        description: \"Built-in metrics collection, logging, and observability features for production monitoring.\",\n        longDescription: \"Comprehensive monitoring and observability features including metrics collection, structured logging, distributed tracing, and integration with popular monitoring platforms.\",\n        benefits: [\n            \"Automatic metrics collection\",\n            \"Structured logging\",\n            \"Distributed tracing support\",\n            \"Performance monitoring\",\n            \"Error tracking and alerting\",\n            \"Health check endpoints\"\n        ],\n        technicalDetails: [\n            \"OpenTelemetry integration\",\n            \"Prometheus metrics export\",\n            \"Custom metrics and events\",\n            \"Request/response logging\",\n            \"Performance benchmarking\",\n            \"Integration with APM tools\"\n        ],\n        codeExample: \"import { MacroAPIClient, MetricsCollector } from 'macro_api';\\n\\nconst client = new MacroAPIClient({\\n  monitoring: {\\n    enabled: true,\\n    metricsCollector: new MetricsCollector({\\n      exportInterval: 60000, // 1 minute\\n      labels: {\\n        service: 'my-app',\\n        environment: process.env.NODE_ENV\\n      }\\n    }),\\n    tracing: {\\n      serviceName: 'macro-api-client',\\n      jaegerEndpoint: process.env.JAEGER_ENDPOINT\\n    },\\n    logging: {\\n      level: 'info',\\n      format: 'json',\\n      includeRequestBody: false,\\n      includeResponseBody: false\\n    }\\n  }\\n});\\n\\n// Automatic metrics collection\\nconst result = await client.execute(\\n  () => gpt.chat('Hello'),\\n  {\\n    service: 'openai',\\n    method: 'chat',\\n    tags: { operation: 'user-query' }\\n  }\\n);\\n\\n// Custom metrics\\nclient.metrics.increment('custom.api.calls', {\\n  endpoint: '/chat',\\n  status: 'success'\\n});\\n\\n// Health check endpoint\\napp.get('/health', (req, res) => {\\n  const health = client.getHealthStatus();\\n  res.status(health.status === 'healthy' ? 200 : 503).json(health);\\n});\",\n        category: \"production\",\n        importance: \"high\"\n    },\n    {\n        id: \"plugin-system\",\n        title: \"Extensible Plugin System\",\n        icon: \"Layers\",\n        description: \"Flexible plugin architecture for extending functionality and integrating with custom services.\",\n        longDescription: \"Powerful plugin system that allows you to extend macro_api with custom functionality, middleware, and integrations. Create reusable plugins for common patterns and share them across projects.\",\n        benefits: [\n            \"Custom service integrations\",\n            \"Middleware plugin support\",\n            \"Reusable functionality components\",\n            \"Third-party plugin ecosystem\",\n            \"Hot-swappable plugins\",\n            \"Plugin dependency management\"\n        ],\n        technicalDetails: [\n            \"Hook-based plugin architecture\",\n            \"Plugin lifecycle management\",\n            \"Dependency injection system\",\n            \"Configuration validation\",\n            \"Plugin sandboxing\",\n            \"Version compatibility checking\"\n        ],\n        codeExample: \"import { MacroAPIClient, Plugin } from 'macro_api';\\n\\n// Custom plugin for logging\\nclass LoggingPlugin extends Plugin {\\n  name = 'logging-plugin';\\n  version = '1.0.0';\\n\\n  async onRequest(request: any) {\\n    console.log(`[REQUEST] ${request.method} ${request.url}`);\\n    return request;\\n  }\\n\\n  async onResponse(response: any) {\\n    console.log(`[RESPONSE] ${response.status} ${response.statusText}`);\\n    return response;\\n  }\\n\\n  async onError(error: any) {\\n    console.error(`[ERROR] ${error.message}`);\\n    throw error;\\n  }\\n}\\n\\n// Analytics plugin\\nclass AnalyticsPlugin extends Plugin {\\n  name = 'analytics-plugin';\\n  \\n  async onResponse(response: any, context: any) {\\n    await this.trackApiCall({\\n      service: context.service,\\n      method: context.method,\\n      duration: context.duration,\\n      success: !context.error\\n    });\\n    return response;\\n  }\\n}\\n\\n// Use plugins\\nconst client = new MacroAPIClient({\\n  plugins: [\\n    new LoggingPlugin(),\\n    new AnalyticsPlugin({\\n      endpoint: 'https://analytics.example.com',\\n      apiKey: process.env.ANALYTICS_KEY\\n    })\\n  ]\\n});\",\n        category: \"developer-experience\",\n        importance: \"medium\"\n    }\n];\nconst featureCategories = [\n    {\n        id: \"core\",\n        name: \"Core Features\",\n        description: \"Essential functionality that makes macro_api powerful and easy to use\",\n        color: \"blue\",\n        features: features.filter((f)=>f.category === \"core\")\n    },\n    {\n        id: \"developer-experience\",\n        name: \"Developer Experience\",\n        description: \"Features that make development faster, easier, and more enjoyable\",\n        color: \"green\",\n        features: features.filter((f)=>f.category === \"developer-experience\")\n    },\n    {\n        id: \"production\",\n        name: \"Production Ready\",\n        description: \"Enterprise-grade features for reliable, scalable applications\",\n        color: \"purple\",\n        features: features.filter((f)=>f.category === \"production\")\n    },\n    {\n        id: \"performance\",\n        name: \"Performance\",\n        description: \"Optimizations for speed, efficiency, and resource management\",\n        color: \"orange\",\n        features: features.filter((f)=>f.category === \"performance\")\n    }\n];\nconst keyMetrics = [\n    {\n        id: \"api-coverage\",\n        title: \"API Coverage\",\n        value: \"15+\",\n        description: \"Major API services supported\",\n        trend: \"+3 this quarter\",\n        icon: \"Globe\"\n    },\n    {\n        id: \"methods\",\n        title: \"Methods\",\n        value: \"200+\",\n        description: \"Total API methods available\",\n        trend: \"+50 this month\",\n        icon: \"Code\"\n    },\n    {\n        id: \"reliability\",\n        title: \"Reliability\",\n        value: \"99.9%\",\n        description: \"Uptime with error handling\",\n        trend: \"Stable\",\n        icon: \"Shield\"\n    },\n    {\n        id: \"performance\",\n        title: \"Performance\",\n        value: \"< 100ms\",\n        description: \"Average response overhead\",\n        trend: \"-20ms this month\",\n        icon: \"Zap\"\n    },\n    {\n        id: \"type-safety\",\n        title: \"Type Safety\",\n        value: \"100%\",\n        description: \"TypeScript coverage\",\n        trend: \"Full coverage\",\n        icon: \"FileCode\"\n    },\n    {\n        id: \"developer-satisfaction\",\n        title: \"Developer Satisfaction\",\n        value: \"4.8/5\",\n        description: \"Average rating from users\",\n        trend: \"+0.2 this quarter\",\n        icon: \"Heart\"\n    }\n];\nconst comparisonData = [\n    {\n        feature: \"TypeScript Support\",\n        macroApi: \"Full\",\n        competition1: \"Partial\",\n        competition2: \"None\",\n        advantage: \"Complete type safety and IntelliSense\"\n    },\n    {\n        feature: \"Error Handling\",\n        macroApi: \"Advanced\",\n        competition1: \"Basic\",\n        competition2: \"Manual\",\n        advantage: \"Automatic retries, circuit breakers, detailed context\"\n    },\n    {\n        feature: \"Caching\",\n        macroApi: \"Multi-tier\",\n        competition1: \"Memory only\",\n        competition2: \"None\",\n        advantage: \"Memory + Redis + Hybrid with intelligent invalidation\"\n    },\n    {\n        feature: \"API Coverage\",\n        macroApi: \"15+ services\",\n        competition1: \"5-8 services\",\n        competition2: \"3-5 services\",\n        advantage: \"Comprehensive coverage of popular APIs\"\n    },\n    {\n        feature: \"Monitoring\",\n        macroApi: \"Built-in\",\n        competition1: \"Plugin\",\n        competition2: \"External\",\n        advantage: \"Native metrics, tracing, and observability\"\n    },\n    {\n        feature: \"Rate Limiting\",\n        macroApi: \"Intelligent\",\n        competition1: \"Basic\",\n        competition2: \"Manual\",\n        advantage: \"Adaptive algorithms with automatic queue management\"\n    }\n];\nconst useCaseExamples = [\n    {\n        id: \"saas-platform\",\n        title: \"SaaS Platform\",\n        description: \"Build a complete SaaS platform with user management, payments, and AI features\",\n        apis: [\n            \"Stripe\",\n            \"ChatGPT\",\n            \"SendGrid\",\n            \"Slack\"\n        ],\n        complexity: \"Advanced\",\n        timeToImplement: \"2-4 weeks\",\n        features: [\n            \"User authentication and billing\",\n            \"AI-powered features\",\n            \"Email notifications\",\n            \"Team collaboration\"\n        ]\n    },\n    {\n        id: \"content-management\",\n        title: \"Content Management\",\n        description: \"Automate content creation, distribution, and analytics across multiple channels\",\n        apis: [\n            \"ChatGPT\",\n            \"YouTube\",\n            \"Notion\",\n            \"Slack\"\n        ],\n        complexity: \"Intermediate\",\n        timeToImplement: \"1-2 weeks\",\n        features: [\n            \"AI content generation\",\n            \"Multi-platform publishing\",\n            \"Analytics dashboard\",\n            \"Team notifications\"\n        ]\n    },\n    {\n        id: \"ecommerce-automation\",\n        title: \"E-commerce Automation\",\n        description: \"Automate order processing, inventory management, and customer communications\",\n        apis: [\n            \"Stripe\",\n            \"PayPal\",\n            \"SendGrid\",\n            \"Notion\"\n        ],\n        complexity: \"Intermediate\",\n        timeToImplement: \"1-3 weeks\",\n        features: [\n            \"Multi-payment processing\",\n            \"Automated email campaigns\",\n            \"Inventory tracking\",\n            \"Customer analytics\"\n        ]\n    },\n    {\n        id: \"devops-pipeline\",\n        title: \"DevOps Pipeline\",\n        description: \"Complete CI/CD pipeline with deployment automation and monitoring\",\n        apis: [\n            \"GitHub\",\n            \"Vercel\",\n            \"Docker Hub\",\n            \"Slack\",\n            \"S3\"\n        ],\n        complexity: \"Advanced\",\n        timeToImplement: \"2-5 weeks\",\n        features: [\n            \"Automated deployments\",\n            \"Container management\",\n            \"Asset storage\",\n            \"Team notifications\"\n        ]\n    },\n    {\n        id: \"gaming-analytics\",\n        title: \"Gaming Analytics\",\n        description: \"Track player statistics, team performance, and generate leaderboards\",\n        apis: [\n            \"Valorant\",\n            \"Football\",\n            \"Notion\",\n            \"Slack\"\n        ],\n        complexity: \"Beginner\",\n        timeToImplement: \"3-7 days\",\n        features: [\n            \"Player stat tracking\",\n            \"Automated leaderboards\",\n            \"Performance analytics\",\n            \"Achievement notifications\"\n        ]\n    },\n    {\n        id: \"music-platform\",\n        title: \"Music Platform\",\n        description: \"Build music discovery and playlist management features\",\n        apis: [\n            \"Spotify\",\n            \"ChatGPT\",\n            \"Notion\"\n        ],\n        complexity: \"Intermediate\",\n        timeToImplement: \"1-2 weeks\",\n        features: [\n            \"Music search and discovery\",\n            \"AI-powered recommendations\",\n            \"Playlist management\",\n            \"User preferences storage\"\n        ]\n    }\n];\nconst integrationGuides = [\n    {\n        id: \"next-js\",\n        title: \"Next.js Integration\",\n        description: \"Complete guide for using macro_api in Next.js applications\",\n        difficulty: \"Beginner\",\n        timeToComplete: \"15 minutes\",\n        steps: [\n            \"Install macro_api and dependencies\",\n            \"Configure environment variables\",\n            \"Set up API routes\",\n            \"Implement client-side usage\",\n            \"Add error handling\"\n        ]\n    },\n    {\n        id: \"express-js\",\n        title: \"Express.js Backend\",\n        description: \"Build a robust backend API using Express.js and macro_api\",\n        difficulty: \"Intermediate\",\n        timeToComplete: \"30 minutes\",\n        steps: [\n            \"Set up Express server\",\n            \"Configure middleware\",\n            \"Implement API endpoints\",\n            \"Add authentication\",\n            \"Set up webhook handling\"\n        ]\n    },\n    {\n        id: \"serverless\",\n        title: \"Serverless Functions\",\n        description: \"Deploy macro_api in serverless environments\",\n        difficulty: \"Intermediate\",\n        timeToComplete: \"20 minutes\",\n        steps: [\n            \"Configure for serverless\",\n            \"Optimize cold starts\",\n            \"Handle environment variables\",\n            \"Implement caching strategies\",\n            \"Deploy and monitor\"\n        ]\n    },\n    {\n        id: \"docker\",\n        title: \"Docker Deployment\",\n        description: \"Containerize applications using macro_api\",\n        difficulty: \"Advanced\",\n        timeToComplete: \"45 minutes\",\n        steps: [\n            \"Create Dockerfile\",\n            \"Configure environment\",\n            \"Set up health checks\",\n            \"Implement logging\",\n            \"Deploy with orchestration\"\n        ]\n    }\n];\n/* harmony default export */ __webpack_exports__[\"default\"] = (features);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2hvbWUvRmVhdHVyZXMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLHVCQUF1QjtBQWVoQixNQUFNQSxXQUFzQjtJQUNqQztRQUNFQyxJQUFJO1FBQ0pDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLGlCQUFpQjtRQUNqQkMsVUFBVTtZQUNSO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNEO1FBQ0RDLGtCQUFrQjtZQUNoQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsYUFBYztRQWFkQyxVQUFVO1FBQ1ZDLFlBQVk7SUFDZDtJQUNBO1FBQ0VULElBQUk7UUFDSkMsT0FBTztRQUNQQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsaUJBQWlCO1FBQ2pCQyxVQUFVO1lBQ1I7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsa0JBQWtCO1lBQ2hCO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxhQUFjO1FBa0JkQyxVQUFVO1FBQ1ZDLFlBQVk7SUFDZDtJQUNBO1FBQ0VULElBQUk7UUFDSkMsT0FBTztRQUNQQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsaUJBQWlCO1FBQ2pCQyxVQUFVO1lBQ1I7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsa0JBQWtCO1lBQ2hCO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtTQUNEO1FBQ0RFLFVBQVU7UUFDVkMsWUFBWTtJQUNkO0lBQ0E7UUFDRVQsSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxpQkFBaUI7UUFDakJDLFVBQVU7WUFDUjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUNEQyxrQkFBa0I7WUFDaEI7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFDREMsYUFBYztRQW9CZEMsVUFBVTtRQUNWQyxZQUFZO0lBQ2Q7SUFDQTtR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QixNQUFNO1lBQUM7WUFBWTtZQUFZO1lBQVU7U0FBUTtRQUNqREMsWUFBWTtRQUNaQyxpQkFBaUI7UUFDakI1QixVQUFVO1lBQ1I7WUFDQTtZQUNBO1lBQ0E7U0FDRDtJQUNIO0lBQ0E7UUFDRUMsSUFBSTtRQUNKQyxPQUFPO1FBQ1BFLGFBQWE7UUFDYnNCLE1BQU07WUFBQztZQUFXO1lBQVc7U0FBUztRQUN0Q0MsWUFBWTtRQUNaQyxpQkFBaUI7UUFDakI1QixVQUFVO1lBQ1I7WUFDQTtZQUNBO1lBQ0E7U0FDRDtJQUNIO0NBQ0QsQ0FBQztBQUVLLE1BQU02QixvQkFBb0I7SUFDL0I7UUFDRTVCLElBQUk7UUFDSkMsT0FBTztRQUNQRSxhQUFhO1FBQ2IwQixZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsT0FBTztZQUNMO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtJQUNIO0lBQ0E7UUFDRS9CLElBQUk7UUFDSkMsT0FBTztRQUNQRSxhQUFhO1FBQ2IwQixZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsT0FBTztZQUNMO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtJQUNIO0lBQ0E7UUFDRS9CLElBQUk7UUFDSkMsT0FBTztRQUNQRSxhQUFhO1FBQ2IwQixZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsT0FBTztZQUNMO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtJQUNIO0lBQ0E7UUFDRS9CLElBQUk7UUFDSkMsT0FBTztRQUNQRSxhQUFhO1FBQ2IwQixZQUFZO1FBQ1pDLGdCQUFnQjtRQUNoQkMsT0FBTztZQUNMO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtJQUNIO0NBQ0QsQ0FBQztBQUVGLCtEQUFlaEMsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9ob21lL0ZlYXR1cmVzLnRzeD80NGRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kYXRhL2ZlYXR1cmVzLnRzXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEZlYXR1cmUge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBpY29uOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBsb25nRGVzY3JpcHRpb246IHN0cmluZztcclxuICBiZW5lZml0czogc3RyaW5nW107XHJcbiAgdGVjaG5pY2FsRGV0YWlsczogc3RyaW5nW107XHJcbiAgY29kZUV4YW1wbGU/OiBzdHJpbmc7XHJcbiAgY2F0ZWdvcnk6ICdjb3JlJyB8ICdkZXZlbG9wZXItZXhwZXJpZW5jZScgfCAncHJvZHVjdGlvbicgfCAncGVyZm9ybWFuY2UnO1xyXG4gIGltcG9ydGFuY2U6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdyc7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBmZWF0dXJlczogRmVhdHVyZVtdID0gW1xyXG4gIHtcclxuICAgIGlkOiAndW5pZmllZC1pbnRlcmZhY2UnLFxyXG4gICAgdGl0bGU6ICdVbmlmaWVkIEludGVyZmFjZScsXHJcbiAgICBpY29uOiAnQ29tbWFuZCcsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0FjY2VzcyBtdWx0aXBsZSBBUElzIHRocm91Z2ggYSBjb25zaXN0ZW50IGFuZCBpbnR1aXRpdmUgaW50ZXJmYWNlIGRlc2lnbiwgcmVkdWNpbmcgbGVhcm5pbmcgY3VydmVzLicsXHJcbiAgICBsb25nRGVzY3JpcHRpb246ICdPdXIgdW5pZmllZCBpbnRlcmZhY2UgcHJvdmlkZXMgY29uc2lzdGVudCBwYXR0ZXJucyBhY3Jvc3MgYWxsIEFQSSBpbnRlZ3JhdGlvbnMsIG1ha2luZyBpdCBlYXNpZXIgdG8gd29yayB3aXRoIG11bHRpcGxlIHNlcnZpY2VzIHdpdGhvdXQgbGVhcm5pbmcgZGlmZmVyZW50IHBhcmFkaWdtcyBmb3IgZWFjaC4gRXZlcnkgQVBJIGZvbGxvd3MgdGhlIHNhbWUgaW5pdGlhbGl6YXRpb24sIG1ldGhvZCBuYW1pbmcsIGFuZCBlcnJvciBoYW5kbGluZyBwYXR0ZXJucy4nLFxyXG4gICAgYmVuZWZpdHM6IFtcclxuICAgICAgJ0NvbnNpc3RlbnQgbWV0aG9kIG5hbWluZyBhY3Jvc3MgYWxsIEFQSXMnLFxyXG4gICAgICAnU3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nIHBhdHRlcm5zJyxcclxuICAgICAgJ1VuaWZpZWQgYXV0aGVudGljYXRpb24gZmxvd3MnLFxyXG4gICAgICAnU2hhcmVkIGNvbmZpZ3VyYXRpb24gcGF0dGVybnMnLFxyXG4gICAgICAnUmVkdWNlZCBsZWFybmluZyBjdXJ2ZSBmb3IgbmV3IEFQSXMnLFxyXG4gICAgICAnRmFzdGVyIGRldmVsb3BtZW50IHRpbWUnXHJcbiAgICBdLFxyXG4gICAgdGVjaG5pY2FsRGV0YWlsczogW1xyXG4gICAgICAnQWJzdHJhY3QgYmFzZSBjbGFzc2VzIGVuc3VyZSBjb25zaXN0ZW5jeScsXHJcbiAgICAgICdTdGFuZGFyZGl6ZWQgcmVzcG9uc2UgZm9ybWF0cycsXHJcbiAgICAgICdDb21tb24gZXJyb3IgdHlwZXMgYWNyb3NzIGFsbCBzZXJ2aWNlcycsXHJcbiAgICAgICdTaGFyZWQgbWlkZGxld2FyZSBhbmQgaW50ZXJjZXB0b3JzJyxcclxuICAgICAgJ0NvbnNpc3RlbnQgYXN5bmMvYXdhaXQgcGF0dGVybnMnXHJcbiAgICBdLFxyXG4gICAgY29kZUV4YW1wbGU6IGAvLyBTYW1lIHBhdHRlcm4gZm9yIGFsbCBBUElzXHJcbmNvbnN0IGdwdCA9IG5ldyBDaGF0R1BUKHsgYXBpS2V5OiAneW91ci1rZXknIH0pO1xyXG5jb25zdCBzcG90aWZ5ID0gbmV3IFNwb3RpZnlBUEkoeyBjbGllbnRJZDogJ2lkJywgY2xpZW50U2VjcmV0OiAnc2VjcmV0JyB9KTtcclxuY29uc3Qgc3RyaXBlID0gbmV3IFN0cmlwZUFQSSh7IHNlY3JldEtleTogJ2tleScgfSk7XHJcblxyXG4vLyBDb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nXHJcbnRyeSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3B0LmNoYXQoJ0hlbGxvJyk7XHJcbn0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgY29uc29sZS5sb2coZXJyb3Iuc2VydmljZSk7IC8vICdvcGVuYWknXHJcbiAgY29uc29sZS5sb2coZXJyb3IuY29kZSk7ICAgIC8vICdyYXRlX2xpbWl0X2V4Y2VlZGVkJ1xyXG4gIGNvbnNvbGUubG9nKGVycm9yLnJldHJ5QWZ0ZXIpOyAvLyA2MCAoc2Vjb25kcylcclxufWAsXHJcbiAgICBjYXRlZ29yeTogJ2NvcmUnLFxyXG4gICAgaW1wb3J0YW5jZTogJ2hpZ2gnXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ3R5cGVzY3JpcHQtc3VwcG9ydCcsXHJcbiAgICB0aXRsZTogJ1R5cGVTY3JpcHQgU3VwcG9ydCcsXHJcbiAgICBpY29uOiAnRmlsZUNvZGUnLFxyXG4gICAgZGVzY3JpcHRpb246ICdCdWlsdCB3aXRoIFR5cGVTY3JpcHQgZnJvbSB0aGUgZ3JvdW5kIHVwLCBwcm92aWRpbmcgcm9idXN0IHR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCBBUEkgb3BlcmF0aW9ucy4nLFxyXG4gICAgbG9uZ0Rlc2NyaXB0aW9uOiAnQ29tcGxldGUgVHlwZVNjcmlwdCBkZWZpbml0aW9ucyBlbnN1cmUgdHlwZSBzYWZldHksIGJldHRlciBJREUgc3VwcG9ydCwgYW5kIGNhdGNoIGVycm9ycyBhdCBjb21waWxlIHRpbWUgcmF0aGVyIHRoYW4gcnVudGltZS4gRXZlcnkgbWV0aG9kLCByZXNwb25zZSwgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGlzIGZ1bGx5IHR5cGVkLicsXHJcbiAgICBiZW5lZml0czogW1xyXG4gICAgICAnRnVsbCBJbnRlbGxpU2Vuc2Ugc3VwcG9ydCBpbiBWUyBDb2RlJyxcclxuICAgICAgJ0NvbXBpbGUtdGltZSBlcnJvciBkZXRlY3Rpb24nLFxyXG4gICAgICAnQXV0by1jb21wbGV0aW9uIGZvciBhbGwgbWV0aG9kcyBhbmQgcHJvcGVydGllcycsXHJcbiAgICAgICdUeXBlLXNhZmUgQVBJIHJlc3BvbnNlcycsXHJcbiAgICAgICdCZXR0ZXIgcmVmYWN0b3Jpbmcgc3VwcG9ydCcsXHJcbiAgICAgICdTZWxmLWRvY3VtZW50aW5nIGNvZGUgdGhyb3VnaCB0eXBlcydcclxuICAgIF0sXHJcbiAgICB0ZWNobmljYWxEZXRhaWxzOiBbXHJcbiAgICAgICdTdHJpY3QgVHlwZVNjcmlwdCBjb25maWd1cmF0aW9uJyxcclxuICAgICAgJ0dlbmVyaWMgdHlwZXMgZm9yIGZsZXhpYmxlIEFQSSByZXNwb25zZXMnLFxyXG4gICAgICAnRGlzY3JpbWluYXRlZCB1bmlvbnMgZm9yIGRpZmZlcmVudCByZXNwb25zZSB0eXBlcycsXHJcbiAgICAgICdCcmFuZGVkIHR5cGVzIGZvciBJRCB2YWxpZGF0aW9uJyxcclxuICAgICAgJ0NvbmRpdGlvbmFsIHR5cGVzIGZvciBhZHZhbmNlZCB1c2UgY2FzZXMnXHJcbiAgICBdLFxyXG4gICAgY29kZUV4YW1wbGU6IGAvLyBGdWxsIHR5cGUgc2FmZXR5XHJcbmludGVyZmFjZSBDaGF0UmVzcG9uc2Uge1xyXG4gIGNvbnRlbnQ6IHN0cmluZztcclxuICB1c2FnZToge1xyXG4gICAgcHJvbXB0X3Rva2VuczogbnVtYmVyO1xyXG4gICAgY29tcGxldGlvbl90b2tlbnM6IG51bWJlcjtcclxuICAgIHRvdGFsX3Rva2VuczogbnVtYmVyO1xyXG4gIH07XHJcbiAgbW9kZWw6IHN0cmluZztcclxuICBjcmVhdGVkOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IHJlc3BvbnNlOiBDaGF0UmVzcG9uc2UgPSBhd2FpdCBncHQuY3JlYXRlQ2hhdENvbXBsZXRpb24oe1xyXG4gIG1vZGVsOiAnZ3B0LTQnLFxyXG4gIG1lc3NhZ2VzOiBbeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6ICdIZWxsbycgfV0sXHJcbiAgdGVtcGVyYXR1cmU6IDAuN1xyXG59KTtcclxuLy8gICAgXi0tIEZ1bGx5IHR5cGVkIHJlc3BvbnNlIHdpdGggSW50ZWxsaVNlbnNlYCxcclxuICAgIGNhdGVnb3J5OiAnZGV2ZWxvcGVyLWV4cGVyaWVuY2UnLFxyXG4gICAgaW1wb3J0YW5jZTogJ2hpZ2gnXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ2NvbXByZWhlbnNpdmUtY292ZXJhZ2UnLFxyXG4gICAgdGl0bGU6ICdDb21wcmVoZW5zaXZlIENvdmVyYWdlJyxcclxuICAgIGljb246ICdMYXllcnMnLFxyXG4gICAgZGVzY3JpcHRpb246ICdTdXBwb3J0IGZvciBtYWpvciBwbGF0Zm9ybXMgYW5kIHNlcnZpY2VzIHdpdGggZGV0YWlsZWQgbWV0aG9kIGltcGxlbWVudGF0aW9ucyBhbmQgZG9jdW1lbnRhdGlvbi4nLFxyXG4gICAgbG9uZ0Rlc2NyaXB0aW9uOiAnV2Ugc3VwcG9ydCB0aGUgbW9zdCBwb3B1bGFyIEFQSXMgd2l0aCBjb21wcmVoZW5zaXZlIG1ldGhvZCBjb3ZlcmFnZSwgbm90IGp1c3QgYmFzaWMgb3BlcmF0aW9ucy4gRWFjaCBzZXJ2aWNlIGluY2x1ZGVzIGFkdmFuY2VkIGZlYXR1cmVzIGxpa2Ugd2ViaG9va3MsIHN0cmVhbWluZywgYW5kIGJhdGNoIG9wZXJhdGlvbnMuJyxcclxuICAgIGJlbmVmaXRzOiBbXHJcbiAgICAgICcxNSsgbWFqb3IgQVBJIHNlcnZpY2VzIHN1cHBvcnRlZCcsXHJcbiAgICAgICcyMDArIG1ldGhvZHMgYWNyb3NzIGFsbCBzZXJ2aWNlcycsXHJcbiAgICAgICdBZHZhbmNlZCBmZWF0dXJlcyBsaWtlIHN0cmVhbWluZyBhbmQgd2ViaG9va3MnLFxyXG4gICAgICAnUmVndWxhciB1cGRhdGVzIGZvciBuZXcgQVBJIGZlYXR1cmVzJyxcclxuICAgICAgJ0NvbXBsZXRlIGVuZHBvaW50IGNvdmVyYWdlJyxcclxuICAgICAgJ0JhdGNoIG9wZXJhdGlvbiBzdXBwb3J0J1xyXG4gICAgXSxcclxuICAgIHRlY2huaWNhbERldGFpbHM6IFtcclxuICAgICAgJ0Z1bGwgUkVTVCBBUEkgY292ZXJhZ2UnLFxyXG4gICAgICAnV2ViU29ja2V0IGFuZCBTZXJ2ZXItU2VudCBFdmVudHMgc3VwcG9ydCcsXHJcbiAgICAgICdQYWdpbmF0aW9uIGhhbmRsaW5nJyxcclxuICAgICAgJ0ZpbGUgdXBsb2FkL2Rvd25sb2FkIGNhcGFiaWxpdGllcycsXHJcbiAgICAgICdXZWJob29rIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24nLFxyXG4gICAgICAnUmVhbC10aW1lIGRhdGEgc3RyZWFtaW5nJ1xyXG4gICAgXSxcclxuICAgIGNhdGVnb3J5OiAnY29yZScsXHJcbiAgICBpbXBvcnRhbmNlOiAnaGlnaCdcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAnZXJyb3ItaGFuZGxpbmcnLFxyXG4gICAgdGl0bGU6ICdQcm9kdWN0aW9uLVJlYWR5IEVycm9yIEhhbmRsaW5nJyxcclxuICAgIGljb246ICdTaGllbGRBbGVydCcsXHJcbiAgICBkZXNjcmlwdGlvbjogJ1JvYnVzdCBlcnJvciBtYW5hZ2VtZW50IHdpdGggZGV0YWlsZWQgZXJyb3IgaW5mb3JtYXRpb24gZm9yIGVmZmljaWVudCBkZWJ1Z2dpbmcgYW5kIHRyb3VibGVzaG9vdGluZy4nLFxyXG4gICAgbG9uZ0Rlc2NyaXB0aW9uOiAnQnVpbHQtaW4gZXJyb3IgaGFuZGxpbmcgd2l0aCByZXRyeSBsb2dpYywgY2lyY3VpdCBicmVha2VycywgYW5kIGRldGFpbGVkIGVycm9yIGluZm9ybWF0aW9uIGhlbHBzIHlvdSBidWlsZCByZXNpbGllbnQgYXBwbGljYXRpb25zLiBFcnJvcnMgaW5jbHVkZSBjb250ZXh0LCBzdWdnZXN0aW9ucywgYW5kIGF1dG9tYXRpYyByZXRyeSBzdHJhdGVnaWVzLicsXHJcbiAgICBiZW5lZml0czogW1xyXG4gICAgICAnQXV0b21hdGljIHJldHJ5IHdpdGggZXhwb25lbnRpYWwgYmFja29mZicsXHJcbiAgICAgICdDaXJjdWl0IGJyZWFrZXIgcGF0dGVybiBpbXBsZW1lbnRhdGlvbicsXHJcbiAgICAgICdEZXRhaWxlZCBlcnJvciBjb250ZXh0IGFuZCBzdWdnZXN0aW9ucycsXHJcbiAgICAgICdSYXRlIGxpbWl0IGhhbmRsaW5nIGFuZCBxdWV1aW5nJyxcclxuICAgICAgJ0N1c3RvbSBlcnJvciB0eXBlcyBmb3IgZGlmZmVyZW50IHNjZW5hcmlvcycsXHJcbiAgICAgICdFcnJvciBsb2dnaW5nIGFuZCBtb25pdG9yaW5nIGludGVncmF0aW9uJ1xyXG4gICAgXSxcclxuICAgIHRlY2huaWNhbERldGFpbHM6IFtcclxuICAgICAgJ0hpZXJhcmNoaWNhbCBlcnJvciB0eXBlcycsXHJcbiAgICAgICdDb25maWd1cmFibGUgcmV0cnkgc3RyYXRlZ2llcycsXHJcbiAgICAgICdKaXR0ZXIgaW4gYmFja29mZiBjYWxjdWxhdGlvbnMnLFxyXG4gICAgICAnUmVxdWVzdCB0aW1lb3V0IGhhbmRsaW5nJyxcclxuICAgICAgJ0RlYWQgbGV0dGVyIHF1ZXVlIGZvciBmYWlsZWQgcmVxdWVzdHMnLFxyXG4gICAgICAnRXJyb3IgbWV0cmljcyBjb2xsZWN0aW9uJ1xyXG4gICAgXSxcclxuICAgIGNvZGVFeGFtcGxlOiBgaW1wb3J0IHsgUmF0ZUxpbWl0RXJyb3IsIE5ldHdvcmtFcnJvciwgUmV0cnlNYW5hZ2VyIH0gZnJvbSAnbWFjcm9fYXBpJztcclxuXHJcbmNvbnN0IHJldHJ5TWFuYWdlciA9IG5ldyBSZXRyeU1hbmFnZXIoe1xyXG4gIG1heFJldHJpZXM6IDMsXHJcbiAgYmFzZURlbGF5OiAxMDAwLFxyXG4gIG1heERlbGF5OiAzMDAwMFxyXG59KTtcclxuXHJcbnRyeSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnlNYW5hZ2VyLmV4ZWN1dGUoXHJcbiAgICAoKSA9PiBncHQuY2hhdCgnSGVsbG8nKSxcclxuICAgICdjaGF0Z3B0LWNvbXBsZXRpb24nXHJcbiAgKTtcclxufSBjYXRjaCAoZXJyb3IpIHtcclxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSYXRlTGltaXRFcnJvcikge1xyXG4gICAgY29uc29sZS5sb2coXFxgUmF0ZSBsaW1pdGVkLiBSZXRyeSBhZnRlcjogXFwke2Vycm9yLnJldHJ5QWZ0ZXJ9c1xcYCk7XHJcbiAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIE5ldHdvcmtFcnJvcikge1xyXG4gICAgY29uc29sZS5sb2coXFxgTmV0d29yayBpc3N1ZTogXFwke2Vycm9yLm1lc3NhZ2V9XFxgKTtcclxuICB9XHJcbn1gLFxyXG4gICAgY2F0ZWdvcnk6ICdwcm9kdWN0aW9uJyxcclxuICAgIGltcG9ydGFuY2U6ICdoaWdoJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdwcm9taXNlLWJhc2VkJyxcclxuICAgIHRpdGxlOiAnTW9kZXJuIFByb21pc2UtQmFzZWQgQXJjaGl0ZWN0dXJlJyxcclxuICAgIGljb246ICdDbG9jaycsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWx0IG9uIG1vZGVybiBwcm9taXNlLWJhc2VkIGFyY2hpdGVjdHVyZSwgbWFraW5nIGl0IGVhc3kgdG8gaW50ZWdyYXRlIHdpdGggYXN5bmMvYXdhaXQgcGF0dGVybnMuJyxcclxuICAgIGxvbmdEZXNjcmlwdGlvbjogJ0Z1bGx5IGFzeW5jL2F3YWl0IGNvbXBhdGlibGUgd2l0aCBzdXBwb3J0IGZvciBzdHJlYW1pbmcsIHBhcmFsbGVsIGV4ZWN1dGlvbiwgYW5kIGFkdmFuY2VkIGZsb3cgY29udHJvbC4gQWxsIG9wZXJhdGlvbnMgcmV0dXJuIHByb21pc2VzIGFuZCBzdXBwb3J0IGNhbmNlbGxhdGlvbi4nLFxyXG4gICAgYmVuZWZpdHM6IFtcclxuICAgICAgJ05hdGl2ZSBhc3luYy9hd2FpdCBzdXBwb3J0JyxcclxuICAgICAgJ1Byb21pc2UuYWxsKCkgYW5kIFByb21pc2UuYWxsU2V0dGxlZCgpIGNvbXBhdGliaWxpdHknLFxyXG4gICAgICAnU3RyZWFtaW5nIHN1cHBvcnQgZm9yIHJlYWwtdGltZSByZXNwb25zZXMnLFxyXG4gICAgICAnQ2FuY2VsbGFibGUgb3BlcmF0aW9ucyB3aXRoIEFib3J0Q29udHJvbGxlcicsXHJcbiAgICAgICdQYXJhbGxlbCByZXF1ZXN0IGV4ZWN1dGlvbicsXHJcbiAgICAgICdHZW5lcmF0b3IgZnVuY3Rpb25zIGZvciBwYWdpbmF0aW9uJ1xyXG4gICAgXSxcclxuICAgIHRlY2huaWNhbERldGFpbHM6IFtcclxuICAgICAgJ0Fib3J0Q29udHJvbGxlciBpbnRlZ3JhdGlvbicsXHJcbiAgICAgICdTdHJlYW0gcHJvY2Vzc2luZyB3aXRoIGFzeW5jIGl0ZXJhdG9ycycsXHJcbiAgICAgICdQcm9taXNlIHRpbWVvdXQgaGFuZGxpbmcnLFxyXG4gICAgICAnTWVtb3J5LWVmZmljaWVudCBzdHJlYW1pbmcnLFxyXG4gICAgICAnQmFja3ByZXNzdXJlIGhhbmRsaW5nJyxcclxuICAgICAgJ0Nvbm5lY3Rpb24gcG9vbGluZydcclxuICAgIF0sXHJcbiAgICBjb2RlRXhhbXBsZTogYC8vIE1vZGVybiBhc3luYy9hd2FpdCBwYXR0ZXJuc1xyXG5jb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG5cclxuLy8gUGFyYWxsZWwgZXhlY3V0aW9uXHJcbmNvbnN0IFt3ZWF0aGVyLCBuZXdzLCBzdG9ja3NdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gIHdlYXRoZXJBUEkuZ2V0Q3VycmVudCgnTG9uZG9uJyksXHJcbiAgbmV3c0FQSS5nZXRIZWFkbGluZXMoKSxcclxuICBzdG9ja0FQSS5nZXRRdW90ZXMoWydBQVBMJywgJ0dPT0dMJ10pXHJcbl0pO1xyXG5cclxuLy8gU3RyZWFtaW5nIHJlc3BvbnNlc1xyXG5mb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdwdC5zdHJlYW1DaGF0KCdUZWxsIG1lIGEgc3RvcnknKSkge1xyXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNodW5rKTtcclxufVxyXG5cclxuLy8gQ2FuY2VsbGFibGUgb3BlcmF0aW9uc1xyXG5zZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgNTAwMCk7XHJcbmNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaS5sb25nUnVubmluZ09wZXJhdGlvbih7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgfSk7YCxcclxuICAgIGNhdGVnb3J5OiAnZGV2ZWxvcGVyLWV4cGVyaWVuY2UnLFxyXG4gICAgaW1wb3J0YW5jZTogJ21lZGl1bSdcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAnY2FjaGluZycsXHJcbiAgICB0aXRsZTogJ0ludGVsbGlnZW50IENhY2hpbmcgU3lzdGVtJyxcclxuICAgIGljb246ICdDaGVja0NpcmNsZScsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWx0LWluIGNhY2hpbmcgc3lzdGVtIHdpdGggc3VwcG9ydCBmb3IgbWVtb3J5LCBSZWRpcywgYW5kIGh5YnJpZCBjYWNoaW5nIHN0cmF0ZWdpZXMuJyxcclxuICAgIGxvbmdEZXNjcmlwdGlvbjogJ0ludGVsbGlnZW50IGNhY2hpbmcgc3lzdGVtIHdpdGggc3VwcG9ydCBmb3IgbWVtb3J5LCBSZWRpcywgYW5kIGh5YnJpZCBjYWNoaW5nIHN0cmF0ZWdpZXMgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UgYW5kIHJlZHVjZSBBUEkgY29zdHMuIEluY2x1ZGVzIGNhY2hlIHdhcm1pbmcsIGludmFsaWRhdGlvbiwgYW5kIGFuYWx5dGljcy4nLFxyXG4gICAgYmVuZWZpdHM6IFtcclxuICAgICAgJ01lbW9yeSBhbmQgUmVkaXMgY2FjaGUgcHJvdmlkZXJzJyxcclxuICAgICAgJ0h5YnJpZCBjYWNoaW5nIGZvciBvcHRpbWFsIHBlcmZvcm1hbmNlJyxcclxuICAgICAgJ0F1dG9tYXRpYyBjYWNoZSBpbnZhbGlkYXRpb24nLFxyXG4gICAgICAnQ29uZmlndXJhYmxlIFRUTCBwb2xpY2llcycsXHJcbiAgICAgICdDYWNoZSB3YXJtaW5nIHN0cmF0ZWdpZXMnLFxyXG4gICAgICAnQ2FjaGUgaGl0L21pc3MgYW5hbHl0aWNzJ1xyXG4gICAgXSxcclxuICAgIHRlY2huaWNhbERldGFpbHM6IFtcclxuICAgICAgJ0xSVSBldmljdGlvbiBwb2xpY3knLFxyXG4gICAgICAnQ2FjaGUgY29tcHJlc3Npb24gc3VwcG9ydCcsXHJcbiAgICAgICdEaXN0cmlidXRlZCBjYWNoaW5nIHdpdGggUmVkaXMgQ2x1c3RlcicsXHJcbiAgICAgICdDYWNoZSBzdGFtcGVkZSBwcm90ZWN0aW9uJyxcclxuICAgICAgJ1Byb2JhYmlsaXN0aWMgY2FjaGUgd2FybWluZycsXHJcbiAgICAgICdDYWNoZSBtZXRyaWNzIGFuZCBtb25pdG9yaW5nJ1xyXG4gICAgXSxcclxuICAgIGNvZGVFeGFtcGxlOiBgLy8gQ29uZmlndXJlIGludGVsbGlnZW50IGNhY2hpbmdcclxuY29uc3QgY2xpZW50ID0gbmV3IE1hY3JvQVBJQ2xpZW50KHtcclxuICBjYWNoZToge1xyXG4gICAgdHlwZTogJ2h5YnJpZCcsXHJcbiAgICB0dGw6IDM2MDAsIC8vIDEgaG91ciBkZWZhdWx0XHJcbiAgICBtYXhTaXplOiAxMDAwLCAvLyBNZW1vcnkgY2FjaGUgc2l6ZVxyXG4gICAgcmVkaXM6IHsgXHJcbiAgICAgIHVybDogcHJvY2Vzcy5lbnYuUkVESVNfVVJMLFxyXG4gICAgICBrZXlQcmVmaXg6ICdteWFwcCcsXHJcbiAgICAgIGNsdXN0ZXI6IHRydWVcclxuICAgIH0sXHJcbiAgICBjb21wcmVzc2lvbjogdHJ1ZVxyXG4gIH1cclxufSk7XHJcblxyXG4vLyBBdXRvbWF0aWMgY2FjaGluZyB3aXRoIGN1c3RvbSBUVExcclxuY29uc3QgcmVzdWx0ID0gYXdhaXQgY2xpZW50LmV4ZWN1dGUoXHJcbiAgKCkgPT4gc3BvdGlmeS5zZWFyY2goJ0RhZnQgUHVuaycsIFsndHJhY2snXSksXHJcbiAge1xyXG4gICAgc2VydmljZTogJ3Nwb3RpZnknLFxyXG4gICAgbWV0aG9kOiAnc2VhcmNoJyxcclxuICAgIHBhcmFtczogeyBxdWVyeTogJ0RhZnQgUHVuaycsIHR5cGVzOiBbJ3RyYWNrJ10gfSxcclxuICAgIGNhY2hlVHRsOiAxODAwIC8vIDMwIG1pbnV0ZXNcclxuICB9XHJcbik7XHJcblxyXG4vLyBDYWNoZSBzdGF0aXN0aWNzXHJcbmNvbnN0IHN0YXRzID0gYXdhaXQgY2xpZW50LmdldENhY2hlU3RhdHMoKTtcclxuY29uc29sZS5sb2coXFxgSGl0IHJhdGU6IFxcJHsoc3RhdHMuaGl0UmF0ZSAqIDEwMCkudG9GaXhlZCgyKX0lXFxgKTtgLFxyXG4gICAgY2F0ZWdvcnk6ICdwZXJmb3JtYW5jZScsXHJcbiAgICBpbXBvcnRhbmNlOiAnaGlnaCdcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAnY2lyY3VpdC1icmVha2VyJyxcclxuICAgIHRpdGxlOiAnQ2lyY3VpdCBCcmVha2VyIFBhdHRlcm4nLFxyXG4gICAgaWNvbjogJ1NoaWVsZEFsZXJ0JyxcclxuICAgIGRlc2NyaXB0aW9uOiAnQnVpbHQtaW4gY2lyY3VpdCBicmVha2VyIHBhdHRlcm4gdG8gcHJldmVudCBjYXNjYWRpbmcgZmFpbHVyZXMgYW5kIGltcHJvdmUgc3lzdGVtIHJlc2lsaWVuY2UuJyxcclxuICAgIGxvbmdEZXNjcmlwdGlvbjogJ0ltcGxlbWVudCB0aGUgY2lyY3VpdCBicmVha2VyIHBhdHRlcm4gdG8gcHJldmVudCBjYXNjYWRpbmcgZmFpbHVyZXMgd2hlbiBleHRlcm5hbCBzZXJ2aWNlcyBhcmUgdW5hdmFpbGFibGUuIEF1dG9tYXRpY2FsbHkgb3BlbnMgY2lyY3VpdHMgd2hlbiBmYWlsdXJlIHRocmVzaG9sZHMgYXJlIHJlYWNoZWQuJyxcclxuICAgIGJlbmVmaXRzOiBbXHJcbiAgICAgICdQcmV2ZW50cyBjYXNjYWRpbmcgZmFpbHVyZXMnLFxyXG4gICAgICAnQ29uZmlndXJhYmxlIGZhaWx1cmUgdGhyZXNob2xkcycsXHJcbiAgICAgICdBdXRvbWF0aWMgcmVjb3ZlcnkgZGV0ZWN0aW9uJyxcclxuICAgICAgJ0ZhbGxiYWNrIG1lY2hhbmlzbSBzdXBwb3J0JyxcclxuICAgICAgJ1JlYWwtdGltZSBjaXJjdWl0IHN0YXRlIG1vbml0b3JpbmcnLFxyXG4gICAgICAnR3JhY2VmdWwgZGVncmFkYXRpb24nXHJcbiAgICBdLFxyXG4gICAgdGVjaG5pY2FsRGV0YWlsczogW1xyXG4gICAgICAnVGhyZWUgc3RhdGVzOiBDbG9zZWQsIE9wZW4sIEhhbGYtT3BlbicsXHJcbiAgICAgICdDb25maWd1cmFibGUgZmFpbHVyZSBjb3VudCBhbmQgdGltZSB3aW5kb3dzJyxcclxuICAgICAgJ1N1Y2Nlc3MgdGhyZXNob2xkIGZvciByZWNvdmVyeScsXHJcbiAgICAgICdNZXRyaWNzIGNvbGxlY3Rpb24gZm9yIG1vbml0b3JpbmcnLFxyXG4gICAgICAnUGVyLXNlcnZpY2UgY2lyY3VpdCBjb25maWd1cmF0aW9uJyxcclxuICAgICAgJ0ludGVncmF0aW9uIHdpdGggbW9uaXRvcmluZyBzeXN0ZW1zJ1xyXG4gICAgXSxcclxuICAgIGNvZGVFeGFtcGxlOiBgaW1wb3J0IHsgQ2lyY3VpdEJyZWFrZXIgfSBmcm9tICdtYWNyb19hcGknO1xyXG5cclxuY29uc3QgYnJlYWtlciA9IG5ldyBDaXJjdWl0QnJlYWtlcih7XHJcbiAgZmFpbHVyZVRocmVzaG9sZDogNSxcclxuICByZWNvdmVyeVRpbWVvdXQ6IDYwMDAwLCAvLyAxIG1pbnV0ZVxyXG4gIHN1Y2Nlc3NUaHJlc2hvbGQ6IDNcclxufSk7XHJcblxyXG4vLyBVc2Ugd2l0aCBmYWxsYmFja1xyXG5jb25zdCByZXN1bHQgPSBhd2FpdCBicmVha2VyLmV4ZWN1dGUoXHJcbiAgKCkgPT4gZXh0ZXJuYWxBUEkuZ2V0RGF0YSgpLFxyXG4gICgpID0+IGZhbGxiYWNrU2VydmljZS5nZXRDYWNoZWREYXRhKCkgLy8gRmFsbGJhY2sgZnVuY3Rpb25cclxuKTtcclxuXHJcbi8vIE1vbml0b3IgY2lyY3VpdCBzdGF0ZVxyXG5jb25zb2xlLmxvZyhcXGBDaXJjdWl0IHN0YXRlOiBcXCR7YnJlYWtlci5nZXRTdGF0ZSgpfVxcYCk7XHJcbmNvbnNvbGUubG9nKFxcYEZhaWx1cmUgY291bnQ6IFxcJHticmVha2VyLmdldEZhaWx1cmVDb3VudCgpfVxcYCk7YCxcclxuICAgIGNhdGVnb3J5OiAncHJvZHVjdGlvbicsXHJcbiAgICBpbXBvcnRhbmNlOiAnbWVkaXVtJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdyZXF1ZXN0LWJhdGNoaW5nJyxcclxuICAgIHRpdGxlOiAnUmVxdWVzdCBCYXRjaGluZycsXHJcbiAgICBpY29uOiAnTGF5ZXJzJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnQXV0b21hdGljYWxseSBiYXRjaCBtdWx0aXBsZSByZXF1ZXN0cyB0byByZWR1Y2UgQVBJIGNhbGxzIGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlLicsXHJcbiAgICBsb25nRGVzY3JpcHRpb246ICdJbnRlbGxpZ2VudCByZXF1ZXN0IGJhdGNoaW5nIHN5c3RlbSB0aGF0IGF1dG9tYXRpY2FsbHkgZ3JvdXBzIHNpbWlsYXIgcmVxdWVzdHMgdG9nZXRoZXIgdG8gcmVkdWNlIEFQSSBjYWxscyBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZSB3aGlsZSByZXNwZWN0aW5nIHJhdGUgbGltaXRzLicsXHJcbiAgICBiZW5lZml0czogW1xyXG4gICAgICAnUmVkdWNlZCBBUEkgY2FsbCBjb3VudCcsXHJcbiAgICAgICdMb3dlciBsYXRlbmN5IGZvciBidWxrIG9wZXJhdGlvbnMnLFxyXG4gICAgICAnQXV0b21hdGljIHJlcXVlc3QgZ3JvdXBpbmcnLFxyXG4gICAgICAnQ29uZmlndXJhYmxlIGJhdGNoIHNpemVzJyxcclxuICAgICAgJ1JhdGUgbGltaXQgb3B0aW1pemF0aW9uJyxcclxuICAgICAgJ0Nvc3QgcmVkdWN0aW9uIGZvciBwYWlkIEFQSXMnXHJcbiAgICBdLFxyXG4gICAgdGVjaG5pY2FsRGV0YWlsczogW1xyXG4gICAgICAnQXV0b21hdGljIHJlcXVlc3QgZGVkdXBsaWNhdGlvbicsXHJcbiAgICAgICdUaW1lLWJhc2VkIGFuZCBzaXplLWJhc2VkIGJhdGNoaW5nJyxcclxuICAgICAgJ1ByaW9yaXR5IHF1ZXVlIGZvciB1cmdlbnQgcmVxdWVzdHMnLFxyXG4gICAgICAnQmF0Y2ggc3BsaXR0aW5nIGZvciBsYXJnZSByZXF1ZXN0cycsXHJcbiAgICAgICdQYXJ0aWFsIGZhaWx1cmUgaGFuZGxpbmcnLFxyXG4gICAgICAnTWV0cmljcyBmb3IgYmF0Y2ggZWZmaWNpZW5jeSdcclxuICAgIF0sXHJcbiAgICBjb2RlRXhhbXBsZTogYC8vIEF1dG9tYXRpYyByZXF1ZXN0IGJhdGNoaW5nXHJcbmNvbnN0IGJhdGNoZXIgPSBuZXcgUmVxdWVzdEJhdGNoZXIoe1xyXG4gIG1heEJhdGNoU2l6ZTogMTAwLFxyXG4gIG1heFdhaXRUaW1lOiAxMDAwLCAvLyAxIHNlY29uZFxyXG4gIGRlZHVwbGljYXRlOiB0cnVlXHJcbn0pO1xyXG5cclxuLy8gVGhlc2UgcmVxdWVzdHMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJhdGNoZWRcclxuY29uc3QgcHJvbWlzZXMgPSB1c2VySWRzLm1hcChpZCA9PiBcclxuICBiYXRjaGVyLmV4ZWN1dGUoJ2dldFVzZXInLCB7IGlkIH0pXHJcbik7XHJcblxyXG5jb25zdCB1c2VycyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuXHJcbi8vIE1hbnVhbCBiYXRjaGluZyBmb3Igc3BlY2lmaWMgdXNlIGNhc2VzXHJcbmNvbnN0IGJhdGNoUmVzdWx0ID0gYXdhaXQgYXBpLmJhdGNoR2V0VXNlcnMoe1xyXG4gIGlkczogWzEsIDIsIDMsIDQsIDVdLFxyXG4gIGZpZWxkczogWyduYW1lJywgJ2VtYWlsJywgJ2F2YXRhciddXHJcbn0pO2AsXHJcbiAgICBjYXRlZ29yeTogJ3BlcmZvcm1hbmNlJyxcclxuICAgIGltcG9ydGFuY2U6ICdtZWRpdW0nXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ3dlYmhvb2stdmVyaWZpY2F0aW9uJyxcclxuICAgIHRpdGxlOiAnV2ViaG9vayBWZXJpZmljYXRpb24nLFxyXG4gICAgaWNvbjogJ1NoaWVsZEFsZXJ0JyxcclxuICAgIGRlc2NyaXB0aW9uOiAnQnVpbHQtaW4gd2ViaG9vayBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZvciBzZWN1cmUgZXZlbnQgaGFuZGxpbmcgZnJvbSBleHRlcm5hbCBzZXJ2aWNlcy4nLFxyXG4gICAgbG9uZ0Rlc2NyaXB0aW9uOiAnU2VjdXJlIHdlYmhvb2sgaGFuZGxpbmcgd2l0aCBhdXRvbWF0aWMgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgcGF5bG9hZCB2YWxpZGF0aW9uLCBhbmQgcmVwbGF5IGF0dGFjayBwcmV2ZW50aW9uIGZvciBhbGwgc3VwcG9ydGVkIHNlcnZpY2VzLicsXHJcbiAgICBiZW5lZml0czogW1xyXG4gICAgICAnQXV0b21hdGljIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24nLFxyXG4gICAgICAnUmVwbGF5IGF0dGFjayBwcmV2ZW50aW9uJyxcclxuICAgICAgJ1BheWxvYWQgdmFsaWRhdGlvbicsXHJcbiAgICAgICdNdWx0aS1zZXJ2aWNlIHdlYmhvb2sgc3VwcG9ydCcsXHJcbiAgICAgICdFdmVudCByb3V0aW5nIGFuZCBmaWx0ZXJpbmcnLFxyXG4gICAgICAnRXJyb3IgaGFuZGxpbmcgYW5kIHJldHJpZXMnXHJcbiAgICBdLFxyXG4gICAgdGVjaG5pY2FsRGV0YWlsczogW1xyXG4gICAgICAnSE1BQyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uJyxcclxuICAgICAgJ1RpbWVzdGFtcC1iYXNlZCByZXBsYXkgcHJvdGVjdGlvbicsXHJcbiAgICAgICdDb25maWd1cmFibGUgdG9sZXJhbmNlIHdpbmRvd3MnLFxyXG4gICAgICAnRXZlbnQgdHlwZSBmaWx0ZXJpbmcnLFxyXG4gICAgICAnTWlkZGxld2FyZS1iYXNlZCBwcm9jZXNzaW5nJyxcclxuICAgICAgJ0RlYWQgbGV0dGVyIHF1ZXVlIGZvciBmYWlsZWQgZXZlbnRzJ1xyXG4gICAgXSxcclxuICAgIGNvZGVFeGFtcGxlOiBgaW1wb3J0IHsgV2ViaG9va1ZlcmlmaWVyIH0gZnJvbSAnbWFjcm9fYXBpJztcclxuXHJcbmNvbnN0IHZlcmlmaWVyID0gbmV3IFdlYmhvb2tWZXJpZmllcih7XHJcbiAgc3RyaXBlOiB7IHNlY3JldDogcHJvY2Vzcy5lbnYuU1RSSVBFX1dFQkhPT0tfU0VDUkVUIH0sXHJcbiAgZ2l0aHViOiB7IHNlY3JldDogcHJvY2Vzcy5lbnYuR0lUSFVCX1dFQkhPT0tfU0VDUkVUIH0sXHJcbiAgc2xhY2s6IHsgc2VjcmV0OiBwcm9jZXNzLmVudi5TTEFDS19XRUJIT09LX1NFQ1JFVCB9XHJcbn0pO1xyXG5cclxuLy8gRXhwcmVzcy5qcyB3ZWJob29rIGhhbmRsZXJcclxuYXBwLnBvc3QoJy93ZWJob29rcy86c2VydmljZScsIGFzeW5jIChyZXEsIHJlcykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBldmVudCA9IGF3YWl0IHZlcmlmaWVyLnZlcmlmeShcclxuICAgICAgcmVxLnBhcmFtcy5zZXJ2aWNlLFxyXG4gICAgICByZXEuYm9keSxcclxuICAgICAgcmVxLmhlYWRlcnNcclxuICAgICk7XHJcbiAgICBcclxuICAgIC8vIFByb2Nlc3MgdmVyaWZpZWQgZXZlbnRcclxuICAgIGF3YWl0IHByb2Nlc3NXZWJob29rRXZlbnQoZXZlbnQpO1xyXG4gICAgcmVzLnN0YXR1cygyMDApLnNlbmQoJ09LJyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1dlYmhvb2sgdmVyaWZpY2F0aW9uIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICByZXMuc3RhdHVzKDQwMCkuc2VuZCgnSW52YWxpZCBzaWduYXR1cmUnKTtcclxuICB9XHJcbn0pO2AsXHJcbiAgICBjYXRlZ29yeTogJ3Byb2R1Y3Rpb24nLFxyXG4gICAgaW1wb3J0YW5jZTogJ21lZGl1bSdcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAncmF0ZS1saW1pdGluZycsXHJcbiAgICB0aXRsZTogJ0FkdmFuY2VkIFJhdGUgTGltaXRpbmcnLFxyXG4gICAgaWNvbjogJ0Nsb2NrJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnSW50ZWxsaWdlbnQgcmF0ZSBsaW1pdGluZyB0aGF0IHJlc3BlY3RzIEFQSSBxdW90YXMgYW5kIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBiYWNrb2ZmIHN0cmF0ZWdpZXMuJyxcclxuICAgIGxvbmdEZXNjcmlwdGlvbjogJ1NtYXJ0IHJhdGUgbGltaXRpbmcgc3lzdGVtIHRoYXQgYXV0b21hdGljYWxseSByZXNwZWN0cyBBUEkgcmF0ZSBsaW1pdHMsIGltcGxlbWVudHMgYmFja29mZiBzdHJhdGVnaWVzLCBhbmQgcXVldWVzIHJlcXVlc3RzIHRvIG1heGltaXplIHRocm91Z2hwdXQgd2hpbGUgc3RheWluZyB3aXRoaW4gbGltaXRzLicsXHJcbiAgICBiZW5lZml0czogW1xyXG4gICAgICAnQXV0b21hdGljIHJhdGUgbGltaXQgZGV0ZWN0aW9uJyxcclxuICAgICAgJ0ludGVsbGlnZW50IHJlcXVlc3QgcXVldWluZycsXHJcbiAgICAgICdQZXItZW5kcG9pbnQgcmF0ZSBsaW1pdGluZycsXHJcbiAgICAgICdBZGFwdGl2ZSBiYWNrb2ZmIHN0cmF0ZWdpZXMnLFxyXG4gICAgICAnUHJpb3JpdHktYmFzZWQgcmVxdWVzdCBoYW5kbGluZycsXHJcbiAgICAgICdSYXRlIGxpbWl0IGFuYWx5dGljcydcclxuICAgIF0sXHJcbiAgICB0ZWNobmljYWxEZXRhaWxzOiBbXHJcbiAgICAgICdUb2tlbiBidWNrZXQgYWxnb3JpdGhtJyxcclxuICAgICAgJ1NsaWRpbmcgd2luZG93IHJhdGUgbGltaXRpbmcnLFxyXG4gICAgICAnRGlzdHJpYnV0ZWQgcmF0ZSBsaW1pdGluZyB3aXRoIFJlZGlzJyxcclxuICAgICAgJ1Blci11c2VyIGFuZCBwZXItQVBJIGtleSBsaW1pdHMnLFxyXG4gICAgICAnUmF0ZSBsaW1pdCBoZWFkZXIgcGFyc2luZycsXHJcbiAgICAgICdQcmVkaWN0aXZlIHJhdGUgbGltaXRpbmcnXHJcbiAgICBdLFxyXG4gICAgY29kZUV4YW1wbGU6IGBpbXBvcnQgeyBSYXRlTGltaXRlciB9IGZyb20gJ21hY3JvX2FwaSc7XHJcblxyXG5jb25zdCBsaW1pdGVyID0gbmV3IFJhdGVMaW1pdGVyKHtcclxuICBvcGVuYWk6IHsgcmVxdWVzdHNQZXJNaW51dGU6IDYwLCB0b2tlbnNQZXJNaW51dGU6IDkwMDAwIH0sXHJcbiAgc3RyaXBlOiB7IHJlcXVlc3RzUGVyU2Vjb25kOiAyNSB9LFxyXG4gIHNwb3RpZnk6IHsgcmVxdWVzdHNQZXJTZWNvbmQ6IDEwIH1cclxufSk7XHJcblxyXG4vLyBBdXRvbWF0aWMgcmF0ZSBsaW1pdGluZ1xyXG5jb25zdCBjbGllbnQgPSBuZXcgTWFjcm9BUElDbGllbnQoe1xyXG4gIHJhdGVMaW1pdGluZzoge1xyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHN0cmF0ZWd5OiAnYWRhcHRpdmUnLFxyXG4gICAgcXVldWVTaXplOiAxMDAwLFxyXG4gICAgcHJpb3JpdHlMZXZlbHM6IDNcclxuICB9XHJcbn0pO1xyXG5cclxuLy8gSGlnaCBwcmlvcml0eSByZXF1ZXN0XHJcbmNvbnN0IHVyZ2VudFJlc3VsdCA9IGF3YWl0IGNsaWVudC5leGVjdXRlKFxyXG4gICgpID0+IGFwaS5jcml0aWNhbE9wZXJhdGlvbigpLFxyXG4gIHsgcHJpb3JpdHk6ICdoaWdoJyB9XHJcbik7XHJcblxyXG4vLyBHZXQgcmF0ZSBsaW1pdCBzdGF0dXNcclxuY29uc3Qgc3RhdHVzID0gYXdhaXQgbGltaXRlci5nZXRTdGF0dXMoJ29wZW5haScpO1xyXG5jb25zb2xlLmxvZyhcXGBSZW1haW5pbmcgcmVxdWVzdHM6IFxcJHtzdGF0dXMucmVtYWluaW5nfVxcYCk7XHJcbmNvbnNvbGUubG9nKFxcYFJlc2V0IHRpbWU6IFxcJHtzdGF0dXMucmVzZXRUaW1lfVxcYCk7YCxcclxuICAgIGNhdGVnb3J5OiAncHJvZHVjdGlvbicsXHJcbiAgICBpbXBvcnRhbmNlOiAnaGlnaCdcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAnbW9uaXRvcmluZy1vYnNlcnZhYmlsaXR5JyxcclxuICAgIHRpdGxlOiAnTW9uaXRvcmluZyAmIE9ic2VydmFiaWxpdHknLFxyXG4gICAgaWNvbjogJ0NoZWNrQ2lyY2xlJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnQnVpbHQtaW4gbWV0cmljcyBjb2xsZWN0aW9uLCBsb2dnaW5nLCBhbmQgb2JzZXJ2YWJpbGl0eSBmZWF0dXJlcyBmb3IgcHJvZHVjdGlvbiBtb25pdG9yaW5nLicsXHJcbiAgICBsb25nRGVzY3JpcHRpb246ICdDb21wcmVoZW5zaXZlIG1vbml0b3JpbmcgYW5kIG9ic2VydmFiaWxpdHkgZmVhdHVyZXMgaW5jbHVkaW5nIG1ldHJpY3MgY29sbGVjdGlvbiwgc3RydWN0dXJlZCBsb2dnaW5nLCBkaXN0cmlidXRlZCB0cmFjaW5nLCBhbmQgaW50ZWdyYXRpb24gd2l0aCBwb3B1bGFyIG1vbml0b3JpbmcgcGxhdGZvcm1zLicsXHJcbiAgICBiZW5lZml0czogW1xyXG4gICAgICAnQXV0b21hdGljIG1ldHJpY3MgY29sbGVjdGlvbicsXHJcbiAgICAgICdTdHJ1Y3R1cmVkIGxvZ2dpbmcnLFxyXG4gICAgICAnRGlzdHJpYnV0ZWQgdHJhY2luZyBzdXBwb3J0JyxcclxuICAgICAgJ1BlcmZvcm1hbmNlIG1vbml0b3JpbmcnLFxyXG4gICAgICAnRXJyb3IgdHJhY2tpbmcgYW5kIGFsZXJ0aW5nJyxcclxuICAgICAgJ0hlYWx0aCBjaGVjayBlbmRwb2ludHMnXHJcbiAgICBdLFxyXG4gICAgdGVjaG5pY2FsRGV0YWlsczogW1xyXG4gICAgICAnT3BlblRlbGVtZXRyeSBpbnRlZ3JhdGlvbicsXHJcbiAgICAgICdQcm9tZXRoZXVzIG1ldHJpY3MgZXhwb3J0JyxcclxuICAgICAgJ0N1c3RvbSBtZXRyaWNzIGFuZCBldmVudHMnLFxyXG4gICAgICAnUmVxdWVzdC9yZXNwb25zZSBsb2dnaW5nJyxcclxuICAgICAgJ1BlcmZvcm1hbmNlIGJlbmNobWFya2luZycsXHJcbiAgICAgICdJbnRlZ3JhdGlvbiB3aXRoIEFQTSB0b29scydcclxuICAgIF0sXHJcbiAgICBjb2RlRXhhbXBsZTogYGltcG9ydCB7IE1hY3JvQVBJQ2xpZW50LCBNZXRyaWNzQ29sbGVjdG9yIH0gZnJvbSAnbWFjcm9fYXBpJztcclxuXHJcbmNvbnN0IGNsaWVudCA9IG5ldyBNYWNyb0FQSUNsaWVudCh7XHJcbiAgbW9uaXRvcmluZzoge1xyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIG1ldHJpY3NDb2xsZWN0b3I6IG5ldyBNZXRyaWNzQ29sbGVjdG9yKHtcclxuICAgICAgZXhwb3J0SW50ZXJ2YWw6IDYwMDAwLCAvLyAxIG1pbnV0ZVxyXG4gICAgICBsYWJlbHM6IHtcclxuICAgICAgICBzZXJ2aWNlOiAnbXktYXBwJyxcclxuICAgICAgICBlbnZpcm9ubWVudDogcHJvY2Vzcy5lbnYuTk9ERV9FTlZcclxuICAgICAgfVxyXG4gICAgfSksXHJcbiAgICB0cmFjaW5nOiB7XHJcbiAgICAgIHNlcnZpY2VOYW1lOiAnbWFjcm8tYXBpLWNsaWVudCcsXHJcbiAgICAgIGphZWdlckVuZHBvaW50OiBwcm9jZXNzLmVudi5KQUVHRVJfRU5EUE9JTlRcclxuICAgIH0sXHJcbiAgICBsb2dnaW5nOiB7XHJcbiAgICAgIGxldmVsOiAnaW5mbycsXHJcbiAgICAgIGZvcm1hdDogJ2pzb24nLFxyXG4gICAgICBpbmNsdWRlUmVxdWVzdEJvZHk6IGZhbHNlLFxyXG4gICAgICBpbmNsdWRlUmVzcG9uc2VCb2R5OiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcblxyXG4vLyBBdXRvbWF0aWMgbWV0cmljcyBjb2xsZWN0aW9uXHJcbmNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5leGVjdXRlKFxyXG4gICgpID0+IGdwdC5jaGF0KCdIZWxsbycpLFxyXG4gIHtcclxuICAgIHNlcnZpY2U6ICdvcGVuYWknLFxyXG4gICAgbWV0aG9kOiAnY2hhdCcsXHJcbiAgICB0YWdzOiB7IG9wZXJhdGlvbjogJ3VzZXItcXVlcnknIH1cclxuICB9XHJcbik7XHJcblxyXG4vLyBDdXN0b20gbWV0cmljc1xyXG5jbGllbnQubWV0cmljcy5pbmNyZW1lbnQoJ2N1c3RvbS5hcGkuY2FsbHMnLCB7XHJcbiAgZW5kcG9pbnQ6ICcvY2hhdCcsXHJcbiAgc3RhdHVzOiAnc3VjY2VzcydcclxufSk7XHJcblxyXG4vLyBIZWFsdGggY2hlY2sgZW5kcG9pbnRcclxuYXBwLmdldCgnL2hlYWx0aCcsIChyZXEsIHJlcykgPT4ge1xyXG4gIGNvbnN0IGhlYWx0aCA9IGNsaWVudC5nZXRIZWFsdGhTdGF0dXMoKTtcclxuICByZXMuc3RhdHVzKGhlYWx0aC5zdGF0dXMgPT09ICdoZWFsdGh5JyA/IDIwMCA6IDUwMykuanNvbihoZWFsdGgpO1xyXG59KTtgLFxyXG4gICAgY2F0ZWdvcnk6ICdwcm9kdWN0aW9uJyxcclxuICAgIGltcG9ydGFuY2U6ICdoaWdoJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdwbHVnaW4tc3lzdGVtJyxcclxuICAgIHRpdGxlOiAnRXh0ZW5zaWJsZSBQbHVnaW4gU3lzdGVtJyxcclxuICAgIGljb246ICdMYXllcnMnLFxyXG4gICAgZGVzY3JpcHRpb246ICdGbGV4aWJsZSBwbHVnaW4gYXJjaGl0ZWN0dXJlIGZvciBleHRlbmRpbmcgZnVuY3Rpb25hbGl0eSBhbmQgaW50ZWdyYXRpbmcgd2l0aCBjdXN0b20gc2VydmljZXMuJyxcclxuICAgIGxvbmdEZXNjcmlwdGlvbjogJ1Bvd2VyZnVsIHBsdWdpbiBzeXN0ZW0gdGhhdCBhbGxvd3MgeW91IHRvIGV4dGVuZCBtYWNyb19hcGkgd2l0aCBjdXN0b20gZnVuY3Rpb25hbGl0eSwgbWlkZGxld2FyZSwgYW5kIGludGVncmF0aW9ucy4gQ3JlYXRlIHJldXNhYmxlIHBsdWdpbnMgZm9yIGNvbW1vbiBwYXR0ZXJucyBhbmQgc2hhcmUgdGhlbSBhY3Jvc3MgcHJvamVjdHMuJyxcclxuICAgIGJlbmVmaXRzOiBbXHJcbiAgICAgICdDdXN0b20gc2VydmljZSBpbnRlZ3JhdGlvbnMnLFxyXG4gICAgICAnTWlkZGxld2FyZSBwbHVnaW4gc3VwcG9ydCcsXHJcbiAgICAgICdSZXVzYWJsZSBmdW5jdGlvbmFsaXR5IGNvbXBvbmVudHMnLFxyXG4gICAgICAnVGhpcmQtcGFydHkgcGx1Z2luIGVjb3N5c3RlbScsXHJcbiAgICAgICdIb3Qtc3dhcHBhYmxlIHBsdWdpbnMnLFxyXG4gICAgICAnUGx1Z2luIGRlcGVuZGVuY3kgbWFuYWdlbWVudCdcclxuICAgIF0sXHJcbiAgICB0ZWNobmljYWxEZXRhaWxzOiBbXHJcbiAgICAgICdIb29rLWJhc2VkIHBsdWdpbiBhcmNoaXRlY3R1cmUnLFxyXG4gICAgICAnUGx1Z2luIGxpZmVjeWNsZSBtYW5hZ2VtZW50JyxcclxuICAgICAgJ0RlcGVuZGVuY3kgaW5qZWN0aW9uIHN5c3RlbScsXHJcbiAgICAgICdDb25maWd1cmF0aW9uIHZhbGlkYXRpb24nLFxyXG4gICAgICAnUGx1Z2luIHNhbmRib3hpbmcnLFxyXG4gICAgICAnVmVyc2lvbiBjb21wYXRpYmlsaXR5IGNoZWNraW5nJ1xyXG4gICAgXSxcclxuICAgIGNvZGVFeGFtcGxlOiBgaW1wb3J0IHsgTWFjcm9BUElDbGllbnQsIFBsdWdpbiB9IGZyb20gJ21hY3JvX2FwaSc7XHJcblxyXG4vLyBDdXN0b20gcGx1Z2luIGZvciBsb2dnaW5nXHJcbmNsYXNzIExvZ2dpbmdQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG4gIG5hbWUgPSAnbG9nZ2luZy1wbHVnaW4nO1xyXG4gIHZlcnNpb24gPSAnMS4wLjAnO1xyXG5cclxuICBhc3luYyBvblJlcXVlc3QocmVxdWVzdDogYW55KSB7XHJcbiAgICBjb25zb2xlLmxvZyhcXGBbUkVRVUVTVF0gXFwke3JlcXVlc3QubWV0aG9kfSBcXCR7cmVxdWVzdC51cmx9XFxgKTtcclxuICAgIHJldHVybiByZXF1ZXN0O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgb25SZXNwb25zZShyZXNwb25zZTogYW55KSB7XHJcbiAgICBjb25zb2xlLmxvZyhcXGBbUkVTUE9OU0VdIFxcJHtyZXNwb25zZS5zdGF0dXN9IFxcJHtyZXNwb25zZS5zdGF0dXNUZXh0fVxcYCk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgfVxyXG5cclxuICBhc3luYyBvbkVycm9yKGVycm9yOiBhbnkpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXFxgW0VSUk9SXSBcXCR7ZXJyb3IubWVzc2FnZX1cXGApO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBbmFseXRpY3MgcGx1Z2luXHJcbmNsYXNzIEFuYWx5dGljc1BsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcbiAgbmFtZSA9ICdhbmFseXRpY3MtcGx1Z2luJztcclxuICBcclxuICBhc3luYyBvblJlc3BvbnNlKHJlc3BvbnNlOiBhbnksIGNvbnRleHQ6IGFueSkge1xyXG4gICAgYXdhaXQgdGhpcy50cmFja0FwaUNhbGwoe1xyXG4gICAgICBzZXJ2aWNlOiBjb250ZXh0LnNlcnZpY2UsXHJcbiAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXHJcbiAgICAgIGR1cmF0aW9uOiBjb250ZXh0LmR1cmF0aW9uLFxyXG4gICAgICBzdWNjZXNzOiAhY29udGV4dC5lcnJvclxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBVc2UgcGx1Z2luc1xyXG5jb25zdCBjbGllbnQgPSBuZXcgTWFjcm9BUElDbGllbnQoe1xyXG4gIHBsdWdpbnM6IFtcclxuICAgIG5ldyBMb2dnaW5nUGx1Z2luKCksXHJcbiAgICBuZXcgQW5hbHl0aWNzUGx1Z2luKHtcclxuICAgICAgZW5kcG9pbnQ6ICdodHRwczovL2FuYWx5dGljcy5leGFtcGxlLmNvbScsXHJcbiAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuQU5BTFlUSUNTX0tFWVxyXG4gICAgfSlcclxuICBdXHJcbn0pO2AsXHJcbiAgICBjYXRlZ29yeTogJ2RldmVsb3Blci1leHBlcmllbmNlJyxcclxuICAgIGltcG9ydGFuY2U6ICdtZWRpdW0nXHJcbiAgfVxyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IGZlYXR1cmVDYXRlZ29yaWVzID0gW1xyXG4gIHtcclxuICAgIGlkOiAnY29yZScsXHJcbiAgICBuYW1lOiAnQ29yZSBGZWF0dXJlcycsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0Vzc2VudGlhbCBmdW5jdGlvbmFsaXR5IHRoYXQgbWFrZXMgbWFjcm9fYXBpIHBvd2VyZnVsIGFuZCBlYXN5IHRvIHVzZScsXHJcbiAgICBjb2xvcjogJ2JsdWUnLFxyXG4gICAgZmVhdHVyZXM6IGZlYXR1cmVzLmZpbHRlcihmID0+IGYuY2F0ZWdvcnkgPT09ICdjb3JlJylcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAnZGV2ZWxvcGVyLWV4cGVyaWVuY2UnLFxyXG4gICAgbmFtZTogJ0RldmVsb3BlciBFeHBlcmllbmNlJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnRmVhdHVyZXMgdGhhdCBtYWtlIGRldmVsb3BtZW50IGZhc3RlciwgZWFzaWVyLCBhbmQgbW9yZSBlbmpveWFibGUnLFxyXG4gICAgY29sb3I6ICdncmVlbicsXHJcbiAgICBmZWF0dXJlczogZmVhdHVyZXMuZmlsdGVyKGYgPT4gZi5jYXRlZ29yeSA9PT0gJ2RldmVsb3Blci1leHBlcmllbmNlJylcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAncHJvZHVjdGlvbicsXHJcbiAgICBuYW1lOiAnUHJvZHVjdGlvbiBSZWFkeScsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0VudGVycHJpc2UtZ3JhZGUgZmVhdHVyZXMgZm9yIHJlbGlhYmxlLCBzY2FsYWJsZSBhcHBsaWNhdGlvbnMnLFxyXG4gICAgY29sb3I6ICdwdXJwbGUnLFxyXG4gICAgZmVhdHVyZXM6IGZlYXR1cmVzLmZpbHRlcihmID0+IGYuY2F0ZWdvcnkgPT09ICdwcm9kdWN0aW9uJylcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAncGVyZm9ybWFuY2UnLFxyXG4gICAgbmFtZTogJ1BlcmZvcm1hbmNlJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnT3B0aW1pemF0aW9ucyBmb3Igc3BlZWQsIGVmZmljaWVuY3ksIGFuZCByZXNvdXJjZSBtYW5hZ2VtZW50JyxcclxuICAgIGNvbG9yOiAnb3JhbmdlJyxcclxuICAgIGZlYXR1cmVzOiBmZWF0dXJlcy5maWx0ZXIoZiA9PiBmLmNhdGVnb3J5ID09PSAncGVyZm9ybWFuY2UnKVxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBrZXlNZXRyaWNzID0gW1xyXG4gIHtcclxuICAgIGlkOiAnYXBpLWNvdmVyYWdlJyxcclxuICAgIHRpdGxlOiAnQVBJIENvdmVyYWdlJyxcclxuICAgIHZhbHVlOiAnMTUrJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnTWFqb3IgQVBJIHNlcnZpY2VzIHN1cHBvcnRlZCcsXHJcbiAgICB0cmVuZDogJyszIHRoaXMgcXVhcnRlcicsXHJcbiAgICBpY29uOiAnR2xvYmUnXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ21ldGhvZHMnLFxyXG4gICAgdGl0bGU6ICdNZXRob2RzJyxcclxuICAgIHZhbHVlOiAnMjAwKycsXHJcbiAgICBkZXNjcmlwdGlvbjogJ1RvdGFsIEFQSSBtZXRob2RzIGF2YWlsYWJsZScsXHJcbiAgICB0cmVuZDogJys1MCB0aGlzIG1vbnRoJyxcclxuICAgIGljb246ICdDb2RlJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdyZWxpYWJpbGl0eScsXHJcbiAgICB0aXRsZTogJ1JlbGlhYmlsaXR5JyxcclxuICAgIHZhbHVlOiAnOTkuOSUnLFxyXG4gICAgZGVzY3JpcHRpb246ICdVcHRpbWUgd2l0aCBlcnJvciBoYW5kbGluZycsXHJcbiAgICB0cmVuZDogJ1N0YWJsZScsXHJcbiAgICBpY29uOiAnU2hpZWxkJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdwZXJmb3JtYW5jZScsXHJcbiAgICB0aXRsZTogJ1BlcmZvcm1hbmNlJyxcclxuICAgIHZhbHVlOiAnPCAxMDBtcycsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0F2ZXJhZ2UgcmVzcG9uc2Ugb3ZlcmhlYWQnLFxyXG4gICAgdHJlbmQ6ICctMjBtcyB0aGlzIG1vbnRoJyxcclxuICAgIGljb246ICdaYXAnXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ3R5cGUtc2FmZXR5JyxcclxuICAgIHRpdGxlOiAnVHlwZSBTYWZldHknLFxyXG4gICAgdmFsdWU6ICcxMDAlJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnVHlwZVNjcmlwdCBjb3ZlcmFnZScsXHJcbiAgICB0cmVuZDogJ0Z1bGwgY292ZXJhZ2UnLFxyXG4gICAgaWNvbjogJ0ZpbGVDb2RlJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdkZXZlbG9wZXItc2F0aXNmYWN0aW9uJyxcclxuICAgIHRpdGxlOiAnRGV2ZWxvcGVyIFNhdGlzZmFjdGlvbicsXHJcbiAgICB2YWx1ZTogJzQuOC81JyxcclxuICAgIGRlc2NyaXB0aW9uOiAnQXZlcmFnZSByYXRpbmcgZnJvbSB1c2VycycsXHJcbiAgICB0cmVuZDogJyswLjIgdGhpcyBxdWFydGVyJyxcclxuICAgIGljb246ICdIZWFydCdcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgY29tcGFyaXNvbkRhdGEgPSBbXHJcbiAge1xyXG4gICAgZmVhdHVyZTogJ1R5cGVTY3JpcHQgU3VwcG9ydCcsXHJcbiAgICBtYWNyb0FwaTogJ0Z1bGwnLFxyXG4gICAgY29tcGV0aXRpb24xOiAnUGFydGlhbCcsXHJcbiAgICBjb21wZXRpdGlvbjI6ICdOb25lJyxcclxuICAgIGFkdmFudGFnZTogJ0NvbXBsZXRlIHR5cGUgc2FmZXR5IGFuZCBJbnRlbGxpU2Vuc2UnXHJcbiAgfSxcclxuICB7XHJcbiAgICBmZWF0dXJlOiAnRXJyb3IgSGFuZGxpbmcnLFxyXG4gICAgbWFjcm9BcGk6ICdBZHZhbmNlZCcsXHJcbiAgICBjb21wZXRpdGlvbjE6ICdCYXNpYycsXHJcbiAgICBjb21wZXRpdGlvbjI6ICdNYW51YWwnLFxyXG4gICAgYWR2YW50YWdlOiAnQXV0b21hdGljIHJldHJpZXMsIGNpcmN1aXQgYnJlYWtlcnMsIGRldGFpbGVkIGNvbnRleHQnXHJcbiAgfSxcclxuICB7XHJcbiAgICBmZWF0dXJlOiAnQ2FjaGluZycsXHJcbiAgICBtYWNyb0FwaTogJ011bHRpLXRpZXInLFxyXG4gICAgY29tcGV0aXRpb24xOiAnTWVtb3J5IG9ubHknLFxyXG4gICAgY29tcGV0aXRpb24yOiAnTm9uZScsXHJcbiAgICBhZHZhbnRhZ2U6ICdNZW1vcnkgKyBSZWRpcyArIEh5YnJpZCB3aXRoIGludGVsbGlnZW50IGludmFsaWRhdGlvbidcclxuICB9LFxyXG4gIHtcclxuICAgIGZlYXR1cmU6ICdBUEkgQ292ZXJhZ2UnLFxyXG4gICAgbWFjcm9BcGk6ICcxNSsgc2VydmljZXMnLFxyXG4gICAgY29tcGV0aXRpb24xOiAnNS04IHNlcnZpY2VzJyxcclxuICAgIGNvbXBldGl0aW9uMjogJzMtNSBzZXJ2aWNlcycsXHJcbiAgICBhZHZhbnRhZ2U6ICdDb21wcmVoZW5zaXZlIGNvdmVyYWdlIG9mIHBvcHVsYXIgQVBJcydcclxuICB9LFxyXG4gIHtcclxuICAgIGZlYXR1cmU6ICdNb25pdG9yaW5nJyxcclxuICAgIG1hY3JvQXBpOiAnQnVpbHQtaW4nLFxyXG4gICAgY29tcGV0aXRpb24xOiAnUGx1Z2luJyxcclxuICAgIGNvbXBldGl0aW9uMjogJ0V4dGVybmFsJyxcclxuICAgIGFkdmFudGFnZTogJ05hdGl2ZSBtZXRyaWNzLCB0cmFjaW5nLCBhbmQgb2JzZXJ2YWJpbGl0eSdcclxuICB9LFxyXG4gIHtcclxuICAgIGZlYXR1cmU6ICdSYXRlIExpbWl0aW5nJyxcclxuICAgIG1hY3JvQXBpOiAnSW50ZWxsaWdlbnQnLFxyXG4gICAgY29tcGV0aXRpb24xOiAnQmFzaWMnLFxyXG4gICAgY29tcGV0aXRpb24yOiAnTWFudWFsJyxcclxuICAgIGFkdmFudGFnZTogJ0FkYXB0aXZlIGFsZ29yaXRobXMgd2l0aCBhdXRvbWF0aWMgcXVldWUgbWFuYWdlbWVudCdcclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQ2FzZUV4YW1wbGVzID0gW1xyXG4gIHtcclxuICAgIGlkOiAnc2Fhcy1wbGF0Zm9ybScsXHJcbiAgICB0aXRsZTogJ1NhYVMgUGxhdGZvcm0nLFxyXG4gICAgZGVzY3JpcHRpb246ICdCdWlsZCBhIGNvbXBsZXRlIFNhYVMgcGxhdGZvcm0gd2l0aCB1c2VyIG1hbmFnZW1lbnQsIHBheW1lbnRzLCBhbmQgQUkgZmVhdHVyZXMnLFxyXG4gICAgYXBpczogWydTdHJpcGUnLCAnQ2hhdEdQVCcsICdTZW5kR3JpZCcsICdTbGFjayddLFxyXG4gICAgY29tcGxleGl0eTogJ0FkdmFuY2VkJyxcclxuICAgIHRpbWVUb0ltcGxlbWVudDogJzItNCB3ZWVrcycsXHJcbiAgICBmZWF0dXJlczogW1xyXG4gICAgICAnVXNlciBhdXRoZW50aWNhdGlvbiBhbmQgYmlsbGluZycsXHJcbiAgICAgICdBSS1wb3dlcmVkIGZlYXR1cmVzJyxcclxuICAgICAgJ0VtYWlsIG5vdGlmaWNhdGlvbnMnLFxyXG4gICAgICAnVGVhbSBjb2xsYWJvcmF0aW9uJ1xyXG4gICAgXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdjb250ZW50LW1hbmFnZW1lbnQnLFxyXG4gICAgdGl0bGU6ICdDb250ZW50IE1hbmFnZW1lbnQnLFxyXG4gICAgZGVzY3JpcHRpb246ICdBdXRvbWF0ZSBjb250ZW50IGNyZWF0aW9uLCBkaXN0cmlidXRpb24sIGFuZCBhbmFseXRpY3MgYWNyb3NzIG11bHRpcGxlIGNoYW5uZWxzJyxcclxuICAgIGFwaXM6IFsnQ2hhdEdQVCcsICdZb3VUdWJlJywgJ05vdGlvbicsICdTbGFjayddLFxyXG4gICAgY29tcGxleGl0eTogJ0ludGVybWVkaWF0ZScsXHJcbiAgICB0aW1lVG9JbXBsZW1lbnQ6ICcxLTIgd2Vla3MnLFxyXG4gICAgZmVhdHVyZXM6IFtcclxuICAgICAgJ0FJIGNvbnRlbnQgZ2VuZXJhdGlvbicsXHJcbiAgICAgICdNdWx0aS1wbGF0Zm9ybSBwdWJsaXNoaW5nJyxcclxuICAgICAgJ0FuYWx5dGljcyBkYXNoYm9hcmQnLFxyXG4gICAgICAnVGVhbSBub3RpZmljYXRpb25zJ1xyXG4gICAgXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdlY29tbWVyY2UtYXV0b21hdGlvbicsXHJcbiAgICB0aXRsZTogJ0UtY29tbWVyY2UgQXV0b21hdGlvbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0F1dG9tYXRlIG9yZGVyIHByb2Nlc3NpbmcsIGludmVudG9yeSBtYW5hZ2VtZW50LCBhbmQgY3VzdG9tZXIgY29tbXVuaWNhdGlvbnMnLFxyXG4gICAgYXBpczogWydTdHJpcGUnLCAnUGF5UGFsJywgJ1NlbmRHcmlkJywgJ05vdGlvbiddLFxyXG4gICAgY29tcGxleGl0eTogJ0ludGVybWVkaWF0ZScsXHJcbiAgICB0aW1lVG9JbXBsZW1lbnQ6ICcxLTMgd2Vla3MnLFxyXG4gICAgZmVhdHVyZXM6IFtcclxuICAgICAgJ011bHRpLXBheW1lbnQgcHJvY2Vzc2luZycsXHJcbiAgICAgICdBdXRvbWF0ZWQgZW1haWwgY2FtcGFpZ25zJyxcclxuICAgICAgJ0ludmVudG9yeSB0cmFja2luZycsXHJcbiAgICAgICdDdXN0b21lciBhbmFseXRpY3MnXHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ2Rldm9wcy1waXBlbGluZScsXHJcbiAgICB0aXRsZTogJ0Rldk9wcyBQaXBlbGluZScsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0NvbXBsZXRlIENJL0NEIHBpcGVsaW5lIHdpdGggZGVwbG95bWVudCBhdXRvbWF0aW9uIGFuZCBtb25pdG9yaW5nJyxcclxuICAgIGFwaXM6IFsnR2l0SHViJywgJ1ZlcmNlbCcsICdEb2NrZXIgSHViJywgJ1NsYWNrJywgJ1MzJ10sXHJcbiAgICBjb21wbGV4aXR5OiAnQWR2YW5jZWQnLFxyXG4gICAgdGltZVRvSW1wbGVtZW50OiAnMi01IHdlZWtzJyxcclxuICAgIGZlYXR1cmVzOiBbXHJcbiAgICAgICdBdXRvbWF0ZWQgZGVwbG95bWVudHMnLFxyXG4gICAgICAnQ29udGFpbmVyIG1hbmFnZW1lbnQnLFxyXG4gICAgICAnQXNzZXQgc3RvcmFnZScsXHJcbiAgICAgICdUZWFtIG5vdGlmaWNhdGlvbnMnXHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ2dhbWluZy1hbmFseXRpY3MnLFxyXG4gICAgdGl0bGU6ICdHYW1pbmcgQW5hbHl0aWNzJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnVHJhY2sgcGxheWVyIHN0YXRpc3RpY3MsIHRlYW0gcGVyZm9ybWFuY2UsIGFuZCBnZW5lcmF0ZSBsZWFkZXJib2FyZHMnLFxyXG4gICAgYXBpczogWydWYWxvcmFudCcsICdGb290YmFsbCcsICdOb3Rpb24nLCAnU2xhY2snXSxcclxuICAgIGNvbXBsZXhpdHk6ICdCZWdpbm5lcicsXHJcbiAgICB0aW1lVG9JbXBsZW1lbnQ6ICczLTcgZGF5cycsXHJcbiAgICBmZWF0dXJlczogW1xyXG4gICAgICAnUGxheWVyIHN0YXQgdHJhY2tpbmcnLFxyXG4gICAgICAnQXV0b21hdGVkIGxlYWRlcmJvYXJkcycsXHJcbiAgICAgICdQZXJmb3JtYW5jZSBhbmFseXRpY3MnLFxyXG4gICAgICAnQWNoaWV2ZW1lbnQgbm90aWZpY2F0aW9ucydcclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAnbXVzaWMtcGxhdGZvcm0nLFxyXG4gICAgdGl0bGU6ICdNdXNpYyBQbGF0Zm9ybScsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWxkIG11c2ljIGRpc2NvdmVyeSBhbmQgcGxheWxpc3QgbWFuYWdlbWVudCBmZWF0dXJlcycsXHJcbiAgICBhcGlzOiBbJ1Nwb3RpZnknLCAnQ2hhdEdQVCcsICdOb3Rpb24nXSxcclxuICAgIGNvbXBsZXhpdHk6ICdJbnRlcm1lZGlhdGUnLFxyXG4gICAgdGltZVRvSW1wbGVtZW50OiAnMS0yIHdlZWtzJyxcclxuICAgIGZlYXR1cmVzOiBbXHJcbiAgICAgICdNdXNpYyBzZWFyY2ggYW5kIGRpc2NvdmVyeScsXHJcbiAgICAgICdBSS1wb3dlcmVkIHJlY29tbWVuZGF0aW9ucycsXHJcbiAgICAgICdQbGF5bGlzdCBtYW5hZ2VtZW50JyxcclxuICAgICAgJ1VzZXIgcHJlZmVyZW5jZXMgc3RvcmFnZSdcclxuICAgIF1cclxuICB9XHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgaW50ZWdyYXRpb25HdWlkZXMgPSBbXHJcbiAge1xyXG4gICAgaWQ6ICduZXh0LWpzJyxcclxuICAgIHRpdGxlOiAnTmV4dC5qcyBJbnRlZ3JhdGlvbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0NvbXBsZXRlIGd1aWRlIGZvciB1c2luZyBtYWNyb19hcGkgaW4gTmV4dC5qcyBhcHBsaWNhdGlvbnMnLFxyXG4gICAgZGlmZmljdWx0eTogJ0JlZ2lubmVyJyxcclxuICAgIHRpbWVUb0NvbXBsZXRlOiAnMTUgbWludXRlcycsXHJcbiAgICBzdGVwczogW1xyXG4gICAgICAnSW5zdGFsbCBtYWNyb19hcGkgYW5kIGRlcGVuZGVuY2llcycsXHJcbiAgICAgICdDb25maWd1cmUgZW52aXJvbm1lbnQgdmFyaWFibGVzJyxcclxuICAgICAgJ1NldCB1cCBBUEkgcm91dGVzJyxcclxuICAgICAgJ0ltcGxlbWVudCBjbGllbnQtc2lkZSB1c2FnZScsXHJcbiAgICAgICdBZGQgZXJyb3IgaGFuZGxpbmcnXHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ2V4cHJlc3MtanMnLFxyXG4gICAgdGl0bGU6ICdFeHByZXNzLmpzIEJhY2tlbmQnLFxyXG4gICAgZGVzY3JpcHRpb246ICdCdWlsZCBhIHJvYnVzdCBiYWNrZW5kIEFQSSB1c2luZyBFeHByZXNzLmpzIGFuZCBtYWNyb19hcGknLFxyXG4gICAgZGlmZmljdWx0eTogJ0ludGVybWVkaWF0ZScsXHJcbiAgICB0aW1lVG9Db21wbGV0ZTogJzMwIG1pbnV0ZXMnLFxyXG4gICAgc3RlcHM6IFtcclxuICAgICAgJ1NldCB1cCBFeHByZXNzIHNlcnZlcicsXHJcbiAgICAgICdDb25maWd1cmUgbWlkZGxld2FyZScsXHJcbiAgICAgICdJbXBsZW1lbnQgQVBJIGVuZHBvaW50cycsXHJcbiAgICAgICdBZGQgYXV0aGVudGljYXRpb24nLFxyXG4gICAgICAnU2V0IHVwIHdlYmhvb2sgaGFuZGxpbmcnXHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBpZDogJ3NlcnZlcmxlc3MnLFxyXG4gICAgdGl0bGU6ICdTZXJ2ZXJsZXNzIEZ1bmN0aW9ucycsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0RlcGxveSBtYWNyb19hcGkgaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMnLFxyXG4gICAgZGlmZmljdWx0eTogJ0ludGVybWVkaWF0ZScsXHJcbiAgICB0aW1lVG9Db21wbGV0ZTogJzIwIG1pbnV0ZXMnLFxyXG4gICAgc3RlcHM6IFtcclxuICAgICAgJ0NvbmZpZ3VyZSBmb3Igc2VydmVybGVzcycsXHJcbiAgICAgICdPcHRpbWl6ZSBjb2xkIHN0YXJ0cycsXHJcbiAgICAgICdIYW5kbGUgZW52aXJvbm1lbnQgdmFyaWFibGVzJyxcclxuICAgICAgJ0ltcGxlbWVudCBjYWNoaW5nIHN0cmF0ZWdpZXMnLFxyXG4gICAgICAnRGVwbG95IGFuZCBtb25pdG9yJ1xyXG4gICAgXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdkb2NrZXInLFxyXG4gICAgdGl0bGU6ICdEb2NrZXIgRGVwbG95bWVudCcsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0NvbnRhaW5lcml6ZSBhcHBsaWNhdGlvbnMgdXNpbmcgbWFjcm9fYXBpJyxcclxuICAgIGRpZmZpY3VsdHk6ICdBZHZhbmNlZCcsXHJcbiAgICB0aW1lVG9Db21wbGV0ZTogJzQ1IG1pbnV0ZXMnLFxyXG4gICAgc3RlcHM6IFtcclxuICAgICAgJ0NyZWF0ZSBEb2NrZXJmaWxlJyxcclxuICAgICAgJ0NvbmZpZ3VyZSBlbnZpcm9ubWVudCcsXHJcbiAgICAgICdTZXQgdXAgaGVhbHRoIGNoZWNrcycsXHJcbiAgICAgICdJbXBsZW1lbnQgbG9nZ2luZycsXHJcbiAgICAgICdEZXBsb3kgd2l0aCBvcmNoZXN0cmF0aW9uJ1xyXG4gICAgXVxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZlYXR1cmVzOyJdLCJuYW1lcyI6WyJmZWF0dXJlcyIsImlkIiwidGl0bGUiLCJpY29uIiwiZGVzY3JpcHRpb24iLCJsb25nRGVzY3JpcHRpb24iLCJiZW5lZml0cyIsInRlY2huaWNhbERldGFpbHMiLCJjb2RlRXhhbXBsZSIsImNhdGVnb3J5IiwiaW1wb3J0YW5jZSIsImZlYXR1cmVDYXRlZ29yaWVzIiwibmFtZSIsImNvbG9yIiwiZmlsdGVyIiwiZiIsImtleU1ldHJpY3MiLCJ2YWx1ZSIsInRyZW5kIiwiY29tcGFyaXNvbkRhdGEiLCJmZWF0dXJlIiwibWFjcm9BcGkiLCJjb21wZXRpdGlvbjEiLCJjb21wZXRpdGlvbjIiLCJhZHZhbnRhZ2UiLCJ1c2VDYXNlRXhhbXBsZXMiLCJhcGlzIiwiY29tcGxleGl0eSIsInRpbWVUb0ltcGxlbWVudCIsImludGVncmF0aW9uR3VpZGVzIiwiZGlmZmljdWx0eSIsInRpbWVUb0NvbXBsZXRlIiwic3RlcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/home/Features.tsx\n"));

/***/ })

});