"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/data/codeExamples.ts":
/*!**********************************!*\
  !*** ./src/data/codeExamples.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// src/data/codeExamples.ts\nconst codeExamples = [\n    {\n        id: \"unified-client\",\n        title: \"Unified API Client\",\n        description: \"Initialize multiple API services with built-in caching, error handling, and retry logic for production applications.\",\n        category: \"Getting Started\",\n        difficulty: \"beginner\",\n        services: [\n            \"ChatGPT\",\n            \"Stripe\",\n            \"Slack\"\n        ],\n        features: [\n            \"Error Handling\",\n            \"Caching\",\n            \"Retry Logic\",\n            \"TypeScript\"\n        ],\n        typescript: \"import { MacroAPIClient, ChatGPT, StripeAPI, SlackAPI } from 'macro_api';\\n\\n// Initialize unified client with caching and error handling\\nconst client = new MacroAPIClient({\\n  cache: {\\n    type: 'hybrid',\\n    ttl: 3600, // 1 hour\\n    redis: { url: process.env.REDIS_URL }\\n  },\\n  retries: {\\n    maxRetries: 3,\\n    baseDelay: 1000,\\n    maxDelay: 10000\\n  }\\n});\\n\\n// Initialize API services\\nconst chatgpt = new ChatGPT({ \\n  apiKey: process.env.OPENAI_API_KEY! \\n});\\n\\nconst stripe = new StripeAPI({ \\n  secretKey: process.env.STRIPE_SECRET_KEY! \\n});\\n\\nconst slack = new SlackAPI({ \\n  botToken: process.env.SLACK_BOT_TOKEN! \\n});\\n\\n// Use with automatic error handling and caching\\nasync function processCustomerQuery(query: string, customerId: string) {\\n  try {\\n    // Generate AI response with caching\\n    const aiResponse = await client.execute(\\n      () => chatgpt.chat(query, \\\"You are a helpful customer service assistant.\\\"),\\n      {\\n        service: 'openai',\\n        method: 'chat',\\n        params: { query, context: 'customer_service' },\\n        cacheTtl: 1800 // 30 minutes\\n      }\\n    );\\n\\n    // Get customer data\\n    const customer = await client.execute(\\n      () => stripe.getCustomer(customerId),\\n      {\\n        service: 'stripe',\\n        method: 'getCustomer',\\n        params: { customerId }\\n      }\\n    );\\n\\n    // Send notification to support channel\\n    await slack.sendMessage('#customer-support', \\n      `New query from ${customer.email}: ${aiResponse}`\\n    );\\n\\n    return {\\n      response: aiResponse,\\n      customer: customer,\\n      status: 'success'\\n    };\\n  } catch (error) {\\n    console.error('Error processing query:', error);\\n    throw error;\\n  }\\n}\",\n        javascript: \"const { MacroAPIClient, ChatGPT, StripeAPI, SlackAPI } = require('macro_api');\\n\\n// Initialize unified client with caching and error handling\\nconst client = new MacroAPIClient({\\n  cache: {\\n    type: 'hybrid',\\n    ttl: 3600, // 1 hour\\n    redis: { url: process.env.REDIS_URL }\\n  },\\n  retries: {\\n    maxRetries: 3,\\n    baseDelay: 1000,\\n    maxDelay: 10000\\n  }\\n});\\n\\n// Initialize API services\\nconst chatgpt = new ChatGPT({ \\n  apiKey: process.env.OPENAI_API_KEY \\n});\\n\\nconst stripe = new StripeAPI({ \\n  secretKey: process.env.STRIPE_SECRET_KEY \\n});\\n\\nconst slack = new SlackAPI({ \\n  botToken: process.env.SLACK_BOT_TOKEN \\n});\\n\\n// Use with automatic error handling and caching\\nasync function processCustomerQuery(query, customerId) {\\n  try {\\n    // Generate AI response with caching\\n    const aiResponse = await client.execute(\\n      () => chatgpt.chat(query, \\\"You are a helpful customer service assistant.\\\"),\\n      {\\n        service: 'openai',\\n        method: 'chat',\\n        params: { query, context: 'customer_service' },\\n        cacheTtl: 1800 // 30 minutes\\n      }\\n    );\\n\\n    // Get customer data\\n    const customer = await client.execute(\\n      () => stripe.getCustomer(customerId),\\n      {\\n        service: 'stripe',\\n        method: 'getCustomer',\\n        params: { customerId }\\n      }\\n    );\\n\\n    // Send notification to support channel\\n    await slack.sendMessage('#customer-support', \\n      `New query from ${customer.email}: ${aiResponse}`\\n    );\\n\\n    return {\\n      response: aiResponse,\\n      customer: customer,\\n      status: 'success'\\n    };\\n  } catch (error) {\\n    console.error('Error processing query:', error);\\n    throw error;\\n  }\\n}\"\n    },\n    {\n        id: \"ai-content-generation\",\n        title: \"AI Content Generation\",\n        description: \"Generate blog posts, code, and marketing content using ChatGPT and DeepSeek with streaming responses.\",\n        category: \"AI & Machine Learning\",\n        difficulty: \"intermediate\",\n        services: [\n            \"ChatGPT\",\n            \"DeepSeek\"\n        ],\n        features: [\n            \"Streaming\",\n            \"Function Calling\",\n            \"Content Generation\"\n        ],\n        typescript: \"import { ChatGPT, DeepSeek } from 'macro_api';\\n\\ninterface ContentRequest {\\n  topic: string;\\n  type: 'blog' | 'code' | 'marketing';\\n  length: 'short' | 'medium' | 'long';\\n  audience: 'technical' | 'general' | 'business';\\n}\\n\\nclass ContentGenerator {\\n  private chatgpt: ChatGPT;\\n  private deepseek: DeepSeek;\\n\\n  constructor() {\\n    this.chatgpt = new ChatGPT({ \\n      apiKey: process.env.OPENAI_API_KEY! \\n    });\\n    this.deepseek = new DeepSeek({ \\n      apiKey: process.env.DEEPSEEK_API_KEY! \\n    });\\n  }\\n\\n  async generateBlogPost(request: ContentRequest): Promise<string> {\\n    const systemPrompt = `You are an expert content writer. Create engaging ${request.length} blog posts for ${request.audience} audiences.`;\\n    \\n    const prompt = `Write a ${request.length} blog post about \\\"${request.topic}\\\" targeting a ${request.audience} audience. Include:\\n    - Engaging introduction\\n    - 3-5 main points with examples\\n    - Actionable conclusion\\n    - SEO-friendly structure`;\\n\\n    return await this.chatgpt.chat(prompt, systemPrompt, 'gpt-4');\\n  }\\n\\n  async generateCode(language: string, description: string): Promise<string> {\\n    const prompt = `Generate ${language} code for: ${description}`;\\n    \\n    const response = await this.deepseek.generateCode(prompt, {\\n      model: 'deepseek-coder-33b-instruct',\\n      temperature: 0.2,\\n      max_tokens: 2048\\n    });\\n\\n    return response.choices[0].text;\\n  }\\n\\n  async streamingGeneration(\\n    prompt: string, \\n    onChunk: (chunk: string) => void\\n  ): Promise<void> {\\n    await this.chatgpt.createStreamingChatCompletion(\\n      {\\n        model: 'gpt-4',\\n        messages: [{ role: 'user', content: prompt }],\\n        temperature: 0.7,\\n        max_tokens: 1500\\n      },\\n      (data) => {\\n        const chunk = data.choices?.[0]?.delta?.content;\\n        if (chunk) {\\n          onChunk(chunk);\\n        }\\n      },\\n      (error) => console.error('Streaming error:', error),\\n      () => console.log('Streaming complete')\\n    );\\n  }\\n\\n  async generateWithFunctions(topic: string): Promise<any> {\\n    const functions = [\\n      {\\n        name: 'research_topic',\\n        description: 'Research a topic for accurate information',\\n        parameters: {\\n          type: 'object',\\n          properties: {\\n            topic: { type: 'string' },\\n            depth: { type: 'string', enum: ['basic', 'detailed', 'comprehensive'] }\\n          }\\n        }\\n      }\\n    ];\\n\\n    return await this.chatgpt.withFunctions(\\n      `Create content about \\\"${topic}\\\" using the research function.`,\\n      functions\\n    );\\n  }\\n}\\n\\n// Usage example\\nconst generator = new ContentGenerator();\\n\\n// Generate blog post\\nconst blogPost = await generator.generateBlogPost({\\n  topic: \\\"Machine Learning in Web Development\\\",\\n  type: \\\"blog\\\",\\n  length: \\\"medium\\\", \\n  audience: \\\"technical\\\"\\n});\\n\\n// Generate code\\nconst pythonCode = await generator.generateCode(\\n  \\\"Python\\\",\\n  \\\"Create a REST API with FastAPI for user authentication\\\"\\n);\\n\\n// Streaming content generation\\nawait generator.streamingGeneration(\\n  \\\"Explain quantum computing in simple terms\\\",\\n  (chunk) => process.stdout.write(chunk)\\n);\",\n        javascript: \"const { ChatGPT, DeepSeek } = require('macro_api');\\n\\nclass ContentGenerator {\\n  constructor() {\\n    this.chatgpt = new ChatGPT({ \\n      apiKey: process.env.OPENAI_API_KEY \\n    });\\n    this.deepseek = new DeepSeek({ \\n      apiKey: process.env.DEEPSEEK_API_KEY \\n    });\\n  }\\n\\n  async generateBlogPost(request) {\\n    const systemPrompt = `You are an expert content writer. Create engaging ${request.length} blog posts for ${request.audience} audiences.`;\\n    \\n    const prompt = `Write a ${request.length} blog post about \\\"${request.topic}\\\" targeting a ${request.audience} audience. Include:\\n    - Engaging introduction\\n    - 3-5 main points with examples\\n    - Actionable conclusion\\n    - SEO-friendly structure`;\\n\\n    return await this.chatgpt.chat(prompt, systemPrompt, 'gpt-4');\\n  }\\n\\n  async generateCode(language, description) {\\n    const prompt = `Generate ${language} code for: ${description}`;\\n    \\n    const response = await this.deepseek.generateCode(prompt, {\\n      model: 'deepseek-coder-33b-instruct',\\n      temperature: 0.2,\\n      max_tokens: 2048\\n    });\\n\\n    return response.choices[0].text;\\n  }\\n\\n  async streamingGeneration(prompt, onChunk) {\\n    await this.chatgpt.createStreamingChatCompletion(\\n      {\\n        model: 'gpt-4',\\n        messages: [{ role: 'user', content: prompt }],\\n        temperature: 0.7,\\n        max_tokens: 1500\\n      },\\n      (data) => {\\n        const chunk = data.choices?.[0]?.delta?.content;\\n        if (chunk) {\\n          onChunk(chunk);\\n        }\\n      },\\n      (error) => console.error('Streaming error:', error),\\n      () => console.log('Streaming complete')\\n    );\\n  }\\n}\\n\\n// Usage example\\nconst generator = new ContentGenerator();\\n\\n// Generate blog post\\nconst blogPost = await generator.generateBlogPost({\\n  topic: \\\"Machine Learning in Web Development\\\",\\n  type: \\\"blog\\\",\\n  length: \\\"medium\\\", \\n  audience: \\\"technical\\\"\\n});\\n\\n// Generate code\\nconst pythonCode = await generator.generateCode(\\n  \\\"Python\\\",\\n  \\\"Create a REST API with FastAPI for user authentication\\\"\\n);\"\n    },\n    {\n        id: \"payment-processing\",\n        title: \"Payment Processing System\",\n        description: \"Complete payment system with Stripe and PayPal integration, webhook handling, and subscription management.\",\n        category: \"Payment & Commerce\",\n        difficulty: \"advanced\",\n        services: [\n            \"Stripe\",\n            \"PayPal\",\n            \"SendGrid\"\n        ],\n        features: [\n            \"Webhooks\",\n            \"Subscriptions\",\n            \"Email Notifications\",\n            \"Error Handling\"\n        ],\n        typescript: \"import { StripeAPI, PayPalAPI, SendGridAPI, RateLimitError, AuthenticationError } from 'macro_api';\\n\\ninterface PaymentRequest {\\n  amount: number;\\n  currency: string;\\n  customerId: string;\\n  description: string;\\n  paymentMethod: 'stripe' | 'paypal';\\n  metadata?: Record<string, string>;\\n}\\n\\ninterface SubscriptionPlan {\\n  name: string;\\n  price: number;\\n  currency: string;\\n  interval: 'month' | 'year';\\n  features: string[];\\n}\\n\\nclass PaymentProcessor {\\n  private stripe: StripeAPI;\\n  private paypal: PayPalAPI;\\n  private sendgrid: SendGridAPI;\\n\\n  constructor() {\\n    this.stripe = new StripeAPI({ \\n      secretKey: process.env.STRIPE_SECRET_KEY! \\n    });\\n    this.paypal = new PayPalAPI({\\n      clientId: process.env.PAYPAL_CLIENT_ID!,\\n      clientSecret: process.env.PAYPAL_CLIENT_SECRET!,\\n      sandbox: process.env.NODE_ENV === 'development'\\n    });\\n    this.sendgrid = new SendGridAPI({\\n      apiKey: process.env.SENDGRID_API_KEY!\\n    });\\n  }\\n\\n  async processPayment(request: PaymentRequest): Promise<any> {\\n    try {\\n      if (request.paymentMethod === 'stripe') {\\n        return await this.processStripePayment(request);\\n      } else {\\n        return await this.processPayPalPayment(request);\\n      }\\n    } catch (error) {\\n      await this.handlePaymentError(error, request);\\n      throw error;\\n    }\\n  }\\n\\n  private async processStripePayment(request: PaymentRequest): Promise<any> {\\n    // Create payment intent\\n    const paymentIntent = await this.stripe.createPaymentIntent({\\n      amount: request.amount * 100, // Convert to cents\\n      currency: request.currency,\\n      customer: request.customerId,\\n      description: request.description,\\n      metadata: request.metadata,\\n      automatic_payment_methods: {\\n        enabled: true\\n      }\\n    });\\n\\n    // Send confirmation email\\n    await this.sendPaymentConfirmation(request.customerId, paymentIntent);\\n\\n    return {\\n      provider: 'stripe',\\n      clientSecret: paymentIntent.client_secret,\\n      paymentIntentId: paymentIntent.id,\\n      status: paymentIntent.status\\n    };\\n  }\\n\\n  private async processPayPalPayment(request: PaymentRequest): Promise<any> {\\n    const order = await this.paypal.createOrder({\\n      intent: 'CAPTURE',\\n      purchase_units: [{\\n        amount: {\\n          currency_code: request.currency.toUpperCase(),\\n          value: request.amount.toString()\\n        },\\n        description: request.description,\\n        custom_id: request.customerId\\n      }],\\n      application_context: {\\n        return_url: `${process.env.BASE_URL}/payment/success`,\\n        cancel_url: `${process.env.BASE_URL}/payment/cancel`\\n      }\\n    });\\n\\n    return {\\n      provider: 'paypal',\\n      orderId: order.id,\\n      approvalUrl: order.links?.find(link => link.rel === 'approve')?.href\\n    };\\n  }\\n\\n  async createSubscription(\\n    customerId: string, \\n    plan: SubscriptionPlan,\\n    paymentMethod?: string\\n  ): Promise<any> {\\n    // Create product and price\\n    const product = await this.stripe.createProduct({\\n      name: plan.name,\\n      description: `${plan.name} subscription plan`\\n    });\\n\\n    const price = await this.stripe.createPrice({\\n      unit_amount: plan.price * 100,\\n      currency: plan.currency,\\n      product: product.id,\\n      recurring: {\\n        interval: plan.interval\\n      }\\n    });\\n\\n    // Create subscription\\n    const subscription = await this.stripe.createSubscription({\\n      customer: customerId,\\n      items: [{ price: price.id }],\\n      default_payment_method: paymentMethod,\\n      trial_period_days: 14, // 14-day free trial\\n      metadata: {\\n        plan_name: plan.name,\\n        features: JSON.stringify(plan.features)\\n      }\\n    });\\n\\n    // Send welcome email\\n    await this.sendSubscriptionWelcome(customerId, plan, subscription);\\n\\n    return subscription;\\n  }\\n\\n  async handleWebhook(payload: string, signature: string, provider: 'stripe' | 'paypal'): Promise<void> {\\n    try {\\n      if (provider === 'stripe') {\\n        const event = this.stripe.webhooks.constructEvent(\\n          payload,\\n          signature,\\n          process.env.STRIPE_WEBHOOK_SECRET!\\n        );\\n\\n        switch (event.type) {\\n          case 'payment_intent.succeeded':\\n            await this.handlePaymentSuccess(event.data.object);\\n            break;\\n          case 'payment_intent.payment_failed':\\n            await this.handlePaymentFailure(event.data.object);\\n            break;\\n          case 'customer.subscription.created':\\n            await this.handleSubscriptionCreated(event.data.object);\\n            break;\\n          case 'customer.subscription.deleted':\\n            await this.handleSubscriptionCanceled(event.data.object);\\n            break;\\n        }\\n      }\\n    } catch (error) {\\n      console.error('Webhook handling error:', error);\\n      throw error;\\n    }\\n  }\\n\\n  private async sendPaymentConfirmation(customerId: string, paymentIntent: any): Promise<void> {\\n    const customer = await this.stripe.getCustomer(customerId);\\n    \\n    await this.sendgrid.sendEmail({\\n      to: customer.email,\\n      subject: 'Payment Confirmation',\\n      templateId: 'd-payment-confirmation-template',\\n      dynamicTemplateData: {\\n        customer_name: customer.name,\\n        amount: (paymentIntent.amount / 100).toFixed(2),\\n        currency: paymentIntent.currency.toUpperCase(),\\n        payment_id: paymentIntent.id\\n      }\\n    });\\n  }\\n\\n  private async sendSubscriptionWelcome(\\n    customerId: string, \\n    plan: SubscriptionPlan, \\n    subscription: any\\n  ): Promise<void> {\\n    const customer = await this.stripe.getCustomer(customerId);\\n    \\n    await this.sendgrid.sendEmail({\\n      to: customer.email,\\n      subject: `Welcome to ${plan.name}!`,\\n      templateId: 'd-subscription-welcome-template',\\n      dynamicTemplateData: {\\n        customer_name: customer.name,\\n        plan_name: plan.name,\\n        features: plan.features,\\n        trial_end: subscription.trial_end,\\n        manage_url: `${process.env.BASE_URL}/account/subscription`\\n      }\\n    });\\n  }\\n\\n  private async handlePaymentError(error: any, request: PaymentRequest): Promise<void> {\\n    let errorType = 'unknown';\\n    \\n    if (error instanceof RateLimitError) {\\n      errorType = 'rate_limit';\\n    } else if (error instanceof AuthenticationError) {\\n      errorType = 'authentication';\\n    }\\n\\n    console.error('Payment processing error:', {\\n      type: errorType,\\n      request,\\n      error: error.message\\n    });\\n\\n    // Log to monitoring service\\n    // await this.logError(error, request);\\n  }\\n}\\n\\n// Usage example\\nconst processor = new PaymentProcessor();\\n\\n// Process one-time payment\\nconst payment = await processor.processPayment({\\n  amount: 29.99,\\n  currency: 'usd',\\n  customerId: 'cus_customer123',\\n  description: 'Premium Course Access',\\n  paymentMethod: 'stripe',\\n  metadata: {\\n    course_id: 'course_123',\\n    user_id: 'user_456'\\n  }\\n});\\n\\n// Create subscription\\nconst subscription = await processor.createSubscription(\\n  'cus_customer123',\\n  {\\n    name: 'Pro Plan',\\n    price: 19.99,\\n    currency: 'usd',\\n    interval: 'month',\\n    features: ['Unlimited API calls', 'Priority support', 'Advanced analytics']\\n  }\\n);\",\n        javascript: \"const { StripeAPI, PayPalAPI, SendGridAPI, RateLimitError, AuthenticationError } = require('macro_api');\\n\\nclass PaymentProcessor {\\n  constructor() {\\n    this.stripe = new StripeAPI({ \\n      secretKey: process.env.STRIPE_SECRET_KEY \\n    });\\n    this.paypal = new PayPalAPI({\\n      clientId: process.env.PAYPAL_CLIENT_ID,\\n      clientSecret: process.env.PAYPAL_CLIENT_SECRET,\\n      sandbox: process.env.NODE_ENV === 'development'\\n    });\\n    this.sendgrid = new SendGridAPI({\\n      apiKey: process.env.SENDGRID_API_KEY\\n    });\\n  }\\n\\n  async processPayment(request) {\\n    try {\\n      if (request.paymentMethod === 'stripe') {\\n        return await this.processStripePayment(request);\\n      } else {\\n        return await this.processPayPalPayment(request);\\n      }\\n    } catch (error) {\\n      await this.handlePaymentError(error, request);\\n      throw error;\\n    }\\n  }\\n\\n  async processStripePayment(request) {\\n    // Create payment intent\\n    const paymentIntent = await this.stripe.createPaymentIntent({\\n      amount: request.amount * 100, // Convert to cents\\n      currency: request.currency,\\n      customer: request.customerId,\\n      description: request.description,\\n      metadata: request.metadata,\\n      automatic_payment_methods: {\\n        enabled: true\\n      }\\n    });\\n\\n    // Send confirmation email\\n    await this.sendPaymentConfirmation(request.customerId, paymentIntent);\\n\\n    return {\\n      provider: 'stripe',\\n      clientSecret: paymentIntent.client_secret,\\n      paymentIntentId: paymentIntent.id,\\n      status: paymentIntent.status\\n    };\\n  }\\n}\\n\\n// Usage example\\nconst processor = new PaymentProcessor();\\n\\nconst payment = await processor.processPayment({\\n  amount: 29.99,\\n  currency: 'usd',\\n  customerId: 'cus_customer123',\\n  description: 'Premium Course Access',\\n  paymentMethod: 'stripe'\\n});\"\n    },\n    {\n        id: \"communication-automation\",\n        title: \"Communication Automation\",\n        description: \"Automate team communication with Slack bots, email campaigns, and intelligent notifications.\",\n        category: \"Communication & Social\",\n        difficulty: \"intermediate\",\n        services: [\n            \"Slack\",\n            \"SendGrid\",\n            \"ChatGPT\"\n        ],\n        features: [\n            \"Slash Commands\",\n            \"Email Templates\",\n            \"AI Integration\"\n        ],\n        typescript: \"import { SlackAPI, SendGridAPI, ChatGPT } from 'macro_api';\\n\\ninterface NotificationConfig {\\n  channels: string[];\\n  emailLists: string[];\\n  urgency: 'low' | 'medium' | 'high';\\n  includeAISummary: boolean;\\n}\\n\\nclass CommunicationHub {\\n  private slack: SlackAPI;\\n  private sendgrid: SendGridAPI;\\n  private chatgpt: ChatGPT;\\n\\n  constructor() {\\n    this.slack = new SlackAPI({ \\n      botToken: process.env.SLACK_BOT_TOKEN! \\n    });\\n    this.sendgrid = new SendGridAPI({\\n      apiKey: process.env.SENDGRID_API_KEY!\\n    });\\n    this.chatgpt = new ChatGPT({\\n      apiKey: process.env.OPENAI_API_KEY!\\n    });\\n  }\\n\\n  async createSlackBot(): Promise<void> {\\n    // Set up slash command handlers\\n    await this.setupSlashCommands();\\n    \\n    // Monitor channels for keywords\\n    await this.setupKeywordMonitoring();\\n  }\\n\\n  private async setupSlashCommands(): Promise<void> {\\n    // Example: /deploy command\\n    const deployCommand = async (payload: any) => {\\n      const { text, user_id, channel_id } = payload;\\n      \\n      try {\\n        // Send immediate response\\n        await this.slack.sendMessage(channel_id, \\n          `\\uD83D\\uDE80 Starting deployment of ${text}...`, \\n          { thread_ts: payload.ts }\\n        );\\n\\n        // Simulate deployment process\\n        await this.simulateDeployment(text);\\n        \\n        // Send success message\\n        await this.slack.sendMessage(channel_id,\\n          `✅ Deployment of ${text} completed successfully!`,\\n          { \\n            thread_ts: payload.ts,\\n            blocks: [\\n              {\\n                type: 'section',\\n                text: {\\n                  type: 'mrkdwn',\\n                  text: `*Deployment Summary*\\\\n• Service: ${text}\\\\n• Status: ✅ Success\\\\n• Duration: 2m 34s`\\n                }\\n              },\\n              {\\n                type: 'actions',\\n                elements: [\\n                  {\\n                    type: 'button',\\n                    text: { type: 'plain_text', text: 'View Logs' },\\n                    url: `https://dashboard.example.com/deployments/${text}`\\n                  }\\n                ]\\n              }\\n            ]\\n          }\\n        );\\n      } catch (error) {\\n        await this.slack.sendMessage(channel_id,\\n          `❌ Deployment failed: ${error.message}`\\n        );\\n      }\\n    };\\n\\n    // Register command handler\\n    // Note: In a real application, you'd set up a web server to handle webhooks\\n    console.log('Slash command handlers registered');\\n  }\\n\\n  async sendIntelligentNotification(\\n    title: string,\\n    content: string,\\n    config: NotificationConfig\\n  ): Promise<void> {\\n    let processedContent = content;\\n    \\n    // Generate AI summary if requested\\n    if (config.includeAISummary) {\\n      const summary = await this.chatgpt.chat(\\n        `Summarize this notification in 2-3 bullet points:\\\\n\\\\n${content}`,\\n        'You are a concise communication assistant.'\\n      );\\n      processedContent = `\\uD83D\\uDCCB **AI Summary:**\\\\n${summary}\\\\n\\\\n\\uD83D\\uDCC4 **Full Details:**\\\\n${content}`;\\n    }\\n\\n    // Send to Slack channels\\n    for (const channel of config.channels) {\\n      await this.sendSlackNotification(channel, title, processedContent, config.urgency);\\n    }\\n\\n    // Send email notifications\\n    if (config.emailLists.length > 0) {\\n      await this.sendEmailNotification(title, processedContent, config);\\n    }\\n  }\\n\\n  private async sendSlackNotification(\\n    channel: string, \\n    title: string, \\n    content: string, \\n    urgency: string\\n  ): Promise<void> {\\n    const urgencyEmoji = {\\n      low: '\\uD83D\\uDCAD',\\n      medium: '⚠️',\\n      high: '\\uD83D\\uDEA8'\\n    };\\n\\n    const urgencyColor = {\\n      low: '#36a64f',\\n      medium: '#ff9500', \\n      high: '#ff0000'\\n    };\\n\\n    await this.slack.sendMessage(channel, '', {\\n      blocks: [\\n        {\\n          type: 'header',\\n          text: {\\n            type: 'plain_text',\\n            text: `${urgencyEmoji[urgency]} ${title}`\\n          }\\n        },\\n        {\\n          type: 'section',\\n          text: {\\n            type: 'mrkdwn',\\n            text: content\\n          }\\n        },\\n        {\\n          type: 'context',\\n          elements: [\\n            {\\n              type: 'mrkdwn',\\n              text: `Urgency: *${urgency.toUpperCase()}* | ${new Date().toLocaleString()}`\\n            }\\n          ]\\n        }\\n      ]\\n    });\\n  }\\n\\n  private async sendEmailNotification(\\n    title: string,\\n    content: string,\\n    config: NotificationConfig\\n  ): Promise<void> {\\n    const emailContent = content.replace(/\\\\*/g, ''); // Remove markdown\\n    \\n    for (const listId of config.emailLists) {\\n      await this.sendgrid.sendEmail({\\n        to: `list-${listId}@company.com`,\\n        subject: title,\\n        html: `\\n          <div style=\\\"font-family: Arial, sans-serif; max-width: 600px;\\\">\\n            <h2 style=\\\"color: #333;\\\">${title}</h2>\\n            <div style=\\\"background: #f8f9fa; padding: 20px; border-radius: 8px;\\\">\\n              ${emailContent.replace(/\\\\n/g, '<br>')}\\n            </div>\\n            <p style=\\\"color: #666; font-size: 12px; margin-top: 20px;\\\">\\n              Sent via macro_api Communication Hub\\n            </p>\\n          </div>\\n        `\\n      });\\n    }\\n  }\\n\\n  async createScheduledCampaign(\\n    subject: string,\\n    templateId: string,\\n    audienceId: string,\\n    scheduleTime: Date,\\n    personalizations: Record<string, any>[]\\n  ): Promise<void> {\\n    // Create email template with dynamic content\\n    const template = await this.sendgrid.createTemplate(\\n      `Campaign: ${subject}`,\\n      'dynamic'\\n    );\\n\\n    // Schedule the campaign\\n    const scheduledEmail = await this.sendgrid.scheduleEmail({\\n      to: personalizations.map(p => p.email),\\n      subject,\\n      templateId,\\n      dynamicTemplateData: personalizations\\n    }, scheduleTime);\\n\\n    // Notify team about scheduled campaign\\n    await this.slack.sendMessage('#marketing',\\n      `\\uD83D\\uDCE7 Email campaign \\\"${subject}\\\" scheduled for ${scheduleTime.toLocaleString()}`,\\n      {\\n        blocks: [\\n          {\\n            type: 'section',\\n            text: {\\n              type: 'mrkdwn',\\n              text: `*Campaign Details*\\\\n• Subject: ${subject}\\\\n• Recipients: ${personalizations.length}\\\\n• Send Time: ${scheduleTime.toLocaleString()}`\\n            }\\n          }\\n        ]\\n      }\\n    );\\n  }\\n\\n  private async simulateDeployment(service: string): Promise<void> {\\n    // Simulate deployment time\\n    await new Promise(resolve => setTimeout(resolve, 2000));\\n  }\\n\\n  async setupAlertSystem(): Promise<void> {\\n    // Monitor system health and send alerts\\n    setInterval(async () => {\\n      const systemHealth = await this.checkSystemHealth();\\n      \\n      if (systemHealth.status === 'critical') {\\n        await this.sendIntelligentNotification(\\n          '\\uD83D\\uDEA8 Critical System Alert',\\n          `System health check failed:\\\\n• CPU: ${systemHealth.cpu}%\\\\n• Memory: ${systemHealth.memory}%\\\\n• Disk: ${systemHealth.disk}%`,\\n          {\\n            channels: ['#alerts', '#engineering'],\\n            emailLists: ['on-call'],\\n            urgency: 'high',\\n            includeAISummary: false\\n          }\\n        );\\n      }\\n    }, 300000); // Check every 5 minutes\\n  }\\n\\n  private async checkSystemHealth(): Promise<any> {\\n    // Mock system health check\\n    return {\\n      status: Math.random() > 0.95 ? 'critical' : 'healthy',\\n      cpu: Math.round(Math.random() * 100),\\n      memory: Math.round(Math.random() * 100),\\n      disk: Math.round(Math.random() * 100)\\n    };\\n  }\\n}\\n\\n// Usage example\\nconst commsHub = new CommunicationHub();\\n\\n// Set up the communication system\\nawait commsHub.createSlackBot();\\nawait commsHub.setupAlertSystem();\\n\\n// Send intelligent notification\\nawait commsHub.sendIntelligentNotification(\\n  'Weekly Product Update',\\n  `This week we launched 3 new features, fixed 12 bugs, and improved performance by 25%. User engagement is up 15% compared to last week.`,\\n  {\\n    channels: ['#general', '#product-updates'],\\n    emailLists: ['all-hands', 'stakeholders'],\\n    urgency: 'medium',\\n    includeAISummary: true\\n  }\\n);\\n\\n// Schedule email campaign\\nawait commsHub.createScheduledCampaign(\\n  'New Feature Announcement',\\n  'd-feature-announcement',\\n  'all-users',\\n  new Date(Date.now() + 24 * 60 * 60 * 1000), // Tomorrow\\n  [\\n    { email: 'user1@example.com', name: 'John', feature: 'Smart Analytics' },\\n    { email: 'user2@example.com', name: 'Jane', feature: 'Advanced Search' }\\n  ]\\n);\",\n        javascript: \"const { SlackAPI, SendGridAPI, ChatGPT } = require('macro_api');\\n\\nclass CommunicationHub {\\n  constructor() {\\n    this.slack = new SlackAPI({ \\n      botToken: process.env.SLACK_BOT_TOKEN \\n    });\\n    this.sendgrid = new SendGridAPI({\\n      apiKey: process.env.SENDGRID_API_KEY\\n    });\\n    this.chatgpt = new ChatGPT({\\n      apiKey: process.env.OPENAI_API_KEY\\n    });\\n  }\\n\\n  async sendIntelligentNotification(title, content, config) {\\n    let processedContent = content;\\n    \\n    // Generate AI summary if requested\\n    if (config.includeAISummary) {\\n      const summary = await this.chatgpt.chat(\\n        `Summarize this notification in 2-3 bullet points:\\\\n\\\\n${content}`,\\n        'You are a concise communication assistant.'\\n      );\\n      processedContent = `\\uD83D\\uDCCB **AI Summary:**\\\\n${summary}\\\\n\\\\n\\uD83D\\uDCC4 **Full Details:**\\\\n${content}`;\\n    }\\n\\n    // Send to Slack channels\\n    for (const channel of config.channels) {\\n      await this.sendSlackNotification(channel, title, processedContent, config.urgency);\\n    }\\n\\n    // Send email notifications\\n    if (config.emailLists.length > 0) {\\n      await this.sendEmailNotification(title, processedContent, config);\\n    }\\n  }\\n\\n  async sendSlackNotification(channel, title, content, urgency) {\\n    const urgencyEmoji = {\\n      low: '\\uD83D\\uDCAD',\\n      medium: '⚠️',\\n      high: '\\uD83D\\uDEA8'\\n    };\\n\\n    await this.slack.sendMessage(channel, '', {\\n      blocks: [\\n        {\\n          type: 'header',\\n          text: {\\n            type: 'plain_text',\\n            text: `${urgencyEmoji[urgency]} ${title}`\\n          }\\n        },\\n        {\\n          type: 'section',\\n          text: {\\n            type: 'mrkdwn',\\n            text: content\\n          }\\n        }\\n      ]\\n    });\\n  }\\n}\\n\\n// Usage\\nconst commsHub = new CommunicationHub();\\n\\nawait commsHub.sendIntelligentNotification(\\n  'Weekly Product Update',\\n  'This week we launched 3 new features and improved performance by 25%.',\\n  {\\n    channels: ['#general', '#product-updates'],\\n    emailLists: ['all-hands'],\\n    urgency: 'medium',\\n    includeAISummary: true\\n  }\\n);\"\n    },\n    {\n        id: \"cloud-deployment\",\n        title: \"Cloud Deployment Pipeline\",\n        description: \"Automated deployment pipeline using Vercel, Docker Hub, and AWS S3 with comprehensive monitoring.\",\n        category: \"Development & Cloud\",\n        difficulty: \"advanced\",\n        services: [\n            \"Vercel\",\n            \"DockerHub\",\n            \"S3\",\n            \"GitHub\",\n            \"Slack\"\n        ],\n        features: [\n            \"CI/CD\",\n            \"Container Registry\",\n            \"File Storage\",\n            \"Webhooks\"\n        ],\n        typescript: \"import { VercelAPI, DockerHubAPI, S3API, GitHubAPI, SlackAPI } from 'macro_api';\\nimport { createReadStream } from 'fs';\\nimport { join } from 'path';\\n\\ninterface DeploymentConfig {\\n  projectName: string;\\n  environment: 'staging' | 'production';\\n  gitBranch: string;\\n  dockerImage?: string;\\n  envVars: Record<string, string>;\\n  domains?: string[];\\n}\\n\\ninterface BuildArtifact {\\n  name: string;\\n  path: string;\\n  type: 'build' | 'asset' | 'config';\\n}\\n\\nclass CloudDeploymentPipeline {\\n  private vercel: VercelAPI;\\n  private dockerhub: DockerHubAPI;\\n  private s3: S3API;\\n  private github: GitHubAPI;\\n  private slack: SlackAPI;\\n\\n  constructor() {\\n    this.vercel = new VercelAPI({\\n      accessToken: process.env.VERCEL_TOKEN!\\n    });\\n    this.dockerhub = new DockerHubAPI({\\n      token: process.env.DOCKER_TOKEN!\\n    });\\n    this.s3 = new S3API({\\n      accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\\n      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,\\n      region: process.env.AWS_REGION!,\\n      bucketName: process.env.S3_BUCKET!\\n    });\\n    this.github = new GitHubAPI({\\n      token: process.env.GITHUB_TOKEN!\\n    });\\n    this.slack = new SlackAPI({\\n      botToken: process.env.SLACK_BOT_TOKEN!\\n    });\\n  }\\n\\n  async deployApplication(config: DeploymentConfig): Promise<string> {\\n    const deploymentId = `deploy-${Date.now()}`;\\n    \\n    try {\\n      // Notify start of deployment\\n      await this.notifyDeploymentStart(config, deploymentId);\\n      \\n      // Step 1: Build and push Docker image if specified\\n      if (config.dockerImage) {\\n        await this.buildAndPushImage(config);\\n      }\\n      \\n      // Step 2: Upload build artifacts to S3\\n      const artifacts = await this.uploadBuildArtifacts(config, deploymentId);\\n      \\n      // Step 3: Deploy to Vercel\\n      const deployment = await this.deployToVercel(config, artifacts);\\n      \\n      // Step 4: Configure domains\\n      if (config.domains) {\\n        await this.configureDomains(deployment.projectId, config.domains);\\n      }\\n      \\n      // Step 5: Wait for deployment to complete\\n      const finalDeployment = await this.vercel.waitForDeployment(\\n        deployment.uid, \\n        600000 // 10 minutes timeout\\n      );\\n      \\n      // Step 6: Run post-deployment tests\\n      await this.runPostDeploymentTests(finalDeployment.url);\\n      \\n      // Step 7: Update GitHub deployment status\\n      await this.updateGitHubDeploymentStatus(config, finalDeployment.url, 'success');\\n      \\n      // Step 8: Notify successful deployment\\n      await this.notifyDeploymentSuccess(config, finalDeployment);\\n      \\n      return finalDeployment.url;\\n      \\n    } catch (error) {\\n      await this.handleDeploymentFailure(config, deploymentId, error);\\n      throw error;\\n    }\\n  }\\n\\n  private async buildAndPushImage(config: DeploymentConfig): Promise<void> {\\n    const imageName = `${config.projectName}:${config.environment}-${Date.now()}`;\\n    \\n    // Check if repository exists\\n    const repoExists = await this.dockerhub.repositoryExists(config.projectName);\\n    \\n    if (!repoExists) {\\n      await this.dockerhub.createRepository(config.projectName, {\\n        description: `${config.projectName} ${config.environment} environment`,\\n        isPrivate: config.environment === 'production'\\n      });\\n    }\\n    \\n    // In a real implementation, you'd trigger a build process here\\n    console.log(`Building Docker image: ${imageName}`);\\n    \\n    // Simulate build time\\n    await new Promise(resolve => setTimeout(resolve, 30000));\\n    \\n    console.log(`Pushed Docker image: ${imageName}`);\\n  }\\n\\n  private async uploadBuildArtifacts(\\n    config: DeploymentConfig, \\n    deploymentId: string\\n  ): Promise<BuildArtifact[]> {\\n    const artifacts: BuildArtifact[] = [\\n      { name: 'build.zip', path: '/tmp/build.zip', type: 'build' },\\n      { name: 'assets.tar.gz', path: '/tmp/assets.tar.gz', type: 'asset' },\\n      { name: 'config.json', path: '/tmp/config.json', type: 'config' }\\n    ];\\n    \\n    for (const artifact of artifacts) {\\n      const key = `deployments/${deploymentId}/${artifact.name}`;\\n      \\n      // Create mock file content\\n      const content = Buffer.from(`Mock ${artifact.type} artifact for ${config.projectName}`);\\n      \\n      const uploadResult = await this.s3.uploadObject(key, content, {\\n        contentType: this.getContentType(artifact.name),\\n        metadata: {\\n          deployment_id: deploymentId,\\n          project: config.projectName,\\n          environment: config.environment,\\n          type: artifact.type\\n        }\\n      });\\n      \\n      console.log(`Uploaded artifact: ${artifact.name} to ${uploadResult.location}`);\\n    }\\n    \\n    return artifacts;\\n  }\\n\\n  private async deployToVercel(\\n    config: DeploymentConfig, \\n    artifacts: BuildArtifact[]\\n  ): Promise<any> {\\n    // Check if project exists\\n    let project;\\n    try {\\n      project = await this.vercel.getProject(config.projectName);\\n    } catch (error) {\\n      // Create project if it doesn't exist\\n      project = await this.vercel.createProject(config.projectName, {\\n        framework: 'nextjs',\\n        buildCommand: 'npm run build',\\n        outputDirectory: 'dist'\\n      });\\n    }\\n    \\n    // Set environment variables\\n    for (const [key, value] of Object.entries(config.envVars)) {\\n      await this.vercel.createEnvironmentVariable(\\n        project.id,\\n        key,\\n        value,\\n        config.environment === 'production' ? ['production'] : ['preview']\\n      );\\n    }\\n    \\n    // Create deployment\\n    const deployment = await this.vercel.createDeployment({\\n      name: config.projectName,\\n      gitSource: {\\n        type: 'github',\\n        repo: `owner/${config.projectName}`,\\n        ref: config.gitBranch\\n      },\\n      env: config.envVars,\\n      regions: ['iad1', 'sfo1'], // Multiple regions for better performance\\n      functions: {\\n        'pages/api/**': {\\n          runtime: 'nodejs18.x',\\n          memory: 1024,\\n          maxDuration: 30\\n        }\\n      }\\n    });\\n    \\n    return deployment;\\n  }\\n\\n  private async configureDomains(projectId: string, domains: string[]): Promise<void> {\\n    for (const domain of domains) {\\n      try {\\n        // Add domain to project\\n        await this.vercel.addDomain(projectId, domain);\\n        \\n        // Verify domain\\n        await this.vercel.verifyDomain(projectId, domain);\\n        \\n        console.log(`Configured domain: ${domain}`);\\n      } catch (error) {\\n        console.warn(`Failed to configure domain ${domain}:`, error);\\n      }\\n    }\\n  }\\n\\n  private async runPostDeploymentTests(deploymentUrl: string): Promise<void> {\\n    console.log(`Running post-deployment tests for ${deploymentUrl}`);\\n    \\n    // Health check\\n    const healthResponse = await fetch(`${deploymentUrl}/api/health`);\\n    if (!healthResponse.ok) {\\n      throw new Error(`Health check failed: ${healthResponse.status}`);\\n    }\\n    \\n    // Performance test\\n    const start = Date.now();\\n    await fetch(deploymentUrl);\\n    const loadTime = Date.now() - start;\\n    \\n    if (loadTime > 3000) {\\n      console.warn(`Slow load time detected: ${loadTime}ms`);\\n    }\\n    \\n    console.log('All post-deployment tests passed');\\n  }\\n\\n  private async updateGitHubDeploymentStatus(\\n    config: DeploymentConfig,\\n    deploymentUrl: string,\\n    status: 'success' | 'failure'\\n  ): Promise<void> {\\n    // This would typically be done via GitHub's deployment API\\n    console.log(`GitHub deployment status updated: ${status}`);\\n  }\\n\\n  private async notifyDeploymentStart(\\n    config: DeploymentConfig, \\n    deploymentId: string\\n  ): Promise<void> {\\n    await this.slack.sendMessage('#deployments',\\n      `\\uD83D\\uDE80 Starting deployment of *${config.projectName}* to *${config.environment}*`,\\n      {\\n        blocks: [\\n          {\\n            type: 'section',\\n            text: {\\n              type: 'mrkdwn',\\n              text: `\\uD83D\\uDE80 *Deployment Started*\\\\n• Project: ${config.projectName}\\\\n• Environment: ${config.environment}\\\\n• Branch: ${config.gitBranch}\\\\n• ID: ${deploymentId}`\\n            }\\n          }\\n        ]\\n      }\\n    );\\n  }\\n\\n  private async notifyDeploymentSuccess(\\n    config: DeploymentConfig, \\n    deployment: any\\n  ): Promise<void> {\\n    await this.slack.sendMessage('#deployments',\\n      `✅ Successfully deployed *${config.projectName}* to *${config.environment}*`,\\n      {\\n        blocks: [\\n          {\\n            type: 'section',\\n            text: {\\n              type: 'mrkdwn',\\n              text: `✅ *Deployment Successful*\\\\n• Project: ${config.projectName}\\\\n• Environment: ${config.environment}\\\\n• URL: ${deployment.url}\\\\n• Status: ${deployment.state}`\\n            }\\n          },\\n          {\\n            type: 'actions',\\n            elements: [\\n              {\\n                type: 'button',\\n                text: { type: 'plain_text', text: 'View Deployment' },\\n                url: deployment.url\\n              },\\n              {\\n                type: 'button',\\n                text: { type: 'plain_text', text: 'View Logs' },\\n                url: `https://vercel.com/deployments/${deployment.uid}`\\n              }\\n            ]\\n          }\\n        ]\\n      }\\n    );\\n  }\\n\\n  private async handleDeploymentFailure(\\n    config: DeploymentConfig,\\n    deploymentId: string,\\n    error: any\\n  ): Promise<void> {\\n    await this.slack.sendMessage('#deployments',\\n      `❌ Deployment of *${config.projectName}* failed`,\\n      {\\n        blocks: [\\n          {\\n            type: 'section',\\n            text: {\\n              type: 'mrkdwn',\\n              text: `❌ *Deployment Failed*\\\\n• Project: ${config.projectName}\\\\n• Environment: ${config.environment}\\\\n• Error: ${error.message}\\\\n• ID: ${deploymentId}`\\n            }\\n          }\\n        ]\\n      }\\n    );\\n    \\n    console.error('Deployment failed:', error);\\n  }\\n\\n  private getContentType(filename: string): string {\\n    const ext = filename.split('.').pop()?.toLowerCase();\\n    const types: Record<string, string> = {\\n      'zip': 'application/zip',\\n      'gz': 'application/gzip',\\n      'json': 'application/json',\\n      'js': 'application/javascript',\\n      'css': 'text/css'\\n    };\\n    return types[ext || ''] || 'application/octet-stream';\\n  }\\n\\n  async rollbackDeployment(projectName: string, targetVersion: string): Promise<void> {\\n    // Implementation for rollback functionality\\n    console.log(`Rolling back ${projectName} to version ${targetVersion}`);\\n  }\\n\\n  async getDeploymentMetrics(deploymentUrl: string): Promise<any> {\\n    // Get performance metrics\\n    return {\\n      loadTime: Math.random() * 2000,\\n      memoryUsage: Math.random() * 100,\\n      cpuUsage: Math.random() * 100,\\n      requestCount: Math.floor(Math.random() * 10000)\\n    };\\n  }\\n}\\n\\n// Usage example\\nconst pipeline = new CloudDeploymentPipeline();\\n\\n// Deploy to staging\\nconst stagingUrl = await pipeline.deployApplication({\\n  projectName: 'my-next-app',\\n  environment: 'staging',\\n  gitBranch: 'develop',\\n  dockerImage: 'my-next-app:staging',\\n  envVars: {\\n    NODE_ENV: 'staging',\\n    API_URL: 'https://api-staging.example.com',\\n    DATABASE_URL: process.env.STAGING_DB_URL!\\n  }\\n});\\n\\n// Deploy to production\\nconst productionUrl = await pipeline.deployApplication({\\n  projectName: 'my-next-app',\\n  environment: 'production',\\n  gitBranch: 'main',\\n  dockerImage: 'my-next-app:production',\\n  envVars: {\\n    NODE_ENV: 'production',\\n    API_URL: 'https://api.example.com',\\n    DATABASE_URL: process.env.PRODUCTION_DB_URL!\\n  },\\n  domains: ['app.example.com', 'www.app.example.com']\\n});\\n\\nconsole.log(`Staging deployed to: ${stagingUrl}`);\\nconsole.log(`Production deployed to: ${productionUrl}`);\",\n        javascript: \"const { VercelAPI, DockerHubAPI, S3API, GitHubAPI, SlackAPI } = require('macro_api');\\n\\nclass CloudDeploymentPipeline {\\n  constructor() {\\n    this.vercel = new VercelAPI({\\n      accessToken: process.env.VERCEL_TOKEN\\n    });\\n    this.dockerhub = new DockerHubAPI({\\n      token: process.env.DOCKER_TOKEN\\n    });\\n    this.s3 = new S3API({\\n      accessKeyId: process.env.AWS_ACCESS_KEY_ID,\\n      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\\n      region: process.env.AWS_REGION,\\n      bucketName: process.env.S3_BUCKET\\n    });\\n    this.slack = new SlackAPI({\\n      botToken: process.env.SLACK_BOT_TOKEN\\n    });\\n  }\\n\\n  async deployApplication(config) {\\n    const deploymentId = `deploy-${Date.now()}`;\\n    \\n    try {\\n      // Notify start\\n      await this.notifyDeploymentStart(config, deploymentId);\\n      \\n      // Upload artifacts to S3\\n      const artifacts = await this.uploadBuildArtifacts(config, deploymentId);\\n      \\n      // Deploy to Vercel\\n      const deployment = await this.deployToVercel(config, artifacts);\\n      \\n      // Wait for completion\\n      const finalDeployment = await this.vercel.waitForDeployment(deployment.uid, 600000);\\n      \\n      // Notify success\\n      await this.notifyDeploymentSuccess(config, finalDeployment);\\n      \\n      return finalDeployment.url;\\n      \\n    } catch (error) {\\n      await this.handleDeploymentFailure(config, deploymentId, error);\\n      throw error;\\n    }\\n  }\\n\\n  async uploadBuildArtifacts(config, deploymentId) {\\n    const artifacts = [\\n      { name: 'build.zip', type: 'build' },\\n      { name: 'assets.tar.gz', type: 'asset' }\\n    ];\\n    \\n    for (const artifact of artifacts) {\\n      const key = `deployments/${deploymentId}/${artifact.name}`;\\n      const content = Buffer.from(`Mock ${artifact.type} artifact`);\\n      \\n      await this.s3.uploadObject(key, content, {\\n        metadata: {\\n          deployment_id: deploymentId,\\n          project: config.projectName,\\n          environment: config.environment\\n        }\\n      });\\n    }\\n    \\n    return artifacts;\\n  }\\n}\\n\\n// Usage\\nconst pipeline = new CloudDeploymentPipeline();\\n\\nconst deploymentUrl = await pipeline.deployApplication({\\n  projectName: 'my-app',\\n  environment: 'production',\\n  gitBranch: 'main',\\n  envVars: {\\n    NODE_ENV: 'production',\\n    API_URL: 'https://api.example.com'\\n  }\\n});\"\n    },\n    {\n        id: \"gaming-analytics\",\n        title: \"Gaming Analytics Dashboard\",\n        description: \"Comprehensive gaming analytics using Valorant API and Football API with real-time statistics and leaderboards.\",\n        category: \"Gaming & Entertainment\",\n        difficulty: \"intermediate\",\n        services: [\n            \"Valorant\",\n            \"Football\",\n            \"Notion\",\n            \"Slack\"\n        ],\n        features: [\n            \"Statistics Tracking\",\n            \"Leaderboards\",\n            \"Data Storage\",\n            \"Notifications\"\n        ],\n        typescript: \"import { Valorant, FootballAPI, NotionAPI, SlackAPI } from 'macro_api';\\n\\ninterface PlayerStats {\\n  puuid: string;\\n  gameName: string;\\n  tagLine: string;\\n  rank: string;\\n  rr: number;\\n  kd: number;\\n  winRate: number;\\n  recentMatches: any[];\\n}\\n\\ninterface TeamStats {\\n  teamId: number;\\n  name: string;\\n  league: string;\\n  wins: number;\\n  losses: number;\\n  draws: number;\\n  goalsFor: number;\\n  goalsAgainst: number;\\n  position: number;\\n}\\n\\nclass GamingAnalyticsDashboard {\\n  private valorant: Valorant;\\n  private football: FootballAPI;\\n  private notion: NotionAPI;\\n  private slack: SlackAPI;\\n  private playerDatabase: string; // Notion database ID\\n  private teamDatabase: string; // Notion database ID\\n\\n  constructor() {\\n    this.valorant = new Valorant(process.env.HENRIK_API_KEY);\\n    this.football = new FootballAPI({\\n      apiKey: process.env.FOOTBALL_API_KEY!\\n    });\\n    this.notion = new NotionAPI({\\n      apiKey: process.env.NOTION_API_KEY!\\n    });\\n    this.slack = new SlackAPI({\\n      botToken: process.env.SLACK_BOT_TOKEN!\\n    });\\n    this.playerDatabase = process.env.NOTION_PLAYER_DB!;\\n    this.teamDatabase = process.env.NOTION_TEAM_DB!;\\n  }\\n\\n  async trackValorantPlayer(gameName: string, tagLine: string, region: string = 'na'): Promise<PlayerStats> {\\n    try {\\n      // Get player account\\n      const account = await this.valorant.getAccount(gameName, tagLine);\\n      \\n      // Get MMR data\\n      const mmrData = await this.valorant.getMMR(gameName, tagLine, { region });\\n      \\n      // Get match history\\n      const matchHistory = await this.valorant.getMatchHistory(region, gameName, tagLine, {\\n        queue: 'competitive'\\n      });\\n      \\n      // Calculate detailed stats\\n      const playerStats = await this.valorant.getPlayerStats(region, gameName, tagLine);\\n      \\n      const stats: PlayerStats = {\\n        puuid: account.puuid,\\n        gameName: account.name,\\n        tagLine: account.tag,\\n        rank: mmrData.currenttierpatched || 'Unranked',\\n        rr: mmrData.ranking_in_tier || 0,\\n        kd: parseFloat((playerStats.combat?.kd || '0').toString()),\\n        winRate: parseFloat((playerStats.overview?.winRate || '0%').replace('%', '')),\\n        recentMatches: matchHistory.slice(0, 5)\\n      };\\n      \\n      // Store in Notion database\\n      await this.storePlayerStats(stats);\\n      \\n      // Check for rank changes and notify\\n      await this.checkRankChanges(stats);\\n      \\n      return stats;\\n    } catch (error) {\\n      console.error('Error tracking Valorant player:', error);\\n      throw error;\\n    }\\n  }\\n\\n  async trackFootballTeam(teamId: number, leagueId: number, season: number): Promise<TeamStats> {\\n    try {\\n      // Get team information\\n      const teamInfo = await this.football.getTeams({ id: teamId });\\n      const team = teamInfo[0];\\n      \\n      // Get team statistics\\n      const teamStats = await this.football.getTeamStatistics({\\n        league: leagueId,\\n        team: teamId,\\n        season\\n      });\\n      \\n      // Get league standings\\n      const standings = await this.football.getStandings({\\n        league: leagueId,\\n        season,\\n        team: teamId\\n      });\\n      \\n      const stats: TeamStats = {\\n        teamId: team.id,\\n        name: team.name,\\n        league: teamStats.league.name,\\n        wins: teamStats.fixtures.wins.total,\\n        losses: teamStats.fixtures.loses.total,\\n        draws: teamStats.fixtures.draws.total,\\n        goalsFor: teamStats.goals.for.total.total,\\n        goalsAgainst: teamStats.goals.against.total.total,\\n        position: standings[0].league.standings[0].find((s: any) => s.team.id === teamId)?.rank || 0\\n      };\\n      \\n      // Store in Notion database\\n      await this.storeTeamStats(stats);\\n      \\n      // Check for significant changes\\n      await this.checkTeamPerformance(stats);\\n      \\n      return stats;\\n    } catch (error) {\\n      console.error('Error tracking football team:', error);\\n      throw error;\\n    }\\n  }\\n\\n  private async storePlayerStats(stats: PlayerStats): Promise<void> {\\n    const properties = {\\n      'Player Name': {\\n        title: [{ text: { content: `${stats.gameName}#${stats.tagLine}` } }]\\n      },\\n      'PUUID': {\\n        rich_text: [{ text: { content: stats.puuid } }]\\n      },\\n      'Rank': {\\n        select: { name: stats.rank }\\n      },\\n      'RR': {\\n        number: stats.rr\\n      },\\n      'K/D Ratio': {\\n        number: stats.kd\\n      },\\n      'Win Rate': {\\n        number: stats.winRate\\n      },\\n      'Last Updated': {\\n        date: { start: new Date().toISOString() }\\n      }\\n    };\\n\\n    await this.notion.createPage({\\n      parent: { database_id: this.playerDatabase },\\n      properties\\n    });\\n  }\\n\\n  private async storeTeamStats(stats: TeamStats): Promise<void> {\\n    const properties = {\\n      'Team Name': {\\n        title: [{ text: { content: stats.name } }]\\n      },\\n      'League': {\\n        select: { name: stats.league }\\n      },\\n      'Position': {\\n        number: stats.position\\n      },\\n      'Wins': {\\n        number: stats.wins\\n      },\\n      'Losses': {\\n        number: stats.losses\\n      },\\n      'Draws': {\\n        number: stats.draws\\n      },\\n      'Goals For': {\\n        number: stats.goalsFor\\n      },\\n      'Goals Against': {\\n        number: stats.goalsAgainst\\n      },\\n      'Last Updated': {\\n        date: { start: new Date().toISOString() }\\n      }\\n    };\\n\\n    await this.notion.createPage({\\n      parent: { database_id: this.teamDatabase },\\n      properties\\n    });\\n  }\\n\\n  private async checkRankChanges(currentStats: PlayerStats): Promise<void> {\\n    // Query previous stats from Notion\\n    const previousData = await this.notion.queryDatabase(this.playerDatabase, {\\n      filter: {\\n        property: 'PUUID',\\n        rich_text: { equals: currentStats.puuid }\\n      },\\n      sorts: [{ timestamp: 'last_edited_time', direction: 'descending' }]\\n    });\\n\\n    if (previousData.results.length > 1) {\\n      const previousEntry = previousData.results[1];\\n      const previousRank = this.getPropertyValue(previousEntry.properties, 'Rank');\\n      \\n      if (previousRank !== currentStats.rank) {\\n        await this.slack.sendMessage('#gaming-updates',\\n          `\\uD83C\\uDFAE Rank Update: *${currentStats.gameName}#${currentStats.tagLine}* \\\\n${previousRank} ➡️ ${currentStats.rank}`,\\n          {\\n            blocks: [\\n              {\\n                type: 'section',\\n                text: {\\n                  type: 'mrkdwn',\\n                  text: `\\uD83C\\uDFAE *Valorant Rank Update*\\\\n• Player: ${currentStats.gameName}#${currentStats.tagLine}\\\\n• Previous: ${previousRank}\\\\n• Current: ${currentStats.rank}\\\\n• RR: ${currentStats.rr}\\\\n• K/D: ${currentStats.kd}\\\\n• Win Rate: ${currentStats.winRate}%`\\n                }\\n              }\\n            ]\\n          }\\n        );\\n      }\\n    }\\n  }\\n\\n  private async checkTeamPerformance(currentStats: TeamStats): Promise<void> {\\n    // Check if team is in top 4 (Champions League spots)\\n    if (currentStats.position <= 4) {\\n      await this.slack.sendMessage('#football-updates',\\n        `⚽ Champions League Position: *${currentStats.name}* is currently ${this.getPositionSuffix(currentStats.position)} in ${currentStats.league}!`,\\n        {\\n          blocks: [\\n            {\\n              type: 'section',\\n              text: {\\n                type: 'mrkdwn',\\n                text: `⚽ *${currentStats.name} Performance*\\\\n• Position: ${currentStats.position}\\\\n• League: ${currentStats.league}\\\\n• Record: ${currentStats.wins}W-${currentStats.draws}D-${currentStats.losses}L\\\\n• Goals: ${currentStats.goalsFor} for, ${currentStats.goalsAgainst} against`\\n              }\\n            }\\n          ]\\n        }\\n      );\\n    }\\n  }\\n\\n  async generateLeaderboard(type: 'valorant' | 'football'): Promise<string> {\\n    if (type === 'valorant') {\\n      const playersData = await this.notion.queryDatabase(this.playerDatabase, {\\n        sorts: [{ property: 'RR', direction: 'descending' }]\\n      });\\n\\n      let leaderboard = '\\uD83C\\uDFC6 **Valorant Leaderboard**\\\\n\\\\n';\\n      playersData.results.slice(0, 10).forEach((player, index) => {\\n        const name = this.getPropertyValue(player.properties, 'Player Name');\\n        const rank = this.getPropertyValue(player.properties, 'Rank');\\n        const rr = this.getPropertyValue(player.properties, 'RR');\\n        const kd = this.getPropertyValue(player.properties, 'K/D Ratio');\\n        \\n        leaderboard += `${index + 1}. **${name}** - ${rank} (${rr} RR) | K/D: ${kd}\\\\n`;\\n      });\\n\\n      return leaderboard;\\n    } else {\\n      const teamsData = await this.notion.queryDatabase(this.teamDatabase, {\\n        sorts: [{ property: 'Position', direction: 'ascending' }]\\n      });\\n\\n      let leaderboard = '⚽ **Football Standings**\\\\n\\\\n';\\n      teamsData.results.slice(0, 10).forEach((team) => {\\n        const name = this.getPropertyValue(team.properties, 'Team Name');\\n        const position = this.getPropertyValue(team.properties, 'Position');\\n        const wins = this.getPropertyValue(team.properties, 'Wins');\\n        const draws = this.getPropertyValue(team.properties, 'Draws');\\n        const losses = this.getPropertyValue(team.properties, 'Losses');\\n        \\n        leaderboard += `${position}. **${name}** - ${wins}W ${draws}D ${losses}L\\\\n`;\\n      });\\n\\n      return leaderboard;\\n    }\\n  }\\n\\n  async scheduleUpdates(): Promise<void> {\\n    // Update Valorant players every hour\\n    setInterval(async () => {\\n      const players = ['TenZ', 'Shroud', 'tarik']; // Example players\\n      for (const player of players) {\\n        try {\\n          await this.trackValorantPlayer(player, 'NA1');\\n        } catch (error) {\\n          console.error(`Error updating ${player}:`, error);\\n        }\\n      }\\n    }, 3600000); // 1 hour\\n\\n    // Update football teams twice daily\\n    setInterval(async () => {\\n      const teams = [33, 40, 50]; // Example team IDs (Real Madrid, Liverpool, Manchester City)\\n      for (const teamId of teams) {\\n        try {\\n          await this.trackFootballTeam(teamId, 39, 2023); // Premier League 2023\\n        } catch (error) {\\n          console.error(`Error updating team ${teamId}:`, error);\\n        }\\n      }\\n    }, 43200000); // 12 hours\\n\\n    // Send daily leaderboard updates\\n    setInterval(async () => {\\n      const valorantLeaderboard = await this.generateLeaderboard('valorant');\\n      const footballLeaderboard = await this.generateLeaderboard('football');\\n      \\n      await this.slack.sendMessage('#daily-stats', valorantLeaderboard);\\n      await this.slack.sendMessage('#daily-stats', footballLeaderboard);\\n    }, 86400000); // 24 hours\\n  }\\n\\n  private getPropertyValue(properties: any, propertyName: string): any {\\n    const property = properties[propertyName];\\n    if (!property) return null;\\n    \\n    switch (property.type) {\\n      case 'title':\\n        return property.title[0]?.plain_text || '';\\n      case 'rich_text':\\n        return property.rich_text[0]?.plain_text || '';\\n      case 'select':\\n        return property.select?.name || '';\\n      case 'number':\\n        return property.number || 0;\\n      default:\\n        return null;\\n    }\\n  }\\n\\n  private getPositionSuffix(position: number): string {\\n    const suffixes = ['', '1st', '2nd', '3rd'];\\n    return suffixes[position] || `${position}th`;\\n  }\\n}\\n\\n// Usage example\\nconst analytics = new GamingAnalyticsDashboard();\\n\\n// Track individual players/teams\\nconst valorantStats = await analytics.trackValorantPlayer('TenZ', 'NA1');\\nconst footballStats = await analytics.trackFootballTeam(33, 39, 2023); // Real Madrid in Premier League\\n\\n// Generate and send leaderboards\\nconst valorantLeaderboard = await analytics.generateLeaderboard('valorant');\\nconst footballLeaderboard = await analytics.generateLeaderboard('football');\\n\\nconsole.log('Valorant Stats:', valorantStats);\\nconsole.log('Football Stats:', footballStats);\\n\\n// Start automated tracking\\nawait analytics.scheduleUpdates();\",\n        javascript: \"const { Valorant, FootballAPI, NotionAPI, SlackAPI } = require('macro_api');\\n\\nclass GamingAnalyticsDashboard {\\n  constructor() {\\n    this.valorant = new Valorant(process.env.HENRIK_API_KEY);\\n    this.football = new FootballAPI({\\n      apiKey: process.env.FOOTBALL_API_KEY\\n    });\\n    this.notion = new NotionAPI({\\n      apiKey: process.env.NOTION_API_KEY\\n    });\\n    this.slack = new SlackAPI({\\n      botToken: process.env.SLACK_BOT_TOKEN\\n    });\\n    this.playerDatabase = process.env.NOTION_PLAYER_DB;\\n    this.teamDatabase = process.env.NOTION_TEAM_DB;\\n  }\\n\\n  async trackValorantPlayer(gameName, tagLine, region = 'na') {\\n    try {\\n      // Get player data\\n      const account = await this.valorant.getAccount(gameName, tagLine);\\n      const mmrData = await this.valorant.getMMR(gameName, tagLine, { region });\\n      const playerStats = await this.valorant.getPlayerStats(region, gameName, tagLine);\\n      \\n      const stats = {\\n        puuid: account.puuid,\\n        gameName: account.name,\\n        tagLine: account.tag,\\n        rank: mmrData.currenttierpatched || 'Unranked',\\n        rr: mmrData.ranking_in_tier || 0,\\n        kd: parseFloat(playerStats.combat?.kd || '0'),\\n        winRate: parseFloat((playerStats.overview?.winRate || '0%').replace('%', ''))\\n      };\\n      \\n      // Store in Notion\\n      await this.storePlayerStats(stats);\\n      \\n      // Check for changes\\n      await this.checkRankChanges(stats);\\n      \\n      return stats;\\n    } catch (error) {\\n      console.error('Error tracking player:', error);\\n      throw error;\\n    }\\n  }\\n\\n  async generateLeaderboard(type) {\\n    if (type === 'valorant') {\\n      const playersData = await this.notion.queryDatabase(this.playerDatabase, {\\n        sorts: [{ property: 'RR', direction: 'descending' }]\\n      });\\n\\n      let leaderboard = '\\uD83C\\uDFC6 **Valorant Leaderboard**\\\\n\\\\n';\\n      playersData.results.slice(0, 10).forEach((player, index) => {\\n        const name = this.getPropertyValue(player.properties, 'Player Name');\\n        const rank = this.getPropertyValue(player.properties, 'Rank');\\n        const rr = this.getPropertyValue(player.properties, 'RR');\\n        \\n        leaderboard += `${index + 1}. **${name}** - ${rank} (${rr} RR)\\\\n`;\\n      });\\n\\n      return leaderboard;\\n    }\\n  }\\n}\\n\\n// Usage\\nconst analytics = new GamingAnalyticsDashboard();\\n\\nconst stats = await analytics.trackValorantPlayer('TenZ', 'NA1');\\nconst leaderboard = await analytics.generateLeaderboard('valorant');\\n\\nconsole.log('Player Stats:', stats);\"\n    }\n];\n/* harmony default export */ __webpack_exports__[\"default\"] = (codeExamples);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9kYXRhL2NvZGVFeGFtcGxlcy50cyIsIm1hcHBpbmdzIjoiO0FBQUEsMkJBQTJCO0FBYzNCLE1BQU1BLGVBQThCO0lBQ2xDO1FBQ0VDLElBQUk7UUFDSkMsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxVQUFVO1lBQUM7WUFBVztZQUFVO1NBQVE7UUFDeENDLFVBQVU7WUFBQztZQUFrQjtZQUFXO1lBQWU7U0FBYTtRQUNwRUMsWUFBYTtRQW9FYkMsWUFBYTtJQW9FZjtJQUNBO1FBQ0VSLElBQUk7UUFDSkMsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxVQUFVO1lBQUM7WUFBVztTQUFXO1FBQ2pDQyxVQUFVO1lBQUM7WUFBYTtZQUFvQjtTQUFxQjtRQUNqRUMsWUFBYTtRQWdIYkMsWUFBYTtJQXdFZjtJQUNBO1FBQ0VSLElBQUk7UUFDSkMsT0FBTztRQUNQQyxhQUFhO1FBQ2JDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxVQUFVO1lBQUM7WUFBVTtZQUFVO1NBQVc7UUFDMUNDLFVBQVU7WUFBQztZQUFZO1lBQWlCO1lBQXVCO1NBQWlCO1FBQ2hGQyxZQUFhO1FBMlBiQyxZQUFhO0lBaUVmO0lBQ0E7UUFDRVIsSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLFVBQVU7WUFBQztZQUFTO1lBQVk7U0FBVTtRQUMxQ0MsVUFBVTtZQUFDO1lBQWtCO1lBQW1CO1NBQWlCO1FBQ2pFQyxZQUFhO1FBbVNiQyxZQUFhO0lBK0VmO0lBQ0E7UUFDRVIsSUFBSTtRQUNKQyxPQUFPO1FBQ1BDLGFBQWE7UUFDYkMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLFVBQVU7WUFBQztZQUFVO1lBQWE7WUFBTTtZQUFVO1NBQVE7UUFDMURDLFVBQVU7WUFBQztZQUFTO1lBQXNCO1lBQWdCO1NBQVc7UUFDckVDLFlBQWE7UUE0WGJDLFlBQWE7SUFtRmY7SUFDQTtRQUNFUixJQUFJO1FBQ0pDLE9BQU87UUFDUEMsYUFBYTtRQUNiQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsVUFBVTtZQUFDO1lBQVk7WUFBWTtZQUFVO1NBQVE7UUFDckRDLFVBQVU7WUFBQztZQUF1QjtZQUFnQjtZQUFnQjtTQUFnQjtRQUNsRkMsWUFBYTtRQThXYkMsWUFBYTtJQTJFZjtDQUNEO0FBRUQsK0RBQWVULFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RhdGEvY29kZUV4YW1wbGVzLnRzPzQ4YmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2RhdGEvY29kZUV4YW1wbGVzLnRzXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvZGVFeGFtcGxlIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBjYXRlZ29yeTogc3RyaW5nO1xyXG4gIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicgfCAnaW50ZXJtZWRpYXRlJyB8ICdhZHZhbmNlZCc7XHJcbiAgdHlwZXNjcmlwdDogc3RyaW5nO1xyXG4gIGphdmFzY3JpcHQ6IHN0cmluZztcclxuICBzZXJ2aWNlczogc3RyaW5nW107XHJcbiAgZmVhdHVyZXM6IHN0cmluZ1tdO1xyXG59XHJcblxyXG5jb25zdCBjb2RlRXhhbXBsZXM6IENvZGVFeGFtcGxlW10gPSBbXHJcbiAge1xyXG4gICAgaWQ6ICd1bmlmaWVkLWNsaWVudCcsXHJcbiAgICB0aXRsZTogJ1VuaWZpZWQgQVBJIENsaWVudCcsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0luaXRpYWxpemUgbXVsdGlwbGUgQVBJIHNlcnZpY2VzIHdpdGggYnVpbHQtaW4gY2FjaGluZywgZXJyb3IgaGFuZGxpbmcsIGFuZCByZXRyeSBsb2dpYyBmb3IgcHJvZHVjdGlvbiBhcHBsaWNhdGlvbnMuJyxcclxuICAgIGNhdGVnb3J5OiAnR2V0dGluZyBTdGFydGVkJyxcclxuICAgIGRpZmZpY3VsdHk6ICdiZWdpbm5lcicsXHJcbiAgICBzZXJ2aWNlczogWydDaGF0R1BUJywgJ1N0cmlwZScsICdTbGFjayddLFxyXG4gICAgZmVhdHVyZXM6IFsnRXJyb3IgSGFuZGxpbmcnLCAnQ2FjaGluZycsICdSZXRyeSBMb2dpYycsICdUeXBlU2NyaXB0J10sXHJcbiAgICB0eXBlc2NyaXB0OiBgaW1wb3J0IHsgTWFjcm9BUElDbGllbnQsIENoYXRHUFQsIFN0cmlwZUFQSSwgU2xhY2tBUEkgfSBmcm9tICdtYWNyb19hcGknO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSB1bmlmaWVkIGNsaWVudCB3aXRoIGNhY2hpbmcgYW5kIGVycm9yIGhhbmRsaW5nXHJcbmNvbnN0IGNsaWVudCA9IG5ldyBNYWNyb0FQSUNsaWVudCh7XHJcbiAgY2FjaGU6IHtcclxuICAgIHR5cGU6ICdoeWJyaWQnLFxyXG4gICAgdHRsOiAzNjAwLCAvLyAxIGhvdXJcclxuICAgIHJlZGlzOiB7IHVybDogcHJvY2Vzcy5lbnYuUkVESVNfVVJMIH1cclxuICB9LFxyXG4gIHJldHJpZXM6IHtcclxuICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICBiYXNlRGVsYXk6IDEwMDAsXHJcbiAgICBtYXhEZWxheTogMTAwMDBcclxuICB9XHJcbn0pO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBBUEkgc2VydmljZXNcclxuY29uc3QgY2hhdGdwdCA9IG5ldyBDaGF0R1BUKHsgXHJcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSEgXHJcbn0pO1xyXG5cclxuY29uc3Qgc3RyaXBlID0gbmV3IFN0cmlwZUFQSSh7IFxyXG4gIHNlY3JldEtleTogcHJvY2Vzcy5lbnYuU1RSSVBFX1NFQ1JFVF9LRVkhIFxyXG59KTtcclxuXHJcbmNvbnN0IHNsYWNrID0gbmV3IFNsYWNrQVBJKHsgXHJcbiAgYm90VG9rZW46IHByb2Nlc3MuZW52LlNMQUNLX0JPVF9UT0tFTiEgXHJcbn0pO1xyXG5cclxuLy8gVXNlIHdpdGggYXV0b21hdGljIGVycm9yIGhhbmRsaW5nIGFuZCBjYWNoaW5nXHJcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDdXN0b21lclF1ZXJ5KHF1ZXJ5OiBzdHJpbmcsIGN1c3RvbWVySWQ6IHN0cmluZykge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBHZW5lcmF0ZSBBSSByZXNwb25zZSB3aXRoIGNhY2hpbmdcclxuICAgIGNvbnN0IGFpUmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuZXhlY3V0ZShcclxuICAgICAgKCkgPT4gY2hhdGdwdC5jaGF0KHF1ZXJ5LCBcIllvdSBhcmUgYSBoZWxwZnVsIGN1c3RvbWVyIHNlcnZpY2UgYXNzaXN0YW50LlwiKSxcclxuICAgICAge1xyXG4gICAgICAgIHNlcnZpY2U6ICdvcGVuYWknLFxyXG4gICAgICAgIG1ldGhvZDogJ2NoYXQnLFxyXG4gICAgICAgIHBhcmFtczogeyBxdWVyeSwgY29udGV4dDogJ2N1c3RvbWVyX3NlcnZpY2UnIH0sXHJcbiAgICAgICAgY2FjaGVUdGw6IDE4MDAgLy8gMzAgbWludXRlc1xyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIEdldCBjdXN0b21lciBkYXRhXHJcbiAgICBjb25zdCBjdXN0b21lciA9IGF3YWl0IGNsaWVudC5leGVjdXRlKFxyXG4gICAgICAoKSA9PiBzdHJpcGUuZ2V0Q3VzdG9tZXIoY3VzdG9tZXJJZCksXHJcbiAgICAgIHtcclxuICAgICAgICBzZXJ2aWNlOiAnc3RyaXBlJyxcclxuICAgICAgICBtZXRob2Q6ICdnZXRDdXN0b21lcicsXHJcbiAgICAgICAgcGFyYW1zOiB7IGN1c3RvbWVySWQgfVxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIFNlbmQgbm90aWZpY2F0aW9uIHRvIHN1cHBvcnQgY2hhbm5lbFxyXG4gICAgYXdhaXQgc2xhY2suc2VuZE1lc3NhZ2UoJyNjdXN0b21lci1zdXBwb3J0JywgXHJcbiAgICAgIFxcYE5ldyBxdWVyeSBmcm9tIFxcJHtjdXN0b21lci5lbWFpbH06IFxcJHthaVJlc3BvbnNlfVxcYFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByZXNwb25zZTogYWlSZXNwb25zZSxcclxuICAgICAgY3VzdG9tZXI6IGN1c3RvbWVyLFxyXG4gICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyBxdWVyeTonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1gLFxyXG4gICAgamF2YXNjcmlwdDogYGNvbnN0IHsgTWFjcm9BUElDbGllbnQsIENoYXRHUFQsIFN0cmlwZUFQSSwgU2xhY2tBUEkgfSA9IHJlcXVpcmUoJ21hY3JvX2FwaScpO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSB1bmlmaWVkIGNsaWVudCB3aXRoIGNhY2hpbmcgYW5kIGVycm9yIGhhbmRsaW5nXHJcbmNvbnN0IGNsaWVudCA9IG5ldyBNYWNyb0FQSUNsaWVudCh7XHJcbiAgY2FjaGU6IHtcclxuICAgIHR5cGU6ICdoeWJyaWQnLFxyXG4gICAgdHRsOiAzNjAwLCAvLyAxIGhvdXJcclxuICAgIHJlZGlzOiB7IHVybDogcHJvY2Vzcy5lbnYuUkVESVNfVVJMIH1cclxuICB9LFxyXG4gIHJldHJpZXM6IHtcclxuICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICBiYXNlRGVsYXk6IDEwMDAsXHJcbiAgICBtYXhEZWxheTogMTAwMDBcclxuICB9XHJcbn0pO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBBUEkgc2VydmljZXNcclxuY29uc3QgY2hhdGdwdCA9IG5ldyBDaGF0R1BUKHsgXHJcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSBcclxufSk7XHJcblxyXG5jb25zdCBzdHJpcGUgPSBuZXcgU3RyaXBlQVBJKHsgXHJcbiAgc2VjcmV0S2V5OiBwcm9jZXNzLmVudi5TVFJJUEVfU0VDUkVUX0tFWSBcclxufSk7XHJcblxyXG5jb25zdCBzbGFjayA9IG5ldyBTbGFja0FQSSh7IFxyXG4gIGJvdFRva2VuOiBwcm9jZXNzLmVudi5TTEFDS19CT1RfVE9LRU4gXHJcbn0pO1xyXG5cclxuLy8gVXNlIHdpdGggYXV0b21hdGljIGVycm9yIGhhbmRsaW5nIGFuZCBjYWNoaW5nXHJcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDdXN0b21lclF1ZXJ5KHF1ZXJ5LCBjdXN0b21lcklkKSB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEdlbmVyYXRlIEFJIHJlc3BvbnNlIHdpdGggY2FjaGluZ1xyXG4gICAgY29uc3QgYWlSZXNwb25zZSA9IGF3YWl0IGNsaWVudC5leGVjdXRlKFxyXG4gICAgICAoKSA9PiBjaGF0Z3B0LmNoYXQocXVlcnksIFwiWW91IGFyZSBhIGhlbHBmdWwgY3VzdG9tZXIgc2VydmljZSBhc3Npc3RhbnQuXCIpLFxyXG4gICAgICB7XHJcbiAgICAgICAgc2VydmljZTogJ29wZW5haScsXHJcbiAgICAgICAgbWV0aG9kOiAnY2hhdCcsXHJcbiAgICAgICAgcGFyYW1zOiB7IHF1ZXJ5LCBjb250ZXh0OiAnY3VzdG9tZXJfc2VydmljZScgfSxcclxuICAgICAgICBjYWNoZVR0bDogMTgwMCAvLyAzMCBtaW51dGVzXHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLy8gR2V0IGN1c3RvbWVyIGRhdGFcclxuICAgIGNvbnN0IGN1c3RvbWVyID0gYXdhaXQgY2xpZW50LmV4ZWN1dGUoXHJcbiAgICAgICgpID0+IHN0cmlwZS5nZXRDdXN0b21lcihjdXN0b21lcklkKSxcclxuICAgICAge1xyXG4gICAgICAgIHNlcnZpY2U6ICdzdHJpcGUnLFxyXG4gICAgICAgIG1ldGhvZDogJ2dldEN1c3RvbWVyJyxcclxuICAgICAgICBwYXJhbXM6IHsgY3VzdG9tZXJJZCB9XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLy8gU2VuZCBub3RpZmljYXRpb24gdG8gc3VwcG9ydCBjaGFubmVsXHJcbiAgICBhd2FpdCBzbGFjay5zZW5kTWVzc2FnZSgnI2N1c3RvbWVyLXN1cHBvcnQnLCBcclxuICAgICAgXFxgTmV3IHF1ZXJ5IGZyb20gXFwke2N1c3RvbWVyLmVtYWlsfTogXFwke2FpUmVzcG9uc2V9XFxgXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJlc3BvbnNlOiBhaVJlc3BvbnNlLFxyXG4gICAgICBjdXN0b21lcjogY3VzdG9tZXIsXHJcbiAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIHF1ZXJ5OicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufWBcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAnYWktY29udGVudC1nZW5lcmF0aW9uJyxcclxuICAgIHRpdGxlOiAnQUkgQ29udGVudCBHZW5lcmF0aW9uJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnR2VuZXJhdGUgYmxvZyBwb3N0cywgY29kZSwgYW5kIG1hcmtldGluZyBjb250ZW50IHVzaW5nIENoYXRHUFQgYW5kIERlZXBTZWVrIHdpdGggc3RyZWFtaW5nIHJlc3BvbnNlcy4nLFxyXG4gICAgY2F0ZWdvcnk6ICdBSSAmIE1hY2hpbmUgTGVhcm5pbmcnLFxyXG4gICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXHJcbiAgICBzZXJ2aWNlczogWydDaGF0R1BUJywgJ0RlZXBTZWVrJ10sXHJcbiAgICBmZWF0dXJlczogWydTdHJlYW1pbmcnLCAnRnVuY3Rpb24gQ2FsbGluZycsICdDb250ZW50IEdlbmVyYXRpb24nXSxcclxuICAgIHR5cGVzY3JpcHQ6IGBpbXBvcnQgeyBDaGF0R1BULCBEZWVwU2VlayB9IGZyb20gJ21hY3JvX2FwaSc7XHJcblxyXG5pbnRlcmZhY2UgQ29udGVudFJlcXVlc3Qge1xyXG4gIHRvcGljOiBzdHJpbmc7XHJcbiAgdHlwZTogJ2Jsb2cnIHwgJ2NvZGUnIHwgJ21hcmtldGluZyc7XHJcbiAgbGVuZ3RoOiAnc2hvcnQnIHwgJ21lZGl1bScgfCAnbG9uZyc7XHJcbiAgYXVkaWVuY2U6ICd0ZWNobmljYWwnIHwgJ2dlbmVyYWwnIHwgJ2J1c2luZXNzJztcclxufVxyXG5cclxuY2xhc3MgQ29udGVudEdlbmVyYXRvciB7XHJcbiAgcHJpdmF0ZSBjaGF0Z3B0OiBDaGF0R1BUO1xyXG4gIHByaXZhdGUgZGVlcHNlZWs6IERlZXBTZWVrO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY2hhdGdwdCA9IG5ldyBDaGF0R1BUKHsgXHJcbiAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVkhIFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmRlZXBzZWVrID0gbmV3IERlZXBTZWVrKHsgXHJcbiAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuREVFUFNFRUtfQVBJX0tFWSEgXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdlbmVyYXRlQmxvZ1Bvc3QocmVxdWVzdDogQ29udGVudFJlcXVlc3QpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgY29uc3Qgc3lzdGVtUHJvbXB0ID0gXFxgWW91IGFyZSBhbiBleHBlcnQgY29udGVudCB3cml0ZXIuIENyZWF0ZSBlbmdhZ2luZyBcXCR7cmVxdWVzdC5sZW5ndGh9IGJsb2cgcG9zdHMgZm9yIFxcJHtyZXF1ZXN0LmF1ZGllbmNlfSBhdWRpZW5jZXMuXFxgO1xyXG4gICAgXHJcbiAgICBjb25zdCBwcm9tcHQgPSBcXGBXcml0ZSBhIFxcJHtyZXF1ZXN0Lmxlbmd0aH0gYmxvZyBwb3N0IGFib3V0IFwiXFwke3JlcXVlc3QudG9waWN9XCIgdGFyZ2V0aW5nIGEgXFwke3JlcXVlc3QuYXVkaWVuY2V9IGF1ZGllbmNlLiBJbmNsdWRlOlxyXG4gICAgLSBFbmdhZ2luZyBpbnRyb2R1Y3Rpb25cclxuICAgIC0gMy01IG1haW4gcG9pbnRzIHdpdGggZXhhbXBsZXNcclxuICAgIC0gQWN0aW9uYWJsZSBjb25jbHVzaW9uXHJcbiAgICAtIFNFTy1mcmllbmRseSBzdHJ1Y3R1cmVcXGA7XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2hhdGdwdC5jaGF0KHByb21wdCwgc3lzdGVtUHJvbXB0LCAnZ3B0LTQnKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdlbmVyYXRlQ29kZShsYW5ndWFnZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIGNvbnN0IHByb21wdCA9IFxcYEdlbmVyYXRlIFxcJHtsYW5ndWFnZX0gY29kZSBmb3I6IFxcJHtkZXNjcmlwdGlvbn1cXGA7XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5kZWVwc2Vlay5nZW5lcmF0ZUNvZGUocHJvbXB0LCB7XHJcbiAgICAgIG1vZGVsOiAnZGVlcHNlZWstY29kZXItMzNiLWluc3RydWN0JyxcclxuICAgICAgdGVtcGVyYXR1cmU6IDAuMixcclxuICAgICAgbWF4X3Rva2VuczogMjA0OFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmNob2ljZXNbMF0udGV4dDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0cmVhbWluZ0dlbmVyYXRpb24oXHJcbiAgICBwcm9tcHQ6IHN0cmluZywgXHJcbiAgICBvbkNodW5rOiAoY2h1bms6IHN0cmluZykgPT4gdm9pZFxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgYXdhaXQgdGhpcy5jaGF0Z3B0LmNyZWF0ZVN0cmVhbWluZ0NoYXRDb21wbGV0aW9uKFxyXG4gICAgICB7XHJcbiAgICAgICAgbW9kZWw6ICdncHQtNCcsXHJcbiAgICAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogcHJvbXB0IH1dLFxyXG4gICAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXHJcbiAgICAgICAgbWF4X3Rva2VuczogMTUwMFxyXG4gICAgICB9LFxyXG4gICAgICAoZGF0YSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaG9pY2VzPy5bMF0/LmRlbHRhPy5jb250ZW50O1xyXG4gICAgICAgIGlmIChjaHVuaykge1xyXG4gICAgICAgICAgb25DaHVuayhjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICAoZXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoJ1N0cmVhbWluZyBlcnJvcjonLCBlcnJvciksXHJcbiAgICAgICgpID0+IGNvbnNvbGUubG9nKCdTdHJlYW1pbmcgY29tcGxldGUnKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdlbmVyYXRlV2l0aEZ1bmN0aW9ucyh0b3BpYzogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIGNvbnN0IGZ1bmN0aW9ucyA9IFtcclxuICAgICAge1xyXG4gICAgICAgIG5hbWU6ICdyZXNlYXJjaF90b3BpYycsXHJcbiAgICAgICAgZGVzY3JpcHRpb246ICdSZXNlYXJjaCBhIHRvcGljIGZvciBhY2N1cmF0ZSBpbmZvcm1hdGlvbicsXHJcbiAgICAgICAgcGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XHJcbiAgICAgICAgICAgIHRvcGljOiB7IHR5cGU6ICdzdHJpbmcnIH0sXHJcbiAgICAgICAgICAgIGRlcHRoOiB7IHR5cGU6ICdzdHJpbmcnLCBlbnVtOiBbJ2Jhc2ljJywgJ2RldGFpbGVkJywgJ2NvbXByZWhlbnNpdmUnXSB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNoYXRncHQud2l0aEZ1bmN0aW9ucyhcclxuICAgICAgXFxgQ3JlYXRlIGNvbnRlbnQgYWJvdXQgXCJcXCR7dG9waWN9XCIgdXNpbmcgdGhlIHJlc2VhcmNoIGZ1bmN0aW9uLlxcYCxcclxuICAgICAgZnVuY3Rpb25zXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVXNhZ2UgZXhhbXBsZVxyXG5jb25zdCBnZW5lcmF0b3IgPSBuZXcgQ29udGVudEdlbmVyYXRvcigpO1xyXG5cclxuLy8gR2VuZXJhdGUgYmxvZyBwb3N0XHJcbmNvbnN0IGJsb2dQb3N0ID0gYXdhaXQgZ2VuZXJhdG9yLmdlbmVyYXRlQmxvZ1Bvc3Qoe1xyXG4gIHRvcGljOiBcIk1hY2hpbmUgTGVhcm5pbmcgaW4gV2ViIERldmVsb3BtZW50XCIsXHJcbiAgdHlwZTogXCJibG9nXCIsXHJcbiAgbGVuZ3RoOiBcIm1lZGl1bVwiLCBcclxuICBhdWRpZW5jZTogXCJ0ZWNobmljYWxcIlxyXG59KTtcclxuXHJcbi8vIEdlbmVyYXRlIGNvZGVcclxuY29uc3QgcHl0aG9uQ29kZSA9IGF3YWl0IGdlbmVyYXRvci5nZW5lcmF0ZUNvZGUoXHJcbiAgXCJQeXRob25cIixcclxuICBcIkNyZWF0ZSBhIFJFU1QgQVBJIHdpdGggRmFzdEFQSSBmb3IgdXNlciBhdXRoZW50aWNhdGlvblwiXHJcbik7XHJcblxyXG4vLyBTdHJlYW1pbmcgY29udGVudCBnZW5lcmF0aW9uXHJcbmF3YWl0IGdlbmVyYXRvci5zdHJlYW1pbmdHZW5lcmF0aW9uKFxyXG4gIFwiRXhwbGFpbiBxdWFudHVtIGNvbXB1dGluZyBpbiBzaW1wbGUgdGVybXNcIixcclxuICAoY2h1bmspID0+IHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNodW5rKVxyXG4pO2AsXHJcbiAgICBqYXZhc2NyaXB0OiBgY29uc3QgeyBDaGF0R1BULCBEZWVwU2VlayB9ID0gcmVxdWlyZSgnbWFjcm9fYXBpJyk7XHJcblxyXG5jbGFzcyBDb250ZW50R2VuZXJhdG9yIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY2hhdGdwdCA9IG5ldyBDaGF0R1BUKHsgXHJcbiAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVkgXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZGVlcHNlZWsgPSBuZXcgRGVlcFNlZWsoeyBcclxuICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5ERUVQU0VFS19BUElfS0VZIFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZW5lcmF0ZUJsb2dQb3N0KHJlcXVlc3QpIHtcclxuICAgIGNvbnN0IHN5c3RlbVByb21wdCA9IFxcYFlvdSBhcmUgYW4gZXhwZXJ0IGNvbnRlbnQgd3JpdGVyLiBDcmVhdGUgZW5nYWdpbmcgXFwke3JlcXVlc3QubGVuZ3RofSBibG9nIHBvc3RzIGZvciBcXCR7cmVxdWVzdC5hdWRpZW5jZX0gYXVkaWVuY2VzLlxcYDtcclxuICAgIFxyXG4gICAgY29uc3QgcHJvbXB0ID0gXFxgV3JpdGUgYSBcXCR7cmVxdWVzdC5sZW5ndGh9IGJsb2cgcG9zdCBhYm91dCBcIlxcJHtyZXF1ZXN0LnRvcGljfVwiIHRhcmdldGluZyBhIFxcJHtyZXF1ZXN0LmF1ZGllbmNlfSBhdWRpZW5jZS4gSW5jbHVkZTpcclxuICAgIC0gRW5nYWdpbmcgaW50cm9kdWN0aW9uXHJcbiAgICAtIDMtNSBtYWluIHBvaW50cyB3aXRoIGV4YW1wbGVzXHJcbiAgICAtIEFjdGlvbmFibGUgY29uY2x1c2lvblxyXG4gICAgLSBTRU8tZnJpZW5kbHkgc3RydWN0dXJlXFxgO1xyXG5cclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNoYXRncHQuY2hhdChwcm9tcHQsIHN5c3RlbVByb21wdCwgJ2dwdC00Jyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZW5lcmF0ZUNvZGUobGFuZ3VhZ2UsIGRlc2NyaXB0aW9uKSB7XHJcbiAgICBjb25zdCBwcm9tcHQgPSBcXGBHZW5lcmF0ZSBcXCR7bGFuZ3VhZ2V9IGNvZGUgZm9yOiBcXCR7ZGVzY3JpcHRpb259XFxgO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZGVlcHNlZWsuZ2VuZXJhdGVDb2RlKHByb21wdCwge1xyXG4gICAgICBtb2RlbDogJ2RlZXBzZWVrLWNvZGVyLTMzYi1pbnN0cnVjdCcsXHJcbiAgICAgIHRlbXBlcmF0dXJlOiAwLjIsXHJcbiAgICAgIG1heF90b2tlbnM6IDIwNDhcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5jaG9pY2VzWzBdLnRleHQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdHJlYW1pbmdHZW5lcmF0aW9uKHByb21wdCwgb25DaHVuaykge1xyXG4gICAgYXdhaXQgdGhpcy5jaGF0Z3B0LmNyZWF0ZVN0cmVhbWluZ0NoYXRDb21wbGV0aW9uKFxyXG4gICAgICB7XHJcbiAgICAgICAgbW9kZWw6ICdncHQtNCcsXHJcbiAgICAgICAgbWVzc2FnZXM6IFt7IHJvbGU6ICd1c2VyJywgY29udGVudDogcHJvbXB0IH1dLFxyXG4gICAgICAgIHRlbXBlcmF0dXJlOiAwLjcsXHJcbiAgICAgICAgbWF4X3Rva2VuczogMTUwMFxyXG4gICAgICB9LFxyXG4gICAgICAoZGF0YSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNodW5rID0gZGF0YS5jaG9pY2VzPy5bMF0/LmRlbHRhPy5jb250ZW50O1xyXG4gICAgICAgIGlmIChjaHVuaykge1xyXG4gICAgICAgICAgb25DaHVuayhjaHVuayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICAoZXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoJ1N0cmVhbWluZyBlcnJvcjonLCBlcnJvciksXHJcbiAgICAgICgpID0+IGNvbnNvbGUubG9nKCdTdHJlYW1pbmcgY29tcGxldGUnKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFVzYWdlIGV4YW1wbGVcclxuY29uc3QgZ2VuZXJhdG9yID0gbmV3IENvbnRlbnRHZW5lcmF0b3IoKTtcclxuXHJcbi8vIEdlbmVyYXRlIGJsb2cgcG9zdFxyXG5jb25zdCBibG9nUG9zdCA9IGF3YWl0IGdlbmVyYXRvci5nZW5lcmF0ZUJsb2dQb3N0KHtcclxuICB0b3BpYzogXCJNYWNoaW5lIExlYXJuaW5nIGluIFdlYiBEZXZlbG9wbWVudFwiLFxyXG4gIHR5cGU6IFwiYmxvZ1wiLFxyXG4gIGxlbmd0aDogXCJtZWRpdW1cIiwgXHJcbiAgYXVkaWVuY2U6IFwidGVjaG5pY2FsXCJcclxufSk7XHJcblxyXG4vLyBHZW5lcmF0ZSBjb2RlXHJcbmNvbnN0IHB5dGhvbkNvZGUgPSBhd2FpdCBnZW5lcmF0b3IuZ2VuZXJhdGVDb2RlKFxyXG4gIFwiUHl0aG9uXCIsXHJcbiAgXCJDcmVhdGUgYSBSRVNUIEFQSSB3aXRoIEZhc3RBUEkgZm9yIHVzZXIgYXV0aGVudGljYXRpb25cIlxyXG4pO2BcclxuICB9LFxyXG4gIHtcclxuICAgIGlkOiAncGF5bWVudC1wcm9jZXNzaW5nJyxcclxuICAgIHRpdGxlOiAnUGF5bWVudCBQcm9jZXNzaW5nIFN5c3RlbScsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0NvbXBsZXRlIHBheW1lbnQgc3lzdGVtIHdpdGggU3RyaXBlIGFuZCBQYXlQYWwgaW50ZWdyYXRpb24sIHdlYmhvb2sgaGFuZGxpbmcsIGFuZCBzdWJzY3JpcHRpb24gbWFuYWdlbWVudC4nLFxyXG4gICAgY2F0ZWdvcnk6ICdQYXltZW50ICYgQ29tbWVyY2UnLFxyXG4gICAgZGlmZmljdWx0eTogJ2FkdmFuY2VkJyxcclxuICAgIHNlcnZpY2VzOiBbJ1N0cmlwZScsICdQYXlQYWwnLCAnU2VuZEdyaWQnXSxcclxuICAgIGZlYXR1cmVzOiBbJ1dlYmhvb2tzJywgJ1N1YnNjcmlwdGlvbnMnLCAnRW1haWwgTm90aWZpY2F0aW9ucycsICdFcnJvciBIYW5kbGluZyddLFxyXG4gICAgdHlwZXNjcmlwdDogYGltcG9ydCB7IFN0cmlwZUFQSSwgUGF5UGFsQVBJLCBTZW5kR3JpZEFQSSwgUmF0ZUxpbWl0RXJyb3IsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSBmcm9tICdtYWNyb19hcGknO1xyXG5cclxuaW50ZXJmYWNlIFBheW1lbnRSZXF1ZXN0IHtcclxuICBhbW91bnQ6IG51bWJlcjtcclxuICBjdXJyZW5jeTogc3RyaW5nO1xyXG4gIGN1c3RvbWVySWQ6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIHBheW1lbnRNZXRob2Q6ICdzdHJpcGUnIHwgJ3BheXBhbCc7XHJcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU3Vic2NyaXB0aW9uUGxhbiB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHByaWNlOiBudW1iZXI7XHJcbiAgY3VycmVuY3k6IHN0cmluZztcclxuICBpbnRlcnZhbDogJ21vbnRoJyB8ICd5ZWFyJztcclxuICBmZWF0dXJlczogc3RyaW5nW107XHJcbn1cclxuXHJcbmNsYXNzIFBheW1lbnRQcm9jZXNzb3Ige1xyXG4gIHByaXZhdGUgc3RyaXBlOiBTdHJpcGVBUEk7XHJcbiAgcHJpdmF0ZSBwYXlwYWw6IFBheVBhbEFQSTtcclxuICBwcml2YXRlIHNlbmRncmlkOiBTZW5kR3JpZEFQSTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnN0cmlwZSA9IG5ldyBTdHJpcGVBUEkoeyBcclxuICAgICAgc2VjcmV0S2V5OiBwcm9jZXNzLmVudi5TVFJJUEVfU0VDUkVUX0tFWSEgXHJcbiAgICB9KTtcclxuICAgIHRoaXMucGF5cGFsID0gbmV3IFBheVBhbEFQSSh7XHJcbiAgICAgIGNsaWVudElkOiBwcm9jZXNzLmVudi5QQVlQQUxfQ0xJRU5UX0lEISxcclxuICAgICAgY2xpZW50U2VjcmV0OiBwcm9jZXNzLmVudi5QQVlQQUxfQ0xJRU5UX1NFQ1JFVCEsXHJcbiAgICAgIHNhbmRib3g6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXHJcbiAgICB9KTtcclxuICAgIHRoaXMuc2VuZGdyaWQgPSBuZXcgU2VuZEdyaWRBUEkoe1xyXG4gICAgICBhcGlLZXk6IHByb2Nlc3MuZW52LlNFTkRHUklEX0FQSV9LRVkhXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByb2Nlc3NQYXltZW50KHJlcXVlc3Q6IFBheW1lbnRSZXF1ZXN0KTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChyZXF1ZXN0LnBheW1lbnRNZXRob2QgPT09ICdzdHJpcGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvY2Vzc1N0cmlwZVBheW1lbnQocmVxdWVzdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvY2Vzc1BheVBhbFBheW1lbnQocmVxdWVzdCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuaGFuZGxlUGF5bWVudEVycm9yKGVycm9yLCByZXF1ZXN0KTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NTdHJpcGVQYXltZW50KHJlcXVlc3Q6IFBheW1lbnRSZXF1ZXN0KTogUHJvbWlzZTxhbnk+IHtcclxuICAgIC8vIENyZWF0ZSBwYXltZW50IGludGVudFxyXG4gICAgY29uc3QgcGF5bWVudEludGVudCA9IGF3YWl0IHRoaXMuc3RyaXBlLmNyZWF0ZVBheW1lbnRJbnRlbnQoe1xyXG4gICAgICBhbW91bnQ6IHJlcXVlc3QuYW1vdW50ICogMTAwLCAvLyBDb252ZXJ0IHRvIGNlbnRzXHJcbiAgICAgIGN1cnJlbmN5OiByZXF1ZXN0LmN1cnJlbmN5LFxyXG4gICAgICBjdXN0b21lcjogcmVxdWVzdC5jdXN0b21lcklkLFxyXG4gICAgICBkZXNjcmlwdGlvbjogcmVxdWVzdC5kZXNjcmlwdGlvbixcclxuICAgICAgbWV0YWRhdGE6IHJlcXVlc3QubWV0YWRhdGEsXHJcbiAgICAgIGF1dG9tYXRpY19wYXltZW50X21ldGhvZHM6IHtcclxuICAgICAgICBlbmFibGVkOiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNlbmQgY29uZmlybWF0aW9uIGVtYWlsXHJcbiAgICBhd2FpdCB0aGlzLnNlbmRQYXltZW50Q29uZmlybWF0aW9uKHJlcXVlc3QuY3VzdG9tZXJJZCwgcGF5bWVudEludGVudCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcHJvdmlkZXI6ICdzdHJpcGUnLFxyXG4gICAgICBjbGllbnRTZWNyZXQ6IHBheW1lbnRJbnRlbnQuY2xpZW50X3NlY3JldCxcclxuICAgICAgcGF5bWVudEludGVudElkOiBwYXltZW50SW50ZW50LmlkLFxyXG4gICAgICBzdGF0dXM6IHBheW1lbnRJbnRlbnQuc3RhdHVzXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzUGF5UGFsUGF5bWVudChyZXF1ZXN0OiBQYXltZW50UmVxdWVzdCk6IFByb21pc2U8YW55PiB7XHJcbiAgICBjb25zdCBvcmRlciA9IGF3YWl0IHRoaXMucGF5cGFsLmNyZWF0ZU9yZGVyKHtcclxuICAgICAgaW50ZW50OiAnQ0FQVFVSRScsXHJcbiAgICAgIHB1cmNoYXNlX3VuaXRzOiBbe1xyXG4gICAgICAgIGFtb3VudDoge1xyXG4gICAgICAgICAgY3VycmVuY3lfY29kZTogcmVxdWVzdC5jdXJyZW5jeS50b1VwcGVyQ2FzZSgpLFxyXG4gICAgICAgICAgdmFsdWU6IHJlcXVlc3QuYW1vdW50LnRvU3RyaW5nKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiByZXF1ZXN0LmRlc2NyaXB0aW9uLFxyXG4gICAgICAgIGN1c3RvbV9pZDogcmVxdWVzdC5jdXN0b21lcklkXHJcbiAgICAgIH1dLFxyXG4gICAgICBhcHBsaWNhdGlvbl9jb250ZXh0OiB7XHJcbiAgICAgICAgcmV0dXJuX3VybDogXFxgXFwke3Byb2Nlc3MuZW52LkJBU0VfVVJMfS9wYXltZW50L3N1Y2Nlc3NcXGAsXHJcbiAgICAgICAgY2FuY2VsX3VybDogXFxgXFwke3Byb2Nlc3MuZW52LkJBU0VfVVJMfS9wYXltZW50L2NhbmNlbFxcYFxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcm92aWRlcjogJ3BheXBhbCcsXHJcbiAgICAgIG9yZGVySWQ6IG9yZGVyLmlkLFxyXG4gICAgICBhcHByb3ZhbFVybDogb3JkZXIubGlua3M/LmZpbmQobGluayA9PiBsaW5rLnJlbCA9PT0gJ2FwcHJvdmUnKT8uaHJlZlxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGNyZWF0ZVN1YnNjcmlwdGlvbihcclxuICAgIGN1c3RvbWVySWQ6IHN0cmluZywgXHJcbiAgICBwbGFuOiBTdWJzY3JpcHRpb25QbGFuLFxyXG4gICAgcGF5bWVudE1ldGhvZD86IHN0cmluZ1xyXG4gICk6IFByb21pc2U8YW55PiB7XHJcbiAgICAvLyBDcmVhdGUgcHJvZHVjdCBhbmQgcHJpY2VcclxuICAgIGNvbnN0IHByb2R1Y3QgPSBhd2FpdCB0aGlzLnN0cmlwZS5jcmVhdGVQcm9kdWN0KHtcclxuICAgICAgbmFtZTogcGxhbi5uYW1lLFxyXG4gICAgICBkZXNjcmlwdGlvbjogXFxgXFwke3BsYW4ubmFtZX0gc3Vic2NyaXB0aW9uIHBsYW5cXGBcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHByaWNlID0gYXdhaXQgdGhpcy5zdHJpcGUuY3JlYXRlUHJpY2Uoe1xyXG4gICAgICB1bml0X2Ftb3VudDogcGxhbi5wcmljZSAqIDEwMCxcclxuICAgICAgY3VycmVuY3k6IHBsYW4uY3VycmVuY3ksXHJcbiAgICAgIHByb2R1Y3Q6IHByb2R1Y3QuaWQsXHJcbiAgICAgIHJlY3VycmluZzoge1xyXG4gICAgICAgIGludGVydmFsOiBwbGFuLmludGVydmFsXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyZWF0ZSBzdWJzY3JpcHRpb25cclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuc3RyaXBlLmNyZWF0ZVN1YnNjcmlwdGlvbih7XHJcbiAgICAgIGN1c3RvbWVyOiBjdXN0b21lcklkLFxyXG4gICAgICBpdGVtczogW3sgcHJpY2U6IHByaWNlLmlkIH1dLFxyXG4gICAgICBkZWZhdWx0X3BheW1lbnRfbWV0aG9kOiBwYXltZW50TWV0aG9kLFxyXG4gICAgICB0cmlhbF9wZXJpb2RfZGF5czogMTQsIC8vIDE0LWRheSBmcmVlIHRyaWFsXHJcbiAgICAgIG1ldGFkYXRhOiB7XHJcbiAgICAgICAgcGxhbl9uYW1lOiBwbGFuLm5hbWUsXHJcbiAgICAgICAgZmVhdHVyZXM6IEpTT04uc3RyaW5naWZ5KHBsYW4uZmVhdHVyZXMpXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFNlbmQgd2VsY29tZSBlbWFpbFxyXG4gICAgYXdhaXQgdGhpcy5zZW5kU3Vic2NyaXB0aW9uV2VsY29tZShjdXN0b21lcklkLCBwbGFuLCBzdWJzY3JpcHRpb24pO1xyXG5cclxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XHJcbiAgfVxyXG5cclxuICBhc3luYyBoYW5kbGVXZWJob29rKHBheWxvYWQ6IHN0cmluZywgc2lnbmF0dXJlOiBzdHJpbmcsIHByb3ZpZGVyOiAnc3RyaXBlJyB8ICdwYXlwYWwnKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAocHJvdmlkZXIgPT09ICdzdHJpcGUnKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLnN0cmlwZS53ZWJob29rcy5jb25zdHJ1Y3RFdmVudChcclxuICAgICAgICAgIHBheWxvYWQsXHJcbiAgICAgICAgICBzaWduYXR1cmUsXHJcbiAgICAgICAgICBwcm9jZXNzLmVudi5TVFJJUEVfV0VCSE9PS19TRUNSRVQhXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XHJcbiAgICAgICAgICBjYXNlICdwYXltZW50X2ludGVudC5zdWNjZWVkZWQnOlxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVBheW1lbnRTdWNjZXNzKGV2ZW50LmRhdGEub2JqZWN0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdwYXltZW50X2ludGVudC5wYXltZW50X2ZhaWxlZCc6XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlUGF5bWVudEZhaWx1cmUoZXZlbnQuZGF0YS5vYmplY3QpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2N1c3RvbWVyLnN1YnNjcmlwdGlvbi5jcmVhdGVkJzpcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25DcmVhdGVkKGV2ZW50LmRhdGEub2JqZWN0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdjdXN0b21lci5zdWJzY3JpcHRpb24uZGVsZXRlZCc6XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uQ2FuY2VsZWQoZXZlbnQuZGF0YS5vYmplY3QpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dlYmhvb2sgaGFuZGxpbmcgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc2VuZFBheW1lbnRDb25maXJtYXRpb24oY3VzdG9tZXJJZDogc3RyaW5nLCBwYXltZW50SW50ZW50OiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGN1c3RvbWVyID0gYXdhaXQgdGhpcy5zdHJpcGUuZ2V0Q3VzdG9tZXIoY3VzdG9tZXJJZCk7XHJcbiAgICBcclxuICAgIGF3YWl0IHRoaXMuc2VuZGdyaWQuc2VuZEVtYWlsKHtcclxuICAgICAgdG86IGN1c3RvbWVyLmVtYWlsLFxyXG4gICAgICBzdWJqZWN0OiAnUGF5bWVudCBDb25maXJtYXRpb24nLFxyXG4gICAgICB0ZW1wbGF0ZUlkOiAnZC1wYXltZW50LWNvbmZpcm1hdGlvbi10ZW1wbGF0ZScsXHJcbiAgICAgIGR5bmFtaWNUZW1wbGF0ZURhdGE6IHtcclxuICAgICAgICBjdXN0b21lcl9uYW1lOiBjdXN0b21lci5uYW1lLFxyXG4gICAgICAgIGFtb3VudDogKHBheW1lbnRJbnRlbnQuYW1vdW50IC8gMTAwKS50b0ZpeGVkKDIpLFxyXG4gICAgICAgIGN1cnJlbmN5OiBwYXltZW50SW50ZW50LmN1cnJlbmN5LnRvVXBwZXJDYXNlKCksXHJcbiAgICAgICAgcGF5bWVudF9pZDogcGF5bWVudEludGVudC5pZFxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc2VuZFN1YnNjcmlwdGlvbldlbGNvbWUoXHJcbiAgICBjdXN0b21lcklkOiBzdHJpbmcsIFxyXG4gICAgcGxhbjogU3Vic2NyaXB0aW9uUGxhbiwgXHJcbiAgICBzdWJzY3JpcHRpb246IGFueVxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgY3VzdG9tZXIgPSBhd2FpdCB0aGlzLnN0cmlwZS5nZXRDdXN0b21lcihjdXN0b21lcklkKTtcclxuICAgIFxyXG4gICAgYXdhaXQgdGhpcy5zZW5kZ3JpZC5zZW5kRW1haWwoe1xyXG4gICAgICB0bzogY3VzdG9tZXIuZW1haWwsXHJcbiAgICAgIHN1YmplY3Q6IFxcYFdlbGNvbWUgdG8gXFwke3BsYW4ubmFtZX0hXFxgLFxyXG4gICAgICB0ZW1wbGF0ZUlkOiAnZC1zdWJzY3JpcHRpb24td2VsY29tZS10ZW1wbGF0ZScsXHJcbiAgICAgIGR5bmFtaWNUZW1wbGF0ZURhdGE6IHtcclxuICAgICAgICBjdXN0b21lcl9uYW1lOiBjdXN0b21lci5uYW1lLFxyXG4gICAgICAgIHBsYW5fbmFtZTogcGxhbi5uYW1lLFxyXG4gICAgICAgIGZlYXR1cmVzOiBwbGFuLmZlYXR1cmVzLFxyXG4gICAgICAgIHRyaWFsX2VuZDogc3Vic2NyaXB0aW9uLnRyaWFsX2VuZCxcclxuICAgICAgICBtYW5hZ2VfdXJsOiBcXGBcXCR7cHJvY2Vzcy5lbnYuQkFTRV9VUkx9L2FjY291bnQvc3Vic2NyaXB0aW9uXFxgXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVQYXltZW50RXJyb3IoZXJyb3I6IGFueSwgcmVxdWVzdDogUGF5bWVudFJlcXVlc3QpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGxldCBlcnJvclR5cGUgPSAndW5rbm93bic7XHJcbiAgICBcclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJhdGVMaW1pdEVycm9yKSB7XHJcbiAgICAgIGVycm9yVHlwZSA9ICdyYXRlX2xpbWl0JztcclxuICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBdXRoZW50aWNhdGlvbkVycm9yKSB7XHJcbiAgICAgIGVycm9yVHlwZSA9ICdhdXRoZW50aWNhdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc29sZS5lcnJvcignUGF5bWVudCBwcm9jZXNzaW5nIGVycm9yOicsIHtcclxuICAgICAgdHlwZTogZXJyb3JUeXBlLFxyXG4gICAgICByZXF1ZXN0LFxyXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTG9nIHRvIG1vbml0b3Jpbmcgc2VydmljZVxyXG4gICAgLy8gYXdhaXQgdGhpcy5sb2dFcnJvcihlcnJvciwgcmVxdWVzdCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBVc2FnZSBleGFtcGxlXHJcbmNvbnN0IHByb2Nlc3NvciA9IG5ldyBQYXltZW50UHJvY2Vzc29yKCk7XHJcblxyXG4vLyBQcm9jZXNzIG9uZS10aW1lIHBheW1lbnRcclxuY29uc3QgcGF5bWVudCA9IGF3YWl0IHByb2Nlc3Nvci5wcm9jZXNzUGF5bWVudCh7XHJcbiAgYW1vdW50OiAyOS45OSxcclxuICBjdXJyZW5jeTogJ3VzZCcsXHJcbiAgY3VzdG9tZXJJZDogJ2N1c19jdXN0b21lcjEyMycsXHJcbiAgZGVzY3JpcHRpb246ICdQcmVtaXVtIENvdXJzZSBBY2Nlc3MnLFxyXG4gIHBheW1lbnRNZXRob2Q6ICdzdHJpcGUnLFxyXG4gIG1ldGFkYXRhOiB7XHJcbiAgICBjb3Vyc2VfaWQ6ICdjb3Vyc2VfMTIzJyxcclxuICAgIHVzZXJfaWQ6ICd1c2VyXzQ1NidcclxuICB9XHJcbn0pO1xyXG5cclxuLy8gQ3JlYXRlIHN1YnNjcmlwdGlvblxyXG5jb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBwcm9jZXNzb3IuY3JlYXRlU3Vic2NyaXB0aW9uKFxyXG4gICdjdXNfY3VzdG9tZXIxMjMnLFxyXG4gIHtcclxuICAgIG5hbWU6ICdQcm8gUGxhbicsXHJcbiAgICBwcmljZTogMTkuOTksXHJcbiAgICBjdXJyZW5jeTogJ3VzZCcsXHJcbiAgICBpbnRlcnZhbDogJ21vbnRoJyxcclxuICAgIGZlYXR1cmVzOiBbJ1VubGltaXRlZCBBUEkgY2FsbHMnLCAnUHJpb3JpdHkgc3VwcG9ydCcsICdBZHZhbmNlZCBhbmFseXRpY3MnXVxyXG4gIH1cclxuKTtgLFxyXG4gICAgamF2YXNjcmlwdDogYGNvbnN0IHsgU3RyaXBlQVBJLCBQYXlQYWxBUEksIFNlbmRHcmlkQVBJLCBSYXRlTGltaXRFcnJvciwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnbWFjcm9fYXBpJyk7XHJcblxyXG5jbGFzcyBQYXltZW50UHJvY2Vzc29yIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuc3RyaXBlID0gbmV3IFN0cmlwZUFQSSh7IFxyXG4gICAgICBzZWNyZXRLZXk6IHByb2Nlc3MuZW52LlNUUklQRV9TRUNSRVRfS0VZIFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnBheXBhbCA9IG5ldyBQYXlQYWxBUEkoe1xyXG4gICAgICBjbGllbnRJZDogcHJvY2Vzcy5lbnYuUEFZUEFMX0NMSUVOVF9JRCxcclxuICAgICAgY2xpZW50U2VjcmV0OiBwcm9jZXNzLmVudi5QQVlQQUxfQ0xJRU5UX1NFQ1JFVCxcclxuICAgICAgc2FuZGJveDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCdcclxuICAgIH0pO1xyXG4gICAgdGhpcy5zZW5kZ3JpZCA9IG5ldyBTZW5kR3JpZEFQSSh7XHJcbiAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuU0VOREdSSURfQVBJX0tFWVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcm9jZXNzUGF5bWVudChyZXF1ZXN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAocmVxdWVzdC5wYXltZW50TWV0aG9kID09PSAnc3RyaXBlJykge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NTdHJpcGVQYXltZW50KHJlcXVlc3QpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NQYXlQYWxQYXltZW50KHJlcXVlc3QpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZVBheW1lbnRFcnJvcihlcnJvciwgcmVxdWVzdCk7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgcHJvY2Vzc1N0cmlwZVBheW1lbnQocmVxdWVzdCkge1xyXG4gICAgLy8gQ3JlYXRlIHBheW1lbnQgaW50ZW50XHJcbiAgICBjb25zdCBwYXltZW50SW50ZW50ID0gYXdhaXQgdGhpcy5zdHJpcGUuY3JlYXRlUGF5bWVudEludGVudCh7XHJcbiAgICAgIGFtb3VudDogcmVxdWVzdC5hbW91bnQgKiAxMDAsIC8vIENvbnZlcnQgdG8gY2VudHNcclxuICAgICAgY3VycmVuY3k6IHJlcXVlc3QuY3VycmVuY3ksXHJcbiAgICAgIGN1c3RvbWVyOiByZXF1ZXN0LmN1c3RvbWVySWQsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiByZXF1ZXN0LmRlc2NyaXB0aW9uLFxyXG4gICAgICBtZXRhZGF0YTogcmVxdWVzdC5tZXRhZGF0YSxcclxuICAgICAgYXV0b21hdGljX3BheW1lbnRfbWV0aG9kczoge1xyXG4gICAgICAgIGVuYWJsZWQ6IHRydWVcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2VuZCBjb25maXJtYXRpb24gZW1haWxcclxuICAgIGF3YWl0IHRoaXMuc2VuZFBheW1lbnRDb25maXJtYXRpb24ocmVxdWVzdC5jdXN0b21lcklkLCBwYXltZW50SW50ZW50KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcm92aWRlcjogJ3N0cmlwZScsXHJcbiAgICAgIGNsaWVudFNlY3JldDogcGF5bWVudEludGVudC5jbGllbnRfc2VjcmV0LFxyXG4gICAgICBwYXltZW50SW50ZW50SWQ6IHBheW1lbnRJbnRlbnQuaWQsXHJcbiAgICAgIHN0YXR1czogcGF5bWVudEludGVudC5zdGF0dXNcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBVc2FnZSBleGFtcGxlXHJcbmNvbnN0IHByb2Nlc3NvciA9IG5ldyBQYXltZW50UHJvY2Vzc29yKCk7XHJcblxyXG5jb25zdCBwYXltZW50ID0gYXdhaXQgcHJvY2Vzc29yLnByb2Nlc3NQYXltZW50KHtcclxuICBhbW91bnQ6IDI5Ljk5LFxyXG4gIGN1cnJlbmN5OiAndXNkJyxcclxuICBjdXN0b21lcklkOiAnY3VzX2N1c3RvbWVyMTIzJyxcclxuICBkZXNjcmlwdGlvbjogJ1ByZW1pdW0gQ291cnNlIEFjY2VzcycsXHJcbiAgcGF5bWVudE1ldGhvZDogJ3N0cmlwZSdcclxufSk7YFxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdjb21tdW5pY2F0aW9uLWF1dG9tYXRpb24nLFxyXG4gICAgdGl0bGU6ICdDb21tdW5pY2F0aW9uIEF1dG9tYXRpb24nLFxyXG4gICAgZGVzY3JpcHRpb246ICdBdXRvbWF0ZSB0ZWFtIGNvbW11bmljYXRpb24gd2l0aCBTbGFjayBib3RzLCBlbWFpbCBjYW1wYWlnbnMsIGFuZCBpbnRlbGxpZ2VudCBub3RpZmljYXRpb25zLicsXHJcbiAgICBjYXRlZ29yeTogJ0NvbW11bmljYXRpb24gJiBTb2NpYWwnLFxyXG4gICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXHJcbiAgICBzZXJ2aWNlczogWydTbGFjaycsICdTZW5kR3JpZCcsICdDaGF0R1BUJ10sXHJcbiAgICBmZWF0dXJlczogWydTbGFzaCBDb21tYW5kcycsICdFbWFpbCBUZW1wbGF0ZXMnLCAnQUkgSW50ZWdyYXRpb24nXSxcclxuICAgIHR5cGVzY3JpcHQ6IGBpbXBvcnQgeyBTbGFja0FQSSwgU2VuZEdyaWRBUEksIENoYXRHUFQgfSBmcm9tICdtYWNyb19hcGknO1xyXG5cclxuaW50ZXJmYWNlIE5vdGlmaWNhdGlvbkNvbmZpZyB7XHJcbiAgY2hhbm5lbHM6IHN0cmluZ1tdO1xyXG4gIGVtYWlsTGlzdHM6IHN0cmluZ1tdO1xyXG4gIHVyZ2VuY3k6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCc7XHJcbiAgaW5jbHVkZUFJU3VtbWFyeTogYm9vbGVhbjtcclxufVxyXG5cclxuY2xhc3MgQ29tbXVuaWNhdGlvbkh1YiB7XHJcbiAgcHJpdmF0ZSBzbGFjazogU2xhY2tBUEk7XHJcbiAgcHJpdmF0ZSBzZW5kZ3JpZDogU2VuZEdyaWRBUEk7XHJcbiAgcHJpdmF0ZSBjaGF0Z3B0OiBDaGF0R1BUO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuc2xhY2sgPSBuZXcgU2xhY2tBUEkoeyBcclxuICAgICAgYm90VG9rZW46IHByb2Nlc3MuZW52LlNMQUNLX0JPVF9UT0tFTiEgXHJcbiAgICB9KTtcclxuICAgIHRoaXMuc2VuZGdyaWQgPSBuZXcgU2VuZEdyaWRBUEkoe1xyXG4gICAgICBhcGlLZXk6IHByb2Nlc3MuZW52LlNFTkRHUklEX0FQSV9LRVkhXHJcbiAgICB9KTtcclxuICAgIHRoaXMuY2hhdGdwdCA9IG5ldyBDaGF0R1BUKHtcclxuICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSFcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY3JlYXRlU2xhY2tCb3QoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBTZXQgdXAgc2xhc2ggY29tbWFuZCBoYW5kbGVyc1xyXG4gICAgYXdhaXQgdGhpcy5zZXR1cFNsYXNoQ29tbWFuZHMoKTtcclxuICAgIFxyXG4gICAgLy8gTW9uaXRvciBjaGFubmVscyBmb3Iga2V5d29yZHNcclxuICAgIGF3YWl0IHRoaXMuc2V0dXBLZXl3b3JkTW9uaXRvcmluZygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzZXR1cFNsYXNoQ29tbWFuZHMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBFeGFtcGxlOiAvZGVwbG95IGNvbW1hbmRcclxuICAgIGNvbnN0IGRlcGxveUNvbW1hbmQgPSBhc3luYyAocGF5bG9hZDogYW55KSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgdGV4dCwgdXNlcl9pZCwgY2hhbm5lbF9pZCB9ID0gcGF5bG9hZDtcclxuICAgICAgXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gU2VuZCBpbW1lZGlhdGUgcmVzcG9uc2VcclxuICAgICAgICBhd2FpdCB0aGlzLnNsYWNrLnNlbmRNZXNzYWdlKGNoYW5uZWxfaWQsIFxyXG4gICAgICAgICAgXFxg8J+agCBTdGFydGluZyBkZXBsb3ltZW50IG9mIFxcJHt0ZXh0fS4uLlxcYCwgXHJcbiAgICAgICAgICB7IHRocmVhZF90czogcGF5bG9hZC50cyB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gU2ltdWxhdGUgZGVwbG95bWVudCBwcm9jZXNzXHJcbiAgICAgICAgYXdhaXQgdGhpcy5zaW11bGF0ZURlcGxveW1lbnQodGV4dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2VuZCBzdWNjZXNzIG1lc3NhZ2VcclxuICAgICAgICBhd2FpdCB0aGlzLnNsYWNrLnNlbmRNZXNzYWdlKGNoYW5uZWxfaWQsXHJcbiAgICAgICAgICBcXGDinIUgRGVwbG95bWVudCBvZiBcXCR7dGV4dH0gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSFcXGAsXHJcbiAgICAgICAgICB7IFxyXG4gICAgICAgICAgICB0aHJlYWRfdHM6IHBheWxvYWQudHMsXHJcbiAgICAgICAgICAgIGJsb2NrczogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzZWN0aW9uJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgdHlwZTogJ21ya2R3bicsXHJcbiAgICAgICAgICAgICAgICAgIHRleHQ6IFxcYCpEZXBsb3ltZW50IFN1bW1hcnkqXFxcXG7igKIgU2VydmljZTogXFwke3RleHR9XFxcXG7igKIgU3RhdHVzOiDinIUgU3VjY2Vzc1xcXFxu4oCiIER1cmF0aW9uOiAybSAzNHNcXGBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdhY3Rpb25zJyxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnV0dG9uJyxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB7IHR5cGU6ICdwbGFpbl90ZXh0JywgdGV4dDogJ1ZpZXcgTG9ncycgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cmw6IFxcYGh0dHBzOi8vZGFzaGJvYXJkLmV4YW1wbGUuY29tL2RlcGxveW1lbnRzL1xcJHt0ZXh0fVxcYFxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnNsYWNrLnNlbmRNZXNzYWdlKGNoYW5uZWxfaWQsXHJcbiAgICAgICAgICBcXGDinYwgRGVwbG95bWVudCBmYWlsZWQ6IFxcJHtlcnJvci5tZXNzYWdlfVxcYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgY29tbWFuZCBoYW5kbGVyXHJcbiAgICAvLyBOb3RlOiBJbiBhIHJlYWwgYXBwbGljYXRpb24sIHlvdSdkIHNldCB1cCBhIHdlYiBzZXJ2ZXIgdG8gaGFuZGxlIHdlYmhvb2tzXHJcbiAgICBjb25zb2xlLmxvZygnU2xhc2ggY29tbWFuZCBoYW5kbGVycyByZWdpc3RlcmVkJyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZW5kSW50ZWxsaWdlbnROb3RpZmljYXRpb24oXHJcbiAgICB0aXRsZTogc3RyaW5nLFxyXG4gICAgY29udGVudDogc3RyaW5nLFxyXG4gICAgY29uZmlnOiBOb3RpZmljYXRpb25Db25maWdcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGxldCBwcm9jZXNzZWRDb250ZW50ID0gY29udGVudDtcclxuICAgIFxyXG4gICAgLy8gR2VuZXJhdGUgQUkgc3VtbWFyeSBpZiByZXF1ZXN0ZWRcclxuICAgIGlmIChjb25maWcuaW5jbHVkZUFJU3VtbWFyeSkge1xyXG4gICAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgdGhpcy5jaGF0Z3B0LmNoYXQoXHJcbiAgICAgICAgXFxgU3VtbWFyaXplIHRoaXMgbm90aWZpY2F0aW9uIGluIDItMyBidWxsZXQgcG9pbnRzOlxcXFxuXFxcXG5cXCR7Y29udGVudH1cXGAsXHJcbiAgICAgICAgJ1lvdSBhcmUgYSBjb25jaXNlIGNvbW11bmljYXRpb24gYXNzaXN0YW50LidcclxuICAgICAgKTtcclxuICAgICAgcHJvY2Vzc2VkQ29udGVudCA9IFxcYPCfk4sgKipBSSBTdW1tYXJ5OioqXFxcXG5cXCR7c3VtbWFyeX1cXFxcblxcXFxu8J+ThCAqKkZ1bGwgRGV0YWlsczoqKlxcXFxuXFwke2NvbnRlbnR9XFxgO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlbmQgdG8gU2xhY2sgY2hhbm5lbHNcclxuICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiBjb25maWcuY2hhbm5lbHMpIHtcclxuICAgICAgYXdhaXQgdGhpcy5zZW5kU2xhY2tOb3RpZmljYXRpb24oY2hhbm5lbCwgdGl0bGUsIHByb2Nlc3NlZENvbnRlbnQsIGNvbmZpZy51cmdlbmN5KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZW5kIGVtYWlsIG5vdGlmaWNhdGlvbnNcclxuICAgIGlmIChjb25maWcuZW1haWxMaXN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2VuZEVtYWlsTm90aWZpY2F0aW9uKHRpdGxlLCBwcm9jZXNzZWRDb250ZW50LCBjb25maWcpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzZW5kU2xhY2tOb3RpZmljYXRpb24oXHJcbiAgICBjaGFubmVsOiBzdHJpbmcsIFxyXG4gICAgdGl0bGU6IHN0cmluZywgXHJcbiAgICBjb250ZW50OiBzdHJpbmcsIFxyXG4gICAgdXJnZW5jeTogc3RyaW5nXHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB1cmdlbmN5RW1vamkgPSB7XHJcbiAgICAgIGxvdzogJ/Cfkq0nLFxyXG4gICAgICBtZWRpdW06ICfimqDvuI8nLFxyXG4gICAgICBoaWdoOiAn8J+aqCdcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdXJnZW5jeUNvbG9yID0ge1xyXG4gICAgICBsb3c6ICcjMzZhNjRmJyxcclxuICAgICAgbWVkaXVtOiAnI2ZmOTUwMCcsIFxyXG4gICAgICBoaWdoOiAnI2ZmMDAwMCdcclxuICAgIH07XHJcblxyXG4gICAgYXdhaXQgdGhpcy5zbGFjay5zZW5kTWVzc2FnZShjaGFubmVsLCAnJywge1xyXG4gICAgICBibG9ja3M6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcclxuICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgdHlwZTogJ3BsYWluX3RleHQnLFxyXG4gICAgICAgICAgICB0ZXh0OiBcXGBcXCR7dXJnZW5jeUVtb2ppW3VyZ2VuY3ldfSBcXCR7dGl0bGV9XFxgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0eXBlOiAnc2VjdGlvbicsXHJcbiAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdtcmtkd24nLFxyXG4gICAgICAgICAgICB0ZXh0OiBjb250ZW50XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0eXBlOiAnY29udGV4dCcsXHJcbiAgICAgICAgICBlbGVtZW50czogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ21ya2R3bicsXHJcbiAgICAgICAgICAgICAgdGV4dDogXFxgVXJnZW5jeTogKlxcJHt1cmdlbmN5LnRvVXBwZXJDYXNlKCl9KiB8IFxcJHtuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKCl9XFxgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF1cclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzZW5kRW1haWxOb3RpZmljYXRpb24oXHJcbiAgICB0aXRsZTogc3RyaW5nLFxyXG4gICAgY29udGVudDogc3RyaW5nLFxyXG4gICAgY29uZmlnOiBOb3RpZmljYXRpb25Db25maWdcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGVtYWlsQ29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXFxcXCovZywgJycpOyAvLyBSZW1vdmUgbWFya2Rvd25cclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBsaXN0SWQgb2YgY29uZmlnLmVtYWlsTGlzdHMpIHtcclxuICAgICAgYXdhaXQgdGhpcy5zZW5kZ3JpZC5zZW5kRW1haWwoe1xyXG4gICAgICAgIHRvOiBcXGBsaXN0LVxcJHtsaXN0SWR9QGNvbXBhbnkuY29tXFxgLFxyXG4gICAgICAgIHN1YmplY3Q6IHRpdGxlLFxyXG4gICAgICAgIGh0bWw6IFxcYFxyXG4gICAgICAgICAgPGRpdiBzdHlsZT1cImZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZjsgbWF4LXdpZHRoOiA2MDBweDtcIj5cclxuICAgICAgICAgICAgPGgyIHN0eWxlPVwiY29sb3I6ICMzMzM7XCI+XFwke3RpdGxlfTwvaDI+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kOiAjZjhmOWZhOyBwYWRkaW5nOiAyMHB4OyBib3JkZXItcmFkaXVzOiA4cHg7XCI+XHJcbiAgICAgICAgICAgICAgXFwke2VtYWlsQ29udGVudC5yZXBsYWNlKC9cXFxcbi9nLCAnPGJyPicpfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPHAgc3R5bGU9XCJjb2xvcjogIzY2NjsgZm9udC1zaXplOiAxMnB4OyBtYXJnaW4tdG9wOiAyMHB4O1wiPlxyXG4gICAgICAgICAgICAgIFNlbnQgdmlhIG1hY3JvX2FwaSBDb21tdW5pY2F0aW9uIEh1YlxyXG4gICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICBcXGBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBjcmVhdGVTY2hlZHVsZWRDYW1wYWlnbihcclxuICAgIHN1YmplY3Q6IHN0cmluZyxcclxuICAgIHRlbXBsYXRlSWQ6IHN0cmluZyxcclxuICAgIGF1ZGllbmNlSWQ6IHN0cmluZyxcclxuICAgIHNjaGVkdWxlVGltZTogRGF0ZSxcclxuICAgIHBlcnNvbmFsaXphdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT5bXVxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gQ3JlYXRlIGVtYWlsIHRlbXBsYXRlIHdpdGggZHluYW1pYyBjb250ZW50XHJcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IHRoaXMuc2VuZGdyaWQuY3JlYXRlVGVtcGxhdGUoXHJcbiAgICAgIFxcYENhbXBhaWduOiBcXCR7c3ViamVjdH1cXGAsXHJcbiAgICAgICdkeW5hbWljJ1xyXG4gICAgKTtcclxuXHJcbiAgICAvLyBTY2hlZHVsZSB0aGUgY2FtcGFpZ25cclxuICAgIGNvbnN0IHNjaGVkdWxlZEVtYWlsID0gYXdhaXQgdGhpcy5zZW5kZ3JpZC5zY2hlZHVsZUVtYWlsKHtcclxuICAgICAgdG86IHBlcnNvbmFsaXphdGlvbnMubWFwKHAgPT4gcC5lbWFpbCksXHJcbiAgICAgIHN1YmplY3QsXHJcbiAgICAgIHRlbXBsYXRlSWQsXHJcbiAgICAgIGR5bmFtaWNUZW1wbGF0ZURhdGE6IHBlcnNvbmFsaXphdGlvbnNcclxuICAgIH0sIHNjaGVkdWxlVGltZSk7XHJcblxyXG4gICAgLy8gTm90aWZ5IHRlYW0gYWJvdXQgc2NoZWR1bGVkIGNhbXBhaWduXHJcbiAgICBhd2FpdCB0aGlzLnNsYWNrLnNlbmRNZXNzYWdlKCcjbWFya2V0aW5nJyxcclxuICAgICAgXFxg8J+TpyBFbWFpbCBjYW1wYWlnbiBcIlxcJHtzdWJqZWN0fVwiIHNjaGVkdWxlZCBmb3IgXFwke3NjaGVkdWxlVGltZS50b0xvY2FsZVN0cmluZygpfVxcYCxcclxuICAgICAge1xyXG4gICAgICAgIGJsb2NrczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiAnc2VjdGlvbicsXHJcbiAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnbXJrZHduJyxcclxuICAgICAgICAgICAgICB0ZXh0OiBcXGAqQ2FtcGFpZ24gRGV0YWlscypcXFxcbuKAoiBTdWJqZWN0OiBcXCR7c3ViamVjdH1cXFxcbuKAoiBSZWNpcGllbnRzOiBcXCR7cGVyc29uYWxpemF0aW9ucy5sZW5ndGh9XFxcXG7igKIgU2VuZCBUaW1lOiBcXCR7c2NoZWR1bGVUaW1lLnRvTG9jYWxlU3RyaW5nKCl9XFxgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHNpbXVsYXRlRGVwbG95bWVudChzZXJ2aWNlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIFNpbXVsYXRlIGRlcGxveW1lbnQgdGltZVxyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHNldHVwQWxlcnRTeXN0ZW0oKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBNb25pdG9yIHN5c3RlbSBoZWFsdGggYW5kIHNlbmQgYWxlcnRzXHJcbiAgICBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN5c3RlbUhlYWx0aCA9IGF3YWl0IHRoaXMuY2hlY2tTeXN0ZW1IZWFsdGgoKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChzeXN0ZW1IZWFsdGguc3RhdHVzID09PSAnY3JpdGljYWwnKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kSW50ZWxsaWdlbnROb3RpZmljYXRpb24oXHJcbiAgICAgICAgICAn8J+aqCBDcml0aWNhbCBTeXN0ZW0gQWxlcnQnLFxyXG4gICAgICAgICAgXFxgU3lzdGVtIGhlYWx0aCBjaGVjayBmYWlsZWQ6XFxcXG7igKIgQ1BVOiBcXCR7c3lzdGVtSGVhbHRoLmNwdX0lXFxcXG7igKIgTWVtb3J5OiBcXCR7c3lzdGVtSGVhbHRoLm1lbW9yeX0lXFxcXG7igKIgRGlzazogXFwke3N5c3RlbUhlYWx0aC5kaXNrfSVcXGAsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGNoYW5uZWxzOiBbJyNhbGVydHMnLCAnI2VuZ2luZWVyaW5nJ10sXHJcbiAgICAgICAgICAgIGVtYWlsTGlzdHM6IFsnb24tY2FsbCddLFxyXG4gICAgICAgICAgICB1cmdlbmN5OiAnaGlnaCcsXHJcbiAgICAgICAgICAgIGluY2x1ZGVBSVN1bW1hcnk6IGZhbHNlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSwgMzAwMDAwKTsgLy8gQ2hlY2sgZXZlcnkgNSBtaW51dGVzXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGNoZWNrU3lzdGVtSGVhbHRoKCk6IFByb21pc2U8YW55PiB7XHJcbiAgICAvLyBNb2NrIHN5c3RlbSBoZWFsdGggY2hlY2tcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXR1czogTWF0aC5yYW5kb20oKSA+IDAuOTUgPyAnY3JpdGljYWwnIDogJ2hlYWx0aHknLFxyXG4gICAgICBjcHU6IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMCksXHJcbiAgICAgIG1lbW9yeTogTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwKSxcclxuICAgICAgZGlzazogTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwKVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFVzYWdlIGV4YW1wbGVcclxuY29uc3QgY29tbXNIdWIgPSBuZXcgQ29tbXVuaWNhdGlvbkh1YigpO1xyXG5cclxuLy8gU2V0IHVwIHRoZSBjb21tdW5pY2F0aW9uIHN5c3RlbVxyXG5hd2FpdCBjb21tc0h1Yi5jcmVhdGVTbGFja0JvdCgpO1xyXG5hd2FpdCBjb21tc0h1Yi5zZXR1cEFsZXJ0U3lzdGVtKCk7XHJcblxyXG4vLyBTZW5kIGludGVsbGlnZW50IG5vdGlmaWNhdGlvblxyXG5hd2FpdCBjb21tc0h1Yi5zZW5kSW50ZWxsaWdlbnROb3RpZmljYXRpb24oXHJcbiAgJ1dlZWtseSBQcm9kdWN0IFVwZGF0ZScsXHJcbiAgXFxgVGhpcyB3ZWVrIHdlIGxhdW5jaGVkIDMgbmV3IGZlYXR1cmVzLCBmaXhlZCAxMiBidWdzLCBhbmQgaW1wcm92ZWQgcGVyZm9ybWFuY2UgYnkgMjUlLiBVc2VyIGVuZ2FnZW1lbnQgaXMgdXAgMTUlIGNvbXBhcmVkIHRvIGxhc3Qgd2Vlay5cXGAsXHJcbiAge1xyXG4gICAgY2hhbm5lbHM6IFsnI2dlbmVyYWwnLCAnI3Byb2R1Y3QtdXBkYXRlcyddLFxyXG4gICAgZW1haWxMaXN0czogWydhbGwtaGFuZHMnLCAnc3Rha2Vob2xkZXJzJ10sXHJcbiAgICB1cmdlbmN5OiAnbWVkaXVtJyxcclxuICAgIGluY2x1ZGVBSVN1bW1hcnk6IHRydWVcclxuICB9XHJcbik7XHJcblxyXG4vLyBTY2hlZHVsZSBlbWFpbCBjYW1wYWlnblxyXG5hd2FpdCBjb21tc0h1Yi5jcmVhdGVTY2hlZHVsZWRDYW1wYWlnbihcclxuICAnTmV3IEZlYXR1cmUgQW5ub3VuY2VtZW50JyxcclxuICAnZC1mZWF0dXJlLWFubm91bmNlbWVudCcsXHJcbiAgJ2FsbC11c2VycycsXHJcbiAgbmV3IERhdGUoRGF0ZS5ub3coKSArIDI0ICogNjAgKiA2MCAqIDEwMDApLCAvLyBUb21vcnJvd1xyXG4gIFtcclxuICAgIHsgZW1haWw6ICd1c2VyMUBleGFtcGxlLmNvbScsIG5hbWU6ICdKb2huJywgZmVhdHVyZTogJ1NtYXJ0IEFuYWx5dGljcycgfSxcclxuICAgIHsgZW1haWw6ICd1c2VyMkBleGFtcGxlLmNvbScsIG5hbWU6ICdKYW5lJywgZmVhdHVyZTogJ0FkdmFuY2VkIFNlYXJjaCcgfVxyXG4gIF1cclxuKTtgLFxyXG4gICAgamF2YXNjcmlwdDogYGNvbnN0IHsgU2xhY2tBUEksIFNlbmRHcmlkQVBJLCBDaGF0R1BUIH0gPSByZXF1aXJlKCdtYWNyb19hcGknKTtcclxuXHJcbmNsYXNzIENvbW11bmljYXRpb25IdWIge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5zbGFjayA9IG5ldyBTbGFja0FQSSh7IFxyXG4gICAgICBib3RUb2tlbjogcHJvY2Vzcy5lbnYuU0xBQ0tfQk9UX1RPS0VOIFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNlbmRncmlkID0gbmV3IFNlbmRHcmlkQVBJKHtcclxuICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5TRU5ER1JJRF9BUElfS0VZXHJcbiAgICB9KTtcclxuICAgIHRoaXMuY2hhdGdwdCA9IG5ldyBDaGF0R1BUKHtcclxuICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZW5kSW50ZWxsaWdlbnROb3RpZmljYXRpb24odGl0bGUsIGNvbnRlbnQsIGNvbmZpZykge1xyXG4gICAgbGV0IHByb2Nlc3NlZENvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgXHJcbiAgICAvLyBHZW5lcmF0ZSBBSSBzdW1tYXJ5IGlmIHJlcXVlc3RlZFxyXG4gICAgaWYgKGNvbmZpZy5pbmNsdWRlQUlTdW1tYXJ5KSB7XHJcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSBhd2FpdCB0aGlzLmNoYXRncHQuY2hhdChcclxuICAgICAgICBcXGBTdW1tYXJpemUgdGhpcyBub3RpZmljYXRpb24gaW4gMi0zIGJ1bGxldCBwb2ludHM6XFxcXG5cXFxcblxcJHtjb250ZW50fVxcYCxcclxuICAgICAgICAnWW91IGFyZSBhIGNvbmNpc2UgY29tbXVuaWNhdGlvbiBhc3Npc3RhbnQuJ1xyXG4gICAgICApO1xyXG4gICAgICBwcm9jZXNzZWRDb250ZW50ID0gXFxg8J+TiyAqKkFJIFN1bW1hcnk6KipcXFxcblxcJHtzdW1tYXJ5fVxcXFxuXFxcXG7wn5OEICoqRnVsbCBEZXRhaWxzOioqXFxcXG5cXCR7Y29udGVudH1cXGA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2VuZCB0byBTbGFjayBjaGFubmVsc1xyXG4gICAgZm9yIChjb25zdCBjaGFubmVsIG9mIGNvbmZpZy5jaGFubmVscykge1xyXG4gICAgICBhd2FpdCB0aGlzLnNlbmRTbGFja05vdGlmaWNhdGlvbihjaGFubmVsLCB0aXRsZSwgcHJvY2Vzc2VkQ29udGVudCwgY29uZmlnLnVyZ2VuY3kpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlbmQgZW1haWwgbm90aWZpY2F0aW9uc1xyXG4gICAgaWYgKGNvbmZpZy5lbWFpbExpc3RzLmxlbmd0aCA+IDApIHtcclxuICAgICAgYXdhaXQgdGhpcy5zZW5kRW1haWxOb3RpZmljYXRpb24odGl0bGUsIHByb2Nlc3NlZENvbnRlbnQsIGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzZW5kU2xhY2tOb3RpZmljYXRpb24oY2hhbm5lbCwgdGl0bGUsIGNvbnRlbnQsIHVyZ2VuY3kpIHtcclxuICAgIGNvbnN0IHVyZ2VuY3lFbW9qaSA9IHtcclxuICAgICAgbG93OiAn8J+SrScsXHJcbiAgICAgIG1lZGl1bTogJ+KaoO+4jycsXHJcbiAgICAgIGhpZ2g6ICfwn5qoJ1xyXG4gICAgfTtcclxuXHJcbiAgICBhd2FpdCB0aGlzLnNsYWNrLnNlbmRNZXNzYWdlKGNoYW5uZWwsICcnLCB7XHJcbiAgICAgIGJsb2NrczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxyXG4gICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICB0eXBlOiAncGxhaW5fdGV4dCcsXHJcbiAgICAgICAgICAgIHRleHQ6IFxcYFxcJHt1cmdlbmN5RW1vamlbdXJnZW5jeV19IFxcJHt0aXRsZX1cXGBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHR5cGU6ICdzZWN0aW9uJyxcclxuICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgdHlwZTogJ21ya2R3bicsXHJcbiAgICAgICAgICAgIHRleHQ6IGNvbnRlbnRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVXNhZ2VcclxuY29uc3QgY29tbXNIdWIgPSBuZXcgQ29tbXVuaWNhdGlvbkh1YigpO1xyXG5cclxuYXdhaXQgY29tbXNIdWIuc2VuZEludGVsbGlnZW50Tm90aWZpY2F0aW9uKFxyXG4gICdXZWVrbHkgUHJvZHVjdCBVcGRhdGUnLFxyXG4gICdUaGlzIHdlZWsgd2UgbGF1bmNoZWQgMyBuZXcgZmVhdHVyZXMgYW5kIGltcHJvdmVkIHBlcmZvcm1hbmNlIGJ5IDI1JS4nLFxyXG4gIHtcclxuICAgIGNoYW5uZWxzOiBbJyNnZW5lcmFsJywgJyNwcm9kdWN0LXVwZGF0ZXMnXSxcclxuICAgIGVtYWlsTGlzdHM6IFsnYWxsLWhhbmRzJ10sXHJcbiAgICB1cmdlbmN5OiAnbWVkaXVtJyxcclxuICAgIGluY2x1ZGVBSVN1bW1hcnk6IHRydWVcclxuICB9XHJcbik7YFxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdjbG91ZC1kZXBsb3ltZW50JyxcclxuICAgIHRpdGxlOiAnQ2xvdWQgRGVwbG95bWVudCBQaXBlbGluZScsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0F1dG9tYXRlZCBkZXBsb3ltZW50IHBpcGVsaW5lIHVzaW5nIFZlcmNlbCwgRG9ja2VyIEh1YiwgYW5kIEFXUyBTMyB3aXRoIGNvbXByZWhlbnNpdmUgbW9uaXRvcmluZy4nLFxyXG4gICAgY2F0ZWdvcnk6ICdEZXZlbG9wbWVudCAmIENsb3VkJyxcclxuICAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCcsXHJcbiAgICBzZXJ2aWNlczogWydWZXJjZWwnLCAnRG9ja2VySHViJywgJ1MzJywgJ0dpdEh1YicsICdTbGFjayddLFxyXG4gICAgZmVhdHVyZXM6IFsnQ0kvQ0QnLCAnQ29udGFpbmVyIFJlZ2lzdHJ5JywgJ0ZpbGUgU3RvcmFnZScsICdXZWJob29rcyddLFxyXG4gICAgdHlwZXNjcmlwdDogYGltcG9ydCB7IFZlcmNlbEFQSSwgRG9ja2VySHViQVBJLCBTM0FQSSwgR2l0SHViQVBJLCBTbGFja0FQSSB9IGZyb20gJ21hY3JvX2FwaSc7XHJcbmltcG9ydCB7IGNyZWF0ZVJlYWRTdHJlYW0gfSBmcm9tICdmcyc7XHJcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdwYXRoJztcclxuXHJcbmludGVyZmFjZSBEZXBsb3ltZW50Q29uZmlnIHtcclxuICBwcm9qZWN0TmFtZTogc3RyaW5nO1xyXG4gIGVudmlyb25tZW50OiAnc3RhZ2luZycgfCAncHJvZHVjdGlvbic7XHJcbiAgZ2l0QnJhbmNoOiBzdHJpbmc7XHJcbiAgZG9ja2VySW1hZ2U/OiBzdHJpbmc7XHJcbiAgZW52VmFyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcclxuICBkb21haW5zPzogc3RyaW5nW107XHJcbn1cclxuXHJcbmludGVyZmFjZSBCdWlsZEFydGlmYWN0IHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgcGF0aDogc3RyaW5nO1xyXG4gIHR5cGU6ICdidWlsZCcgfCAnYXNzZXQnIHwgJ2NvbmZpZyc7XHJcbn1cclxuXHJcbmNsYXNzIENsb3VkRGVwbG95bWVudFBpcGVsaW5lIHtcclxuICBwcml2YXRlIHZlcmNlbDogVmVyY2VsQVBJO1xyXG4gIHByaXZhdGUgZG9ja2VyaHViOiBEb2NrZXJIdWJBUEk7XHJcbiAgcHJpdmF0ZSBzMzogUzNBUEk7XHJcbiAgcHJpdmF0ZSBnaXRodWI6IEdpdEh1YkFQSTtcclxuICBwcml2YXRlIHNsYWNrOiBTbGFja0FQSTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnZlcmNlbCA9IG5ldyBWZXJjZWxBUEkoe1xyXG4gICAgICBhY2Nlc3NUb2tlbjogcHJvY2Vzcy5lbnYuVkVSQ0VMX1RPS0VOIVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmRvY2tlcmh1YiA9IG5ldyBEb2NrZXJIdWJBUEkoe1xyXG4gICAgICB0b2tlbjogcHJvY2Vzcy5lbnYuRE9DS0VSX1RPS0VOIVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnMzID0gbmV3IFMzQVBJKHtcclxuICAgICAgYWNjZXNzS2V5SWQ6IHByb2Nlc3MuZW52LkFXU19BQ0NFU1NfS0VZX0lEISxcclxuICAgICAgc2VjcmV0QWNjZXNzS2V5OiBwcm9jZXNzLmVudi5BV1NfU0VDUkVUX0FDQ0VTU19LRVkhLFxyXG4gICAgICByZWdpb246IHByb2Nlc3MuZW52LkFXU19SRUdJT04hLFxyXG4gICAgICBidWNrZXROYW1lOiBwcm9jZXNzLmVudi5TM19CVUNLRVQhXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZ2l0aHViID0gbmV3IEdpdEh1YkFQSSh7XHJcbiAgICAgIHRva2VuOiBwcm9jZXNzLmVudi5HSVRIVUJfVE9LRU4hXHJcbiAgICB9KTtcclxuICAgIHRoaXMuc2xhY2sgPSBuZXcgU2xhY2tBUEkoe1xyXG4gICAgICBib3RUb2tlbjogcHJvY2Vzcy5lbnYuU0xBQ0tfQk9UX1RPS0VOIVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZXBsb3lBcHBsaWNhdGlvbihjb25maWc6IERlcGxveW1lbnRDb25maWcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgY29uc3QgZGVwbG95bWVudElkID0gXFxgZGVwbG95LVxcJHtEYXRlLm5vdygpfVxcYDtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gTm90aWZ5IHN0YXJ0IG9mIGRlcGxveW1lbnRcclxuICAgICAgYXdhaXQgdGhpcy5ub3RpZnlEZXBsb3ltZW50U3RhcnQoY29uZmlnLCBkZXBsb3ltZW50SWQpO1xyXG4gICAgICBcclxuICAgICAgLy8gU3RlcCAxOiBCdWlsZCBhbmQgcHVzaCBEb2NrZXIgaW1hZ2UgaWYgc3BlY2lmaWVkXHJcbiAgICAgIGlmIChjb25maWcuZG9ja2VySW1hZ2UpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmJ1aWxkQW5kUHVzaEltYWdlKGNvbmZpZyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFN0ZXAgMjogVXBsb2FkIGJ1aWxkIGFydGlmYWN0cyB0byBTM1xyXG4gICAgICBjb25zdCBhcnRpZmFjdHMgPSBhd2FpdCB0aGlzLnVwbG9hZEJ1aWxkQXJ0aWZhY3RzKGNvbmZpZywgZGVwbG95bWVudElkKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0ZXAgMzogRGVwbG95IHRvIFZlcmNlbFxyXG4gICAgICBjb25zdCBkZXBsb3ltZW50ID0gYXdhaXQgdGhpcy5kZXBsb3lUb1ZlcmNlbChjb25maWcsIGFydGlmYWN0cyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdGVwIDQ6IENvbmZpZ3VyZSBkb21haW5zXHJcbiAgICAgIGlmIChjb25maWcuZG9tYWlucykge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuY29uZmlndXJlRG9tYWlucyhkZXBsb3ltZW50LnByb2plY3RJZCwgY29uZmlnLmRvbWFpbnMpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdGVwIDU6IFdhaXQgZm9yIGRlcGxveW1lbnQgdG8gY29tcGxldGVcclxuICAgICAgY29uc3QgZmluYWxEZXBsb3ltZW50ID0gYXdhaXQgdGhpcy52ZXJjZWwud2FpdEZvckRlcGxveW1lbnQoXHJcbiAgICAgICAgZGVwbG95bWVudC51aWQsIFxyXG4gICAgICAgIDYwMDAwMCAvLyAxMCBtaW51dGVzIHRpbWVvdXRcclxuICAgICAgKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0ZXAgNjogUnVuIHBvc3QtZGVwbG95bWVudCB0ZXN0c1xyXG4gICAgICBhd2FpdCB0aGlzLnJ1blBvc3REZXBsb3ltZW50VGVzdHMoZmluYWxEZXBsb3ltZW50LnVybCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdGVwIDc6IFVwZGF0ZSBHaXRIdWIgZGVwbG95bWVudCBzdGF0dXNcclxuICAgICAgYXdhaXQgdGhpcy51cGRhdGVHaXRIdWJEZXBsb3ltZW50U3RhdHVzKGNvbmZpZywgZmluYWxEZXBsb3ltZW50LnVybCwgJ3N1Y2Nlc3MnKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0ZXAgODogTm90aWZ5IHN1Y2Nlc3NmdWwgZGVwbG95bWVudFxyXG4gICAgICBhd2FpdCB0aGlzLm5vdGlmeURlcGxveW1lbnRTdWNjZXNzKGNvbmZpZywgZmluYWxEZXBsb3ltZW50KTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBmaW5hbERlcGxveW1lbnQudXJsO1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRGVwbG95bWVudEZhaWx1cmUoY29uZmlnLCBkZXBsb3ltZW50SWQsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGJ1aWxkQW5kUHVzaEltYWdlKGNvbmZpZzogRGVwbG95bWVudENvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgaW1hZ2VOYW1lID0gXFxgXFwke2NvbmZpZy5wcm9qZWN0TmFtZX06XFwke2NvbmZpZy5lbnZpcm9ubWVudH0tXFwke0RhdGUubm93KCl9XFxgO1xyXG4gICAgXHJcbiAgICAvLyBDaGVjayBpZiByZXBvc2l0b3J5IGV4aXN0c1xyXG4gICAgY29uc3QgcmVwb0V4aXN0cyA9IGF3YWl0IHRoaXMuZG9ja2VyaHViLnJlcG9zaXRvcnlFeGlzdHMoY29uZmlnLnByb2plY3ROYW1lKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXBvRXhpc3RzKSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuZG9ja2VyaHViLmNyZWF0ZVJlcG9zaXRvcnkoY29uZmlnLnByb2plY3ROYW1lLCB7XHJcbiAgICAgICAgZGVzY3JpcHRpb246IFxcYFxcJHtjb25maWcucHJvamVjdE5hbWV9IFxcJHtjb25maWcuZW52aXJvbm1lbnR9IGVudmlyb25tZW50XFxgLFxyXG4gICAgICAgIGlzUHJpdmF0ZTogY29uZmlnLmVudmlyb25tZW50ID09PSAncHJvZHVjdGlvbidcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91J2QgdHJpZ2dlciBhIGJ1aWxkIHByb2Nlc3MgaGVyZVxyXG4gICAgY29uc29sZS5sb2coXFxgQnVpbGRpbmcgRG9ja2VyIGltYWdlOiBcXCR7aW1hZ2VOYW1lfVxcYCk7XHJcbiAgICBcclxuICAgIC8vIFNpbXVsYXRlIGJ1aWxkIHRpbWVcclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwMCkpO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhcXGBQdXNoZWQgRG9ja2VyIGltYWdlOiBcXCR7aW1hZ2VOYW1lfVxcYCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHVwbG9hZEJ1aWxkQXJ0aWZhY3RzKFxyXG4gICAgY29uZmlnOiBEZXBsb3ltZW50Q29uZmlnLCBcclxuICAgIGRlcGxveW1lbnRJZDogc3RyaW5nXHJcbiAgKTogUHJvbWlzZTxCdWlsZEFydGlmYWN0W10+IHtcclxuICAgIGNvbnN0IGFydGlmYWN0czogQnVpbGRBcnRpZmFjdFtdID0gW1xyXG4gICAgICB7IG5hbWU6ICdidWlsZC56aXAnLCBwYXRoOiAnL3RtcC9idWlsZC56aXAnLCB0eXBlOiAnYnVpbGQnIH0sXHJcbiAgICAgIHsgbmFtZTogJ2Fzc2V0cy50YXIuZ3onLCBwYXRoOiAnL3RtcC9hc3NldHMudGFyLmd6JywgdHlwZTogJ2Fzc2V0JyB9LFxyXG4gICAgICB7IG5hbWU6ICdjb25maWcuanNvbicsIHBhdGg6ICcvdG1wL2NvbmZpZy5qc29uJywgdHlwZTogJ2NvbmZpZycgfVxyXG4gICAgXTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBhcnRpZmFjdCBvZiBhcnRpZmFjdHMpIHtcclxuICAgICAgY29uc3Qga2V5ID0gXFxgZGVwbG95bWVudHMvXFwke2RlcGxveW1lbnRJZH0vXFwke2FydGlmYWN0Lm5hbWV9XFxgO1xyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXRlIG1vY2sgZmlsZSBjb250ZW50XHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBCdWZmZXIuZnJvbShcXGBNb2NrIFxcJHthcnRpZmFjdC50eXBlfSBhcnRpZmFjdCBmb3IgXFwke2NvbmZpZy5wcm9qZWN0TmFtZX1cXGApO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdXBsb2FkUmVzdWx0ID0gYXdhaXQgdGhpcy5zMy51cGxvYWRPYmplY3Qoa2V5LCBjb250ZW50LCB7XHJcbiAgICAgICAgY29udGVudFR5cGU6IHRoaXMuZ2V0Q29udGVudFR5cGUoYXJ0aWZhY3QubmFtZSksXHJcbiAgICAgICAgbWV0YWRhdGE6IHtcclxuICAgICAgICAgIGRlcGxveW1lbnRfaWQ6IGRlcGxveW1lbnRJZCxcclxuICAgICAgICAgIHByb2plY3Q6IGNvbmZpZy5wcm9qZWN0TmFtZSxcclxuICAgICAgICAgIGVudmlyb25tZW50OiBjb25maWcuZW52aXJvbm1lbnQsXHJcbiAgICAgICAgICB0eXBlOiBhcnRpZmFjdC50eXBlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKFxcYFVwbG9hZGVkIGFydGlmYWN0OiBcXCR7YXJ0aWZhY3QubmFtZX0gdG8gXFwke3VwbG9hZFJlc3VsdC5sb2NhdGlvbn1cXGApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gYXJ0aWZhY3RzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBkZXBsb3lUb1ZlcmNlbChcclxuICAgIGNvbmZpZzogRGVwbG95bWVudENvbmZpZywgXHJcbiAgICBhcnRpZmFjdHM6IEJ1aWxkQXJ0aWZhY3RbXVxyXG4gICk6IFByb21pc2U8YW55PiB7XHJcbiAgICAvLyBDaGVjayBpZiBwcm9qZWN0IGV4aXN0c1xyXG4gICAgbGV0IHByb2plY3Q7XHJcbiAgICB0cnkge1xyXG4gICAgICBwcm9qZWN0ID0gYXdhaXQgdGhpcy52ZXJjZWwuZ2V0UHJvamVjdChjb25maWcucHJvamVjdE5hbWUpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgLy8gQ3JlYXRlIHByb2plY3QgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgICBwcm9qZWN0ID0gYXdhaXQgdGhpcy52ZXJjZWwuY3JlYXRlUHJvamVjdChjb25maWcucHJvamVjdE5hbWUsIHtcclxuICAgICAgICBmcmFtZXdvcms6ICduZXh0anMnLFxyXG4gICAgICAgIGJ1aWxkQ29tbWFuZDogJ25wbSBydW4gYnVpbGQnLFxyXG4gICAgICAgIG91dHB1dERpcmVjdG9yeTogJ2Rpc3QnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzXHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhjb25maWcuZW52VmFycykpIHtcclxuICAgICAgYXdhaXQgdGhpcy52ZXJjZWwuY3JlYXRlRW52aXJvbm1lbnRWYXJpYWJsZShcclxuICAgICAgICBwcm9qZWN0LmlkLFxyXG4gICAgICAgIGtleSxcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBjb25maWcuZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJyA/IFsncHJvZHVjdGlvbiddIDogWydwcmV2aWV3J11cclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGRlcGxveW1lbnRcclxuICAgIGNvbnN0IGRlcGxveW1lbnQgPSBhd2FpdCB0aGlzLnZlcmNlbC5jcmVhdGVEZXBsb3ltZW50KHtcclxuICAgICAgbmFtZTogY29uZmlnLnByb2plY3ROYW1lLFxyXG4gICAgICBnaXRTb3VyY2U6IHtcclxuICAgICAgICB0eXBlOiAnZ2l0aHViJyxcclxuICAgICAgICByZXBvOiBcXGBvd25lci9cXCR7Y29uZmlnLnByb2plY3ROYW1lfVxcYCxcclxuICAgICAgICByZWY6IGNvbmZpZy5naXRCcmFuY2hcclxuICAgICAgfSxcclxuICAgICAgZW52OiBjb25maWcuZW52VmFycyxcclxuICAgICAgcmVnaW9uczogWydpYWQxJywgJ3NmbzEnXSwgLy8gTXVsdGlwbGUgcmVnaW9ucyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXHJcbiAgICAgIGZ1bmN0aW9uczoge1xyXG4gICAgICAgICdwYWdlcy9hcGkvKionOiB7XHJcbiAgICAgICAgICBydW50aW1lOiAnbm9kZWpzMTgueCcsXHJcbiAgICAgICAgICBtZW1vcnk6IDEwMjQsXHJcbiAgICAgICAgICBtYXhEdXJhdGlvbjogMzBcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZGVwbG95bWVudDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgY29uZmlndXJlRG9tYWlucyhwcm9qZWN0SWQ6IHN0cmluZywgZG9tYWluczogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGZvciAoY29uc3QgZG9tYWluIG9mIGRvbWFpbnMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBBZGQgZG9tYWluIHRvIHByb2plY3RcclxuICAgICAgICBhd2FpdCB0aGlzLnZlcmNlbC5hZGREb21haW4ocHJvamVjdElkLCBkb21haW4pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFZlcmlmeSBkb21haW5cclxuICAgICAgICBhd2FpdCB0aGlzLnZlcmNlbC52ZXJpZnlEb21haW4ocHJvamVjdElkLCBkb21haW4pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxcYENvbmZpZ3VyZWQgZG9tYWluOiBcXCR7ZG9tYWlufVxcYCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFxcYEZhaWxlZCB0byBjb25maWd1cmUgZG9tYWluIFxcJHtkb21haW59OlxcYCwgZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJ1blBvc3REZXBsb3ltZW50VGVzdHMoZGVwbG95bWVudFVybDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zb2xlLmxvZyhcXGBSdW5uaW5nIHBvc3QtZGVwbG95bWVudCB0ZXN0cyBmb3IgXFwke2RlcGxveW1lbnRVcmx9XFxgKTtcclxuICAgIFxyXG4gICAgLy8gSGVhbHRoIGNoZWNrXHJcbiAgICBjb25zdCBoZWFsdGhSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxcYFxcJHtkZXBsb3ltZW50VXJsfS9hcGkvaGVhbHRoXFxgKTtcclxuICAgIGlmICghaGVhbHRoUmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYEhlYWx0aCBjaGVjayBmYWlsZWQ6IFxcJHtoZWFsdGhSZXNwb25zZS5zdGF0dXN9XFxgKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUGVyZm9ybWFuY2UgdGVzdFxyXG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgYXdhaXQgZmV0Y2goZGVwbG95bWVudFVybCk7XHJcbiAgICBjb25zdCBsb2FkVGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcclxuICAgIFxyXG4gICAgaWYgKGxvYWRUaW1lID4gMzAwMCkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXFxgU2xvdyBsb2FkIHRpbWUgZGV0ZWN0ZWQ6IFxcJHtsb2FkVGltZX1tc1xcYCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdBbGwgcG9zdC1kZXBsb3ltZW50IHRlc3RzIHBhc3NlZCcpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyB1cGRhdGVHaXRIdWJEZXBsb3ltZW50U3RhdHVzKFxyXG4gICAgY29uZmlnOiBEZXBsb3ltZW50Q29uZmlnLFxyXG4gICAgZGVwbG95bWVudFVybDogc3RyaW5nLFxyXG4gICAgc3RhdHVzOiAnc3VjY2VzcycgfCAnZmFpbHVyZSdcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIFRoaXMgd291bGQgdHlwaWNhbGx5IGJlIGRvbmUgdmlhIEdpdEh1YidzIGRlcGxveW1lbnQgQVBJXHJcbiAgICBjb25zb2xlLmxvZyhcXGBHaXRIdWIgZGVwbG95bWVudCBzdGF0dXMgdXBkYXRlZDogXFwke3N0YXR1c31cXGApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBub3RpZnlEZXBsb3ltZW50U3RhcnQoXHJcbiAgICBjb25maWc6IERlcGxveW1lbnRDb25maWcsIFxyXG4gICAgZGVwbG95bWVudElkOiBzdHJpbmdcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IHRoaXMuc2xhY2suc2VuZE1lc3NhZ2UoJyNkZXBsb3ltZW50cycsXHJcbiAgICAgIFxcYPCfmoAgU3RhcnRpbmcgZGVwbG95bWVudCBvZiAqXFwke2NvbmZpZy5wcm9qZWN0TmFtZX0qIHRvICpcXCR7Y29uZmlnLmVudmlyb25tZW50fSpcXGAsXHJcbiAgICAgIHtcclxuICAgICAgICBibG9ja3M6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogJ3NlY3Rpb24nLFxyXG4gICAgICAgICAgICB0ZXh0OiB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ21ya2R3bicsXHJcbiAgICAgICAgICAgICAgdGV4dDogXFxg8J+agCAqRGVwbG95bWVudCBTdGFydGVkKlxcXFxu4oCiIFByb2plY3Q6IFxcJHtjb25maWcucHJvamVjdE5hbWV9XFxcXG7igKIgRW52aXJvbm1lbnQ6IFxcJHtjb25maWcuZW52aXJvbm1lbnR9XFxcXG7igKIgQnJhbmNoOiBcXCR7Y29uZmlnLmdpdEJyYW5jaH1cXFxcbuKAoiBJRDogXFwke2RlcGxveW1lbnRJZH1cXGBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbm90aWZ5RGVwbG95bWVudFN1Y2Nlc3MoXHJcbiAgICBjb25maWc6IERlcGxveW1lbnRDb25maWcsIFxyXG4gICAgZGVwbG95bWVudDogYW55XHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCB0aGlzLnNsYWNrLnNlbmRNZXNzYWdlKCcjZGVwbG95bWVudHMnLFxyXG4gICAgICBcXGDinIUgU3VjY2Vzc2Z1bGx5IGRlcGxveWVkICpcXCR7Y29uZmlnLnByb2plY3ROYW1lfSogdG8gKlxcJHtjb25maWcuZW52aXJvbm1lbnR9KlxcYCxcclxuICAgICAge1xyXG4gICAgICAgIGJsb2NrczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiAnc2VjdGlvbicsXHJcbiAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnbXJrZHduJyxcclxuICAgICAgICAgICAgICB0ZXh0OiBcXGDinIUgKkRlcGxveW1lbnQgU3VjY2Vzc2Z1bCpcXFxcbuKAoiBQcm9qZWN0OiBcXCR7Y29uZmlnLnByb2plY3ROYW1lfVxcXFxu4oCiIEVudmlyb25tZW50OiBcXCR7Y29uZmlnLmVudmlyb25tZW50fVxcXFxu4oCiIFVSTDogXFwke2RlcGxveW1lbnQudXJsfVxcXFxu4oCiIFN0YXR1czogXFwke2RlcGxveW1lbnQuc3RhdGV9XFxgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdhY3Rpb25zJyxcclxuICAgICAgICAgICAgZWxlbWVudHM6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnV0dG9uJyxcclxuICAgICAgICAgICAgICAgIHRleHQ6IHsgdHlwZTogJ3BsYWluX3RleHQnLCB0ZXh0OiAnVmlldyBEZXBsb3ltZW50JyB9LFxyXG4gICAgICAgICAgICAgICAgdXJsOiBkZXBsb3ltZW50LnVybFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J1dHRvbicsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiB7IHR5cGU6ICdwbGFpbl90ZXh0JywgdGV4dDogJ1ZpZXcgTG9ncycgfSxcclxuICAgICAgICAgICAgICAgIHVybDogXFxgaHR0cHM6Ly92ZXJjZWwuY29tL2RlcGxveW1lbnRzL1xcJHtkZXBsb3ltZW50LnVpZH1cXGBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGhhbmRsZURlcGxveW1lbnRGYWlsdXJlKFxyXG4gICAgY29uZmlnOiBEZXBsb3ltZW50Q29uZmlnLFxyXG4gICAgZGVwbG95bWVudElkOiBzdHJpbmcsXHJcbiAgICBlcnJvcjogYW55XHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCB0aGlzLnNsYWNrLnNlbmRNZXNzYWdlKCcjZGVwbG95bWVudHMnLFxyXG4gICAgICBcXGDinYwgRGVwbG95bWVudCBvZiAqXFwke2NvbmZpZy5wcm9qZWN0TmFtZX0qIGZhaWxlZFxcYCxcclxuICAgICAge1xyXG4gICAgICAgIGJsb2NrczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiAnc2VjdGlvbicsXHJcbiAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICB0eXBlOiAnbXJrZHduJyxcclxuICAgICAgICAgICAgICB0ZXh0OiBcXGDinYwgKkRlcGxveW1lbnQgRmFpbGVkKlxcXFxu4oCiIFByb2plY3Q6IFxcJHtjb25maWcucHJvamVjdE5hbWV9XFxcXG7igKIgRW52aXJvbm1lbnQ6IFxcJHtjb25maWcuZW52aXJvbm1lbnR9XFxcXG7igKIgRXJyb3I6IFxcJHtlcnJvci5tZXNzYWdlfVxcXFxu4oCiIElEOiBcXCR7ZGVwbG95bWVudElkfVxcYFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmVycm9yKCdEZXBsb3ltZW50IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldENvbnRlbnRUeXBlKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgZXh0ID0gZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKT8udG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IHR5cGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgICAnemlwJzogJ2FwcGxpY2F0aW9uL3ppcCcsXHJcbiAgICAgICdneic6ICdhcHBsaWNhdGlvbi9nemlwJyxcclxuICAgICAgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICdqcyc6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcclxuICAgICAgJ2Nzcyc6ICd0ZXh0L2NzcydcclxuICAgIH07XHJcbiAgICByZXR1cm4gdHlwZXNbZXh0IHx8ICcnXSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcclxuICB9XHJcblxyXG4gIGFzeW5jIHJvbGxiYWNrRGVwbG95bWVudChwcm9qZWN0TmFtZTogc3RyaW5nLCB0YXJnZXRWZXJzaW9uOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIEltcGxlbWVudGF0aW9uIGZvciByb2xsYmFjayBmdW5jdGlvbmFsaXR5XHJcbiAgICBjb25zb2xlLmxvZyhcXGBSb2xsaW5nIGJhY2sgXFwke3Byb2plY3ROYW1lfSB0byB2ZXJzaW9uIFxcJHt0YXJnZXRWZXJzaW9ufVxcYCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXREZXBsb3ltZW50TWV0cmljcyhkZXBsb3ltZW50VXJsOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgLy8gR2V0IHBlcmZvcm1hbmNlIG1ldHJpY3NcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxvYWRUaW1lOiBNYXRoLnJhbmRvbSgpICogMjAwMCxcclxuICAgICAgbWVtb3J5VXNhZ2U6IE1hdGgucmFuZG9tKCkgKiAxMDAsXHJcbiAgICAgIGNwdVVzYWdlOiBNYXRoLnJhbmRvbSgpICogMTAwLFxyXG4gICAgICByZXF1ZXN0Q291bnQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFVzYWdlIGV4YW1wbGVcclxuY29uc3QgcGlwZWxpbmUgPSBuZXcgQ2xvdWREZXBsb3ltZW50UGlwZWxpbmUoKTtcclxuXHJcbi8vIERlcGxveSB0byBzdGFnaW5nXHJcbmNvbnN0IHN0YWdpbmdVcmwgPSBhd2FpdCBwaXBlbGluZS5kZXBsb3lBcHBsaWNhdGlvbih7XHJcbiAgcHJvamVjdE5hbWU6ICdteS1uZXh0LWFwcCcsXHJcbiAgZW52aXJvbm1lbnQ6ICdzdGFnaW5nJyxcclxuICBnaXRCcmFuY2g6ICdkZXZlbG9wJyxcclxuICBkb2NrZXJJbWFnZTogJ215LW5leHQtYXBwOnN0YWdpbmcnLFxyXG4gIGVudlZhcnM6IHtcclxuICAgIE5PREVfRU5WOiAnc3RhZ2luZycsXHJcbiAgICBBUElfVVJMOiAnaHR0cHM6Ly9hcGktc3RhZ2luZy5leGFtcGxlLmNvbScsXHJcbiAgICBEQVRBQkFTRV9VUkw6IHByb2Nlc3MuZW52LlNUQUdJTkdfREJfVVJMIVxyXG4gIH1cclxufSk7XHJcblxyXG4vLyBEZXBsb3kgdG8gcHJvZHVjdGlvblxyXG5jb25zdCBwcm9kdWN0aW9uVXJsID0gYXdhaXQgcGlwZWxpbmUuZGVwbG95QXBwbGljYXRpb24oe1xyXG4gIHByb2plY3ROYW1lOiAnbXktbmV4dC1hcHAnLFxyXG4gIGVudmlyb25tZW50OiAncHJvZHVjdGlvbicsXHJcbiAgZ2l0QnJhbmNoOiAnbWFpbicsXHJcbiAgZG9ja2VySW1hZ2U6ICdteS1uZXh0LWFwcDpwcm9kdWN0aW9uJyxcclxuICBlbnZWYXJzOiB7XHJcbiAgICBOT0RFX0VOVjogJ3Byb2R1Y3Rpb24nLFxyXG4gICAgQVBJX1VSTDogJ2h0dHBzOi8vYXBpLmV4YW1wbGUuY29tJyxcclxuICAgIERBVEFCQVNFX1VSTDogcHJvY2Vzcy5lbnYuUFJPRFVDVElPTl9EQl9VUkwhXHJcbiAgfSxcclxuICBkb21haW5zOiBbJ2FwcC5leGFtcGxlLmNvbScsICd3d3cuYXBwLmV4YW1wbGUuY29tJ11cclxufSk7XHJcblxyXG5jb25zb2xlLmxvZyhcXGBTdGFnaW5nIGRlcGxveWVkIHRvOiBcXCR7c3RhZ2luZ1VybH1cXGApO1xyXG5jb25zb2xlLmxvZyhcXGBQcm9kdWN0aW9uIGRlcGxveWVkIHRvOiBcXCR7cHJvZHVjdGlvblVybH1cXGApO2AsXHJcbiAgICBqYXZhc2NyaXB0OiBgY29uc3QgeyBWZXJjZWxBUEksIERvY2tlckh1YkFQSSwgUzNBUEksIEdpdEh1YkFQSSwgU2xhY2tBUEkgfSA9IHJlcXVpcmUoJ21hY3JvX2FwaScpO1xyXG5cclxuY2xhc3MgQ2xvdWREZXBsb3ltZW50UGlwZWxpbmUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy52ZXJjZWwgPSBuZXcgVmVyY2VsQVBJKHtcclxuICAgICAgYWNjZXNzVG9rZW46IHByb2Nlc3MuZW52LlZFUkNFTF9UT0tFTlxyXG4gICAgfSk7XHJcbiAgICB0aGlzLmRvY2tlcmh1YiA9IG5ldyBEb2NrZXJIdWJBUEkoe1xyXG4gICAgICB0b2tlbjogcHJvY2Vzcy5lbnYuRE9DS0VSX1RPS0VOXHJcbiAgICB9KTtcclxuICAgIHRoaXMuczMgPSBuZXcgUzNBUEkoe1xyXG4gICAgICBhY2Nlc3NLZXlJZDogcHJvY2Vzcy5lbnYuQVdTX0FDQ0VTU19LRVlfSUQsXHJcbiAgICAgIHNlY3JldEFjY2Vzc0tleTogcHJvY2Vzcy5lbnYuQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZLFxyXG4gICAgICByZWdpb246IHByb2Nlc3MuZW52LkFXU19SRUdJT04sXHJcbiAgICAgIGJ1Y2tldE5hbWU6IHByb2Nlc3MuZW52LlMzX0JVQ0tFVFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNsYWNrID0gbmV3IFNsYWNrQVBJKHtcclxuICAgICAgYm90VG9rZW46IHByb2Nlc3MuZW52LlNMQUNLX0JPVF9UT0tFTlxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZXBsb3lBcHBsaWNhdGlvbihjb25maWcpIHtcclxuICAgIGNvbnN0IGRlcGxveW1lbnRJZCA9IFxcYGRlcGxveS1cXCR7RGF0ZS5ub3coKX1cXGA7XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIE5vdGlmeSBzdGFydFxyXG4gICAgICBhd2FpdCB0aGlzLm5vdGlmeURlcGxveW1lbnRTdGFydChjb25maWcsIGRlcGxveW1lbnRJZCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGxvYWQgYXJ0aWZhY3RzIHRvIFMzXHJcbiAgICAgIGNvbnN0IGFydGlmYWN0cyA9IGF3YWl0IHRoaXMudXBsb2FkQnVpbGRBcnRpZmFjdHMoY29uZmlnLCBkZXBsb3ltZW50SWQpO1xyXG4gICAgICBcclxuICAgICAgLy8gRGVwbG95IHRvIFZlcmNlbFxyXG4gICAgICBjb25zdCBkZXBsb3ltZW50ID0gYXdhaXQgdGhpcy5kZXBsb3lUb1ZlcmNlbChjb25maWcsIGFydGlmYWN0cyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBXYWl0IGZvciBjb21wbGV0aW9uXHJcbiAgICAgIGNvbnN0IGZpbmFsRGVwbG95bWVudCA9IGF3YWl0IHRoaXMudmVyY2VsLndhaXRGb3JEZXBsb3ltZW50KGRlcGxveW1lbnQudWlkLCA2MDAwMDApO1xyXG4gICAgICBcclxuICAgICAgLy8gTm90aWZ5IHN1Y2Nlc3NcclxuICAgICAgYXdhaXQgdGhpcy5ub3RpZnlEZXBsb3ltZW50U3VjY2Vzcyhjb25maWcsIGZpbmFsRGVwbG95bWVudCk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gZmluYWxEZXBsb3ltZW50LnVybDtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZURlcGxveW1lbnRGYWlsdXJlKGNvbmZpZywgZGVwbG95bWVudElkLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgdXBsb2FkQnVpbGRBcnRpZmFjdHMoY29uZmlnLCBkZXBsb3ltZW50SWQpIHtcclxuICAgIGNvbnN0IGFydGlmYWN0cyA9IFtcclxuICAgICAgeyBuYW1lOiAnYnVpbGQuemlwJywgdHlwZTogJ2J1aWxkJyB9LFxyXG4gICAgICB7IG5hbWU6ICdhc3NldHMudGFyLmd6JywgdHlwZTogJ2Fzc2V0JyB9XHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IGFydGlmYWN0IG9mIGFydGlmYWN0cykge1xyXG4gICAgICBjb25zdCBrZXkgPSBcXGBkZXBsb3ltZW50cy9cXCR7ZGVwbG95bWVudElkfS9cXCR7YXJ0aWZhY3QubmFtZX1cXGA7XHJcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBCdWZmZXIuZnJvbShcXGBNb2NrIFxcJHthcnRpZmFjdC50eXBlfSBhcnRpZmFjdFxcYCk7XHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCB0aGlzLnMzLnVwbG9hZE9iamVjdChrZXksIGNvbnRlbnQsIHtcclxuICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgZGVwbG95bWVudF9pZDogZGVwbG95bWVudElkLFxyXG4gICAgICAgICAgcHJvamVjdDogY29uZmlnLnByb2plY3ROYW1lLFxyXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IGNvbmZpZy5lbnZpcm9ubWVudFxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBhcnRpZmFjdHM7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBVc2FnZVxyXG5jb25zdCBwaXBlbGluZSA9IG5ldyBDbG91ZERlcGxveW1lbnRQaXBlbGluZSgpO1xyXG5cclxuY29uc3QgZGVwbG95bWVudFVybCA9IGF3YWl0IHBpcGVsaW5lLmRlcGxveUFwcGxpY2F0aW9uKHtcclxuICBwcm9qZWN0TmFtZTogJ215LWFwcCcsXHJcbiAgZW52aXJvbm1lbnQ6ICdwcm9kdWN0aW9uJyxcclxuICBnaXRCcmFuY2g6ICdtYWluJyxcclxuICBlbnZWYXJzOiB7XHJcbiAgICBOT0RFX0VOVjogJ3Byb2R1Y3Rpb24nLFxyXG4gICAgQVBJX1VSTDogJ2h0dHBzOi8vYXBpLmV4YW1wbGUuY29tJ1xyXG4gIH1cclxufSk7YFxyXG4gIH0sXHJcbiAge1xyXG4gICAgaWQ6ICdnYW1pbmctYW5hbHl0aWNzJyxcclxuICAgIHRpdGxlOiAnR2FtaW5nIEFuYWx5dGljcyBEYXNoYm9hcmQnLFxyXG4gICAgZGVzY3JpcHRpb246ICdDb21wcmVoZW5zaXZlIGdhbWluZyBhbmFseXRpY3MgdXNpbmcgVmFsb3JhbnQgQVBJIGFuZCBGb290YmFsbCBBUEkgd2l0aCByZWFsLXRpbWUgc3RhdGlzdGljcyBhbmQgbGVhZGVyYm9hcmRzLicsXHJcbiAgICBjYXRlZ29yeTogJ0dhbWluZyAmIEVudGVydGFpbm1lbnQnLFxyXG4gICAgZGlmZmljdWx0eTogJ2ludGVybWVkaWF0ZScsXHJcbiAgICBzZXJ2aWNlczogWydWYWxvcmFudCcsICdGb290YmFsbCcsICdOb3Rpb24nLCAnU2xhY2snXSxcclxuICAgIGZlYXR1cmVzOiBbJ1N0YXRpc3RpY3MgVHJhY2tpbmcnLCAnTGVhZGVyYm9hcmRzJywgJ0RhdGEgU3RvcmFnZScsICdOb3RpZmljYXRpb25zJ10sXHJcbiAgICB0eXBlc2NyaXB0OiBgaW1wb3J0IHsgVmFsb3JhbnQsIEZvb3RiYWxsQVBJLCBOb3Rpb25BUEksIFNsYWNrQVBJIH0gZnJvbSAnbWFjcm9fYXBpJztcclxuXHJcbmludGVyZmFjZSBQbGF5ZXJTdGF0cyB7XHJcbiAgcHV1aWQ6IHN0cmluZztcclxuICBnYW1lTmFtZTogc3RyaW5nO1xyXG4gIHRhZ0xpbmU6IHN0cmluZztcclxuICByYW5rOiBzdHJpbmc7XHJcbiAgcnI6IG51bWJlcjtcclxuICBrZDogbnVtYmVyO1xyXG4gIHdpblJhdGU6IG51bWJlcjtcclxuICByZWNlbnRNYXRjaGVzOiBhbnlbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFRlYW1TdGF0cyB7XHJcbiAgdGVhbUlkOiBudW1iZXI7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGxlYWd1ZTogc3RyaW5nO1xyXG4gIHdpbnM6IG51bWJlcjtcclxuICBsb3NzZXM6IG51bWJlcjtcclxuICBkcmF3czogbnVtYmVyO1xyXG4gIGdvYWxzRm9yOiBudW1iZXI7XHJcbiAgZ29hbHNBZ2FpbnN0OiBudW1iZXI7XHJcbiAgcG9zaXRpb246IG51bWJlcjtcclxufVxyXG5cclxuY2xhc3MgR2FtaW5nQW5hbHl0aWNzRGFzaGJvYXJkIHtcclxuICBwcml2YXRlIHZhbG9yYW50OiBWYWxvcmFudDtcclxuICBwcml2YXRlIGZvb3RiYWxsOiBGb290YmFsbEFQSTtcclxuICBwcml2YXRlIG5vdGlvbjogTm90aW9uQVBJO1xyXG4gIHByaXZhdGUgc2xhY2s6IFNsYWNrQVBJO1xyXG4gIHByaXZhdGUgcGxheWVyRGF0YWJhc2U6IHN0cmluZzsgLy8gTm90aW9uIGRhdGFiYXNlIElEXHJcbiAgcHJpdmF0ZSB0ZWFtRGF0YWJhc2U6IHN0cmluZzsgLy8gTm90aW9uIGRhdGFiYXNlIElEXHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy52YWxvcmFudCA9IG5ldyBWYWxvcmFudChwcm9jZXNzLmVudi5IRU5SSUtfQVBJX0tFWSk7XHJcbiAgICB0aGlzLmZvb3RiYWxsID0gbmV3IEZvb3RiYWxsQVBJKHtcclxuICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5GT09UQkFMTF9BUElfS0VZIVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLm5vdGlvbiA9IG5ldyBOb3Rpb25BUEkoe1xyXG4gICAgICBhcGlLZXk6IHByb2Nlc3MuZW52Lk5PVElPTl9BUElfS0VZIVxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnNsYWNrID0gbmV3IFNsYWNrQVBJKHtcclxuICAgICAgYm90VG9rZW46IHByb2Nlc3MuZW52LlNMQUNLX0JPVF9UT0tFTiFcclxuICAgIH0pO1xyXG4gICAgdGhpcy5wbGF5ZXJEYXRhYmFzZSA9IHByb2Nlc3MuZW52Lk5PVElPTl9QTEFZRVJfREIhO1xyXG4gICAgdGhpcy50ZWFtRGF0YWJhc2UgPSBwcm9jZXNzLmVudi5OT1RJT05fVEVBTV9EQiE7XHJcbiAgfVxyXG5cclxuICBhc3luYyB0cmFja1ZhbG9yYW50UGxheWVyKGdhbWVOYW1lOiBzdHJpbmcsIHRhZ0xpbmU6IHN0cmluZywgcmVnaW9uOiBzdHJpbmcgPSAnbmEnKTogUHJvbWlzZTxQbGF5ZXJTdGF0cz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHBsYXllciBhY2NvdW50XHJcbiAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLnZhbG9yYW50LmdldEFjY291bnQoZ2FtZU5hbWUsIHRhZ0xpbmUpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IE1NUiBkYXRhXHJcbiAgICAgIGNvbnN0IG1tckRhdGEgPSBhd2FpdCB0aGlzLnZhbG9yYW50LmdldE1NUihnYW1lTmFtZSwgdGFnTGluZSwgeyByZWdpb24gfSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgbWF0Y2ggaGlzdG9yeVxyXG4gICAgICBjb25zdCBtYXRjaEhpc3RvcnkgPSBhd2FpdCB0aGlzLnZhbG9yYW50LmdldE1hdGNoSGlzdG9yeShyZWdpb24sIGdhbWVOYW1lLCB0YWdMaW5lLCB7XHJcbiAgICAgICAgcXVldWU6ICdjb21wZXRpdGl2ZSdcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDYWxjdWxhdGUgZGV0YWlsZWQgc3RhdHNcclxuICAgICAgY29uc3QgcGxheWVyU3RhdHMgPSBhd2FpdCB0aGlzLnZhbG9yYW50LmdldFBsYXllclN0YXRzKHJlZ2lvbiwgZ2FtZU5hbWUsIHRhZ0xpbmUpO1xyXG4gICAgICBcclxuICAgICAgY29uc3Qgc3RhdHM6IFBsYXllclN0YXRzID0ge1xyXG4gICAgICAgIHB1dWlkOiBhY2NvdW50LnB1dWlkLFxyXG4gICAgICAgIGdhbWVOYW1lOiBhY2NvdW50Lm5hbWUsXHJcbiAgICAgICAgdGFnTGluZTogYWNjb3VudC50YWcsXHJcbiAgICAgICAgcmFuazogbW1yRGF0YS5jdXJyZW50dGllcnBhdGNoZWQgfHwgJ1VucmFua2VkJyxcclxuICAgICAgICBycjogbW1yRGF0YS5yYW5raW5nX2luX3RpZXIgfHwgMCxcclxuICAgICAgICBrZDogcGFyc2VGbG9hdCgocGxheWVyU3RhdHMuY29tYmF0Py5rZCB8fCAnMCcpLnRvU3RyaW5nKCkpLFxyXG4gICAgICAgIHdpblJhdGU6IHBhcnNlRmxvYXQoKHBsYXllclN0YXRzLm92ZXJ2aWV3Py53aW5SYXRlIHx8ICcwJScpLnJlcGxhY2UoJyUnLCAnJykpLFxyXG4gICAgICAgIHJlY2VudE1hdGNoZXM6IG1hdGNoSGlzdG9yeS5zbGljZSgwLCA1KVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gU3RvcmUgaW4gTm90aW9uIGRhdGFiYXNlXHJcbiAgICAgIGF3YWl0IHRoaXMuc3RvcmVQbGF5ZXJTdGF0cyhzdGF0cyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBmb3IgcmFuayBjaGFuZ2VzIGFuZCBub3RpZnlcclxuICAgICAgYXdhaXQgdGhpcy5jaGVja1JhbmtDaGFuZ2VzKHN0YXRzKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiBzdGF0cztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRyYWNraW5nIFZhbG9yYW50IHBsYXllcjonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgdHJhY2tGb290YmFsbFRlYW0odGVhbUlkOiBudW1iZXIsIGxlYWd1ZUlkOiBudW1iZXIsIHNlYXNvbjogbnVtYmVyKTogUHJvbWlzZTxUZWFtU3RhdHM+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEdldCB0ZWFtIGluZm9ybWF0aW9uXHJcbiAgICAgIGNvbnN0IHRlYW1JbmZvID0gYXdhaXQgdGhpcy5mb290YmFsbC5nZXRUZWFtcyh7IGlkOiB0ZWFtSWQgfSk7XHJcbiAgICAgIGNvbnN0IHRlYW0gPSB0ZWFtSW5mb1swXTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCB0ZWFtIHN0YXRpc3RpY3NcclxuICAgICAgY29uc3QgdGVhbVN0YXRzID0gYXdhaXQgdGhpcy5mb290YmFsbC5nZXRUZWFtU3RhdGlzdGljcyh7XHJcbiAgICAgICAgbGVhZ3VlOiBsZWFndWVJZCxcclxuICAgICAgICB0ZWFtOiB0ZWFtSWQsXHJcbiAgICAgICAgc2Vhc29uXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IGxlYWd1ZSBzdGFuZGluZ3NcclxuICAgICAgY29uc3Qgc3RhbmRpbmdzID0gYXdhaXQgdGhpcy5mb290YmFsbC5nZXRTdGFuZGluZ3Moe1xyXG4gICAgICAgIGxlYWd1ZTogbGVhZ3VlSWQsXHJcbiAgICAgICAgc2Vhc29uLFxyXG4gICAgICAgIHRlYW06IHRlYW1JZFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHN0YXRzOiBUZWFtU3RhdHMgPSB7XHJcbiAgICAgICAgdGVhbUlkOiB0ZWFtLmlkLFxyXG4gICAgICAgIG5hbWU6IHRlYW0ubmFtZSxcclxuICAgICAgICBsZWFndWU6IHRlYW1TdGF0cy5sZWFndWUubmFtZSxcclxuICAgICAgICB3aW5zOiB0ZWFtU3RhdHMuZml4dHVyZXMud2lucy50b3RhbCxcclxuICAgICAgICBsb3NzZXM6IHRlYW1TdGF0cy5maXh0dXJlcy5sb3Nlcy50b3RhbCxcclxuICAgICAgICBkcmF3czogdGVhbVN0YXRzLmZpeHR1cmVzLmRyYXdzLnRvdGFsLFxyXG4gICAgICAgIGdvYWxzRm9yOiB0ZWFtU3RhdHMuZ29hbHMuZm9yLnRvdGFsLnRvdGFsLFxyXG4gICAgICAgIGdvYWxzQWdhaW5zdDogdGVhbVN0YXRzLmdvYWxzLmFnYWluc3QudG90YWwudG90YWwsXHJcbiAgICAgICAgcG9zaXRpb246IHN0YW5kaW5nc1swXS5sZWFndWUuc3RhbmRpbmdzWzBdLmZpbmQoKHM6IGFueSkgPT4gcy50ZWFtLmlkID09PSB0ZWFtSWQpPy5yYW5rIHx8IDBcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3JlIGluIE5vdGlvbiBkYXRhYmFzZVxyXG4gICAgICBhd2FpdCB0aGlzLnN0b3JlVGVhbVN0YXRzKHN0YXRzKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGZvciBzaWduaWZpY2FudCBjaGFuZ2VzXHJcbiAgICAgIGF3YWl0IHRoaXMuY2hlY2tUZWFtUGVyZm9ybWFuY2Uoc3RhdHMpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHN0YXRzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdHJhY2tpbmcgZm9vdGJhbGwgdGVhbTonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzdG9yZVBsYXllclN0YXRzKHN0YXRzOiBQbGF5ZXJTdGF0cyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcclxuICAgICAgJ1BsYXllciBOYW1lJzoge1xyXG4gICAgICAgIHRpdGxlOiBbeyB0ZXh0OiB7IGNvbnRlbnQ6IFxcYFxcJHtzdGF0cy5nYW1lTmFtZX0jXFwke3N0YXRzLnRhZ0xpbmV9XFxgIH0gfV1cclxuICAgICAgfSxcclxuICAgICAgJ1BVVUlEJzoge1xyXG4gICAgICAgIHJpY2hfdGV4dDogW3sgdGV4dDogeyBjb250ZW50OiBzdGF0cy5wdXVpZCB9IH1dXHJcbiAgICAgIH0sXHJcbiAgICAgICdSYW5rJzoge1xyXG4gICAgICAgIHNlbGVjdDogeyBuYW1lOiBzdGF0cy5yYW5rIH1cclxuICAgICAgfSxcclxuICAgICAgJ1JSJzoge1xyXG4gICAgICAgIG51bWJlcjogc3RhdHMucnJcclxuICAgICAgfSxcclxuICAgICAgJ0svRCBSYXRpbyc6IHtcclxuICAgICAgICBudW1iZXI6IHN0YXRzLmtkXHJcbiAgICAgIH0sXHJcbiAgICAgICdXaW4gUmF0ZSc6IHtcclxuICAgICAgICBudW1iZXI6IHN0YXRzLndpblJhdGVcclxuICAgICAgfSxcclxuICAgICAgJ0xhc3QgVXBkYXRlZCc6IHtcclxuICAgICAgICBkYXRlOiB7IHN0YXJ0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGF3YWl0IHRoaXMubm90aW9uLmNyZWF0ZVBhZ2Uoe1xyXG4gICAgICBwYXJlbnQ6IHsgZGF0YWJhc2VfaWQ6IHRoaXMucGxheWVyRGF0YWJhc2UgfSxcclxuICAgICAgcHJvcGVydGllc1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHN0b3JlVGVhbVN0YXRzKHN0YXRzOiBUZWFtU3RhdHMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XHJcbiAgICAgICdUZWFtIE5hbWUnOiB7XHJcbiAgICAgICAgdGl0bGU6IFt7IHRleHQ6IHsgY29udGVudDogc3RhdHMubmFtZSB9IH1dXHJcbiAgICAgIH0sXHJcbiAgICAgICdMZWFndWUnOiB7XHJcbiAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHN0YXRzLmxlYWd1ZSB9XHJcbiAgICAgIH0sXHJcbiAgICAgICdQb3NpdGlvbic6IHtcclxuICAgICAgICBudW1iZXI6IHN0YXRzLnBvc2l0aW9uXHJcbiAgICAgIH0sXHJcbiAgICAgICdXaW5zJzoge1xyXG4gICAgICAgIG51bWJlcjogc3RhdHMud2luc1xyXG4gICAgICB9LFxyXG4gICAgICAnTG9zc2VzJzoge1xyXG4gICAgICAgIG51bWJlcjogc3RhdHMubG9zc2VzXHJcbiAgICAgIH0sXHJcbiAgICAgICdEcmF3cyc6IHtcclxuICAgICAgICBudW1iZXI6IHN0YXRzLmRyYXdzXHJcbiAgICAgIH0sXHJcbiAgICAgICdHb2FscyBGb3InOiB7XHJcbiAgICAgICAgbnVtYmVyOiBzdGF0cy5nb2Fsc0ZvclxyXG4gICAgICB9LFxyXG4gICAgICAnR29hbHMgQWdhaW5zdCc6IHtcclxuICAgICAgICBudW1iZXI6IHN0YXRzLmdvYWxzQWdhaW5zdFxyXG4gICAgICB9LFxyXG4gICAgICAnTGFzdCBVcGRhdGVkJzoge1xyXG4gICAgICAgIGRhdGU6IHsgc3RhcnQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgYXdhaXQgdGhpcy5ub3Rpb24uY3JlYXRlUGFnZSh7XHJcbiAgICAgIHBhcmVudDogeyBkYXRhYmFzZV9pZDogdGhpcy50ZWFtRGF0YWJhc2UgfSxcclxuICAgICAgcHJvcGVydGllc1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGNoZWNrUmFua0NoYW5nZXMoY3VycmVudFN0YXRzOiBQbGF5ZXJTdGF0cyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gUXVlcnkgcHJldmlvdXMgc3RhdHMgZnJvbSBOb3Rpb25cclxuICAgIGNvbnN0IHByZXZpb3VzRGF0YSA9IGF3YWl0IHRoaXMubm90aW9uLnF1ZXJ5RGF0YWJhc2UodGhpcy5wbGF5ZXJEYXRhYmFzZSwge1xyXG4gICAgICBmaWx0ZXI6IHtcclxuICAgICAgICBwcm9wZXJ0eTogJ1BVVUlEJyxcclxuICAgICAgICByaWNoX3RleHQ6IHsgZXF1YWxzOiBjdXJyZW50U3RhdHMucHV1aWQgfVxyXG4gICAgICB9LFxyXG4gICAgICBzb3J0czogW3sgdGltZXN0YW1wOiAnbGFzdF9lZGl0ZWRfdGltZScsIGRpcmVjdGlvbjogJ2Rlc2NlbmRpbmcnIH1dXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAocHJldmlvdXNEYXRhLnJlc3VsdHMubGVuZ3RoID4gMSkge1xyXG4gICAgICBjb25zdCBwcmV2aW91c0VudHJ5ID0gcHJldmlvdXNEYXRhLnJlc3VsdHNbMV07XHJcbiAgICAgIGNvbnN0IHByZXZpb3VzUmFuayA9IHRoaXMuZ2V0UHJvcGVydHlWYWx1ZShwcmV2aW91c0VudHJ5LnByb3BlcnRpZXMsICdSYW5rJyk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAocHJldmlvdXNSYW5rICE9PSBjdXJyZW50U3RhdHMucmFuaykge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuc2xhY2suc2VuZE1lc3NhZ2UoJyNnYW1pbmctdXBkYXRlcycsXHJcbiAgICAgICAgICBcXGDwn46uIFJhbmsgVXBkYXRlOiAqXFwke2N1cnJlbnRTdGF0cy5nYW1lTmFtZX0jXFwke2N1cnJlbnRTdGF0cy50YWdMaW5lfSogXFxcXG5cXCR7cHJldmlvdXNSYW5rfSDinqHvuI8gXFwke2N1cnJlbnRTdGF0cy5yYW5rfVxcYCxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgYmxvY2tzOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NlY3Rpb24nLFxyXG4gICAgICAgICAgICAgICAgdGV4dDoge1xyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnbXJrZHduJyxcclxuICAgICAgICAgICAgICAgICAgdGV4dDogXFxg8J+OriAqVmFsb3JhbnQgUmFuayBVcGRhdGUqXFxcXG7igKIgUGxheWVyOiBcXCR7Y3VycmVudFN0YXRzLmdhbWVOYW1lfSNcXCR7Y3VycmVudFN0YXRzLnRhZ0xpbmV9XFxcXG7igKIgUHJldmlvdXM6IFxcJHtwcmV2aW91c1Jhbmt9XFxcXG7igKIgQ3VycmVudDogXFwke2N1cnJlbnRTdGF0cy5yYW5rfVxcXFxu4oCiIFJSOiBcXCR7Y3VycmVudFN0YXRzLnJyfVxcXFxu4oCiIEsvRDogXFwke2N1cnJlbnRTdGF0cy5rZH1cXFxcbuKAoiBXaW4gUmF0ZTogXFwke2N1cnJlbnRTdGF0cy53aW5SYXRlfSVcXGBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGNoZWNrVGVhbVBlcmZvcm1hbmNlKGN1cnJlbnRTdGF0czogVGVhbVN0YXRzKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBDaGVjayBpZiB0ZWFtIGlzIGluIHRvcCA0IChDaGFtcGlvbnMgTGVhZ3VlIHNwb3RzKVxyXG4gICAgaWYgKGN1cnJlbnRTdGF0cy5wb3NpdGlvbiA8PSA0KSB7XHJcbiAgICAgIGF3YWl0IHRoaXMuc2xhY2suc2VuZE1lc3NhZ2UoJyNmb290YmFsbC11cGRhdGVzJyxcclxuICAgICAgICBcXGDimr0gQ2hhbXBpb25zIExlYWd1ZSBQb3NpdGlvbjogKlxcJHtjdXJyZW50U3RhdHMubmFtZX0qIGlzIGN1cnJlbnRseSBcXCR7dGhpcy5nZXRQb3NpdGlvblN1ZmZpeChjdXJyZW50U3RhdHMucG9zaXRpb24pfSBpbiBcXCR7Y3VycmVudFN0YXRzLmxlYWd1ZX0hXFxgLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGJsb2NrczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgdHlwZTogJ3NlY3Rpb24nLFxyXG4gICAgICAgICAgICAgIHRleHQ6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdtcmtkd24nLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogXFxg4pq9ICpcXCR7Y3VycmVudFN0YXRzLm5hbWV9IFBlcmZvcm1hbmNlKlxcXFxu4oCiIFBvc2l0aW9uOiBcXCR7Y3VycmVudFN0YXRzLnBvc2l0aW9ufVxcXFxu4oCiIExlYWd1ZTogXFwke2N1cnJlbnRTdGF0cy5sZWFndWV9XFxcXG7igKIgUmVjb3JkOiBcXCR7Y3VycmVudFN0YXRzLndpbnN9Vy1cXCR7Y3VycmVudFN0YXRzLmRyYXdzfUQtXFwke2N1cnJlbnRTdGF0cy5sb3NzZXN9TFxcXFxu4oCiIEdvYWxzOiBcXCR7Y3VycmVudFN0YXRzLmdvYWxzRm9yfSBmb3IsIFxcJHtjdXJyZW50U3RhdHMuZ29hbHNBZ2FpbnN0fSBhZ2FpbnN0XFxgXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2VuZXJhdGVMZWFkZXJib2FyZCh0eXBlOiAndmFsb3JhbnQnIHwgJ2Zvb3RiYWxsJyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBpZiAodHlwZSA9PT0gJ3ZhbG9yYW50Jykge1xyXG4gICAgICBjb25zdCBwbGF5ZXJzRGF0YSA9IGF3YWl0IHRoaXMubm90aW9uLnF1ZXJ5RGF0YWJhc2UodGhpcy5wbGF5ZXJEYXRhYmFzZSwge1xyXG4gICAgICAgIHNvcnRzOiBbeyBwcm9wZXJ0eTogJ1JSJywgZGlyZWN0aW9uOiAnZGVzY2VuZGluZycgfV1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBsZXQgbGVhZGVyYm9hcmQgPSAn8J+PhiAqKlZhbG9yYW50IExlYWRlcmJvYXJkKipcXFxcblxcXFxuJztcclxuICAgICAgcGxheWVyc0RhdGEucmVzdWx0cy5zbGljZSgwLCAxMCkuZm9yRWFjaCgocGxheWVyLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldFByb3BlcnR5VmFsdWUocGxheWVyLnByb3BlcnRpZXMsICdQbGF5ZXIgTmFtZScpO1xyXG4gICAgICAgIGNvbnN0IHJhbmsgPSB0aGlzLmdldFByb3BlcnR5VmFsdWUocGxheWVyLnByb3BlcnRpZXMsICdSYW5rJyk7XHJcbiAgICAgICAgY29uc3QgcnIgPSB0aGlzLmdldFByb3BlcnR5VmFsdWUocGxheWVyLnByb3BlcnRpZXMsICdSUicpO1xyXG4gICAgICAgIGNvbnN0IGtkID0gdGhpcy5nZXRQcm9wZXJ0eVZhbHVlKHBsYXllci5wcm9wZXJ0aWVzLCAnSy9EIFJhdGlvJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGVhZGVyYm9hcmQgKz0gXFxgXFwke2luZGV4ICsgMX0uICoqXFwke25hbWV9KiogLSBcXCR7cmFua30gKFxcJHtycn0gUlIpIHwgSy9EOiBcXCR7a2R9XFxcXG5cXGA7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGxlYWRlcmJvYXJkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgdGVhbXNEYXRhID0gYXdhaXQgdGhpcy5ub3Rpb24ucXVlcnlEYXRhYmFzZSh0aGlzLnRlYW1EYXRhYmFzZSwge1xyXG4gICAgICAgIHNvcnRzOiBbeyBwcm9wZXJ0eTogJ1Bvc2l0aW9uJywgZGlyZWN0aW9uOiAnYXNjZW5kaW5nJyB9XVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGxldCBsZWFkZXJib2FyZCA9ICfimr0gKipGb290YmFsbCBTdGFuZGluZ3MqKlxcXFxuXFxcXG4nO1xyXG4gICAgICB0ZWFtc0RhdGEucmVzdWx0cy5zbGljZSgwLCAxMCkuZm9yRWFjaCgodGVhbSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldFByb3BlcnR5VmFsdWUodGVhbS5wcm9wZXJ0aWVzLCAnVGVhbSBOYW1lJyk7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldFByb3BlcnR5VmFsdWUodGVhbS5wcm9wZXJ0aWVzLCAnUG9zaXRpb24nKTtcclxuICAgICAgICBjb25zdCB3aW5zID0gdGhpcy5nZXRQcm9wZXJ0eVZhbHVlKHRlYW0ucHJvcGVydGllcywgJ1dpbnMnKTtcclxuICAgICAgICBjb25zdCBkcmF3cyA9IHRoaXMuZ2V0UHJvcGVydHlWYWx1ZSh0ZWFtLnByb3BlcnRpZXMsICdEcmF3cycpO1xyXG4gICAgICAgIGNvbnN0IGxvc3NlcyA9IHRoaXMuZ2V0UHJvcGVydHlWYWx1ZSh0ZWFtLnByb3BlcnRpZXMsICdMb3NzZXMnKTtcclxuICAgICAgICBcclxuICAgICAgICBsZWFkZXJib2FyZCArPSBcXGBcXCR7cG9zaXRpb259LiAqKlxcJHtuYW1lfSoqIC0gXFwke3dpbnN9VyBcXCR7ZHJhd3N9RCBcXCR7bG9zc2VzfUxcXFxcblxcYDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gbGVhZGVyYm9hcmQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzY2hlZHVsZVVwZGF0ZXMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBVcGRhdGUgVmFsb3JhbnQgcGxheWVycyBldmVyeSBob3VyXHJcbiAgICBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHBsYXllcnMgPSBbJ1RlblonLCAnU2hyb3VkJywgJ3RhcmlrJ107IC8vIEV4YW1wbGUgcGxheWVyc1xyXG4gICAgICBmb3IgKGNvbnN0IHBsYXllciBvZiBwbGF5ZXJzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMudHJhY2tWYWxvcmFudFBsYXllcihwbGF5ZXIsICdOQTEnKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcXGBFcnJvciB1cGRhdGluZyBcXCR7cGxheWVyfTpcXGAsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIDM2MDAwMDApOyAvLyAxIGhvdXJcclxuXHJcbiAgICAvLyBVcGRhdGUgZm9vdGJhbGwgdGVhbXMgdHdpY2UgZGFpbHlcclxuICAgIHNldEludGVydmFsKGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgdGVhbXMgPSBbMzMsIDQwLCA1MF07IC8vIEV4YW1wbGUgdGVhbSBJRHMgKFJlYWwgTWFkcmlkLCBMaXZlcnBvb2wsIE1hbmNoZXN0ZXIgQ2l0eSlcclxuICAgICAgZm9yIChjb25zdCB0ZWFtSWQgb2YgdGVhbXMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy50cmFja0Zvb3RiYWxsVGVhbSh0ZWFtSWQsIDM5LCAyMDIzKTsgLy8gUHJlbWllciBMZWFndWUgMjAyM1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxcYEVycm9yIHVwZGF0aW5nIHRlYW0gXFwke3RlYW1JZH06XFxgLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCA0MzIwMDAwMCk7IC8vIDEyIGhvdXJzXHJcblxyXG4gICAgLy8gU2VuZCBkYWlseSBsZWFkZXJib2FyZCB1cGRhdGVzXHJcbiAgICBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHZhbG9yYW50TGVhZGVyYm9hcmQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlTGVhZGVyYm9hcmQoJ3ZhbG9yYW50Jyk7XHJcbiAgICAgIGNvbnN0IGZvb3RiYWxsTGVhZGVyYm9hcmQgPSBhd2FpdCB0aGlzLmdlbmVyYXRlTGVhZGVyYm9hcmQoJ2Zvb3RiYWxsJyk7XHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCB0aGlzLnNsYWNrLnNlbmRNZXNzYWdlKCcjZGFpbHktc3RhdHMnLCB2YWxvcmFudExlYWRlcmJvYXJkKTtcclxuICAgICAgYXdhaXQgdGhpcy5zbGFjay5zZW5kTWVzc2FnZSgnI2RhaWx5LXN0YXRzJywgZm9vdGJhbGxMZWFkZXJib2FyZCk7XHJcbiAgICB9LCA4NjQwMDAwMCk7IC8vIDI0IGhvdXJzXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldFByb3BlcnR5VmFsdWUocHJvcGVydGllczogYW55LCBwcm9wZXJ0eU5hbWU6IHN0cmluZyk6IGFueSB7XHJcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcclxuICAgIGlmICghcHJvcGVydHkpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICBzd2l0Y2ggKHByb3BlcnR5LnR5cGUpIHtcclxuICAgICAgY2FzZSAndGl0bGUnOlxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eS50aXRsZVswXT8ucGxhaW5fdGV4dCB8fCAnJztcclxuICAgICAgY2FzZSAncmljaF90ZXh0JzpcclxuICAgICAgICByZXR1cm4gcHJvcGVydHkucmljaF90ZXh0WzBdPy5wbGFpbl90ZXh0IHx8ICcnO1xyXG4gICAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eS5zZWxlY3Q/Lm5hbWUgfHwgJyc7XHJcbiAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5Lm51bWJlciB8fCAwO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRQb3NpdGlvblN1ZmZpeChwb3NpdGlvbjogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHN1ZmZpeGVzID0gWycnLCAnMXN0JywgJzJuZCcsICczcmQnXTtcclxuICAgIHJldHVybiBzdWZmaXhlc1twb3NpdGlvbl0gfHwgXFxgXFwke3Bvc2l0aW9ufXRoXFxgO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVXNhZ2UgZXhhbXBsZVxyXG5jb25zdCBhbmFseXRpY3MgPSBuZXcgR2FtaW5nQW5hbHl0aWNzRGFzaGJvYXJkKCk7XHJcblxyXG4vLyBUcmFjayBpbmRpdmlkdWFsIHBsYXllcnMvdGVhbXNcclxuY29uc3QgdmFsb3JhbnRTdGF0cyA9IGF3YWl0IGFuYWx5dGljcy50cmFja1ZhbG9yYW50UGxheWVyKCdUZW5aJywgJ05BMScpO1xyXG5jb25zdCBmb290YmFsbFN0YXRzID0gYXdhaXQgYW5hbHl0aWNzLnRyYWNrRm9vdGJhbGxUZWFtKDMzLCAzOSwgMjAyMyk7IC8vIFJlYWwgTWFkcmlkIGluIFByZW1pZXIgTGVhZ3VlXHJcblxyXG4vLyBHZW5lcmF0ZSBhbmQgc2VuZCBsZWFkZXJib2FyZHNcclxuY29uc3QgdmFsb3JhbnRMZWFkZXJib2FyZCA9IGF3YWl0IGFuYWx5dGljcy5nZW5lcmF0ZUxlYWRlcmJvYXJkKCd2YWxvcmFudCcpO1xyXG5jb25zdCBmb290YmFsbExlYWRlcmJvYXJkID0gYXdhaXQgYW5hbHl0aWNzLmdlbmVyYXRlTGVhZGVyYm9hcmQoJ2Zvb3RiYWxsJyk7XHJcblxyXG5jb25zb2xlLmxvZygnVmFsb3JhbnQgU3RhdHM6JywgdmFsb3JhbnRTdGF0cyk7XHJcbmNvbnNvbGUubG9nKCdGb290YmFsbCBTdGF0czonLCBmb290YmFsbFN0YXRzKTtcclxuXHJcbi8vIFN0YXJ0IGF1dG9tYXRlZCB0cmFja2luZ1xyXG5hd2FpdCBhbmFseXRpY3Muc2NoZWR1bGVVcGRhdGVzKCk7YCxcclxuICAgIGphdmFzY3JpcHQ6IGBjb25zdCB7IFZhbG9yYW50LCBGb290YmFsbEFQSSwgTm90aW9uQVBJLCBTbGFja0FQSSB9ID0gcmVxdWlyZSgnbWFjcm9fYXBpJyk7XHJcblxyXG5jbGFzcyBHYW1pbmdBbmFseXRpY3NEYXNoYm9hcmQge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy52YWxvcmFudCA9IG5ldyBWYWxvcmFudChwcm9jZXNzLmVudi5IRU5SSUtfQVBJX0tFWSk7XHJcbiAgICB0aGlzLmZvb3RiYWxsID0gbmV3IEZvb3RiYWxsQVBJKHtcclxuICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5GT09UQkFMTF9BUElfS0VZXHJcbiAgICB9KTtcclxuICAgIHRoaXMubm90aW9uID0gbmV3IE5vdGlvbkFQSSh7XHJcbiAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuTk9USU9OX0FQSV9LRVlcclxuICAgIH0pO1xyXG4gICAgdGhpcy5zbGFjayA9IG5ldyBTbGFja0FQSSh7XHJcbiAgICAgIGJvdFRva2VuOiBwcm9jZXNzLmVudi5TTEFDS19CT1RfVE9LRU5cclxuICAgIH0pO1xyXG4gICAgdGhpcy5wbGF5ZXJEYXRhYmFzZSA9IHByb2Nlc3MuZW52Lk5PVElPTl9QTEFZRVJfREI7XHJcbiAgICB0aGlzLnRlYW1EYXRhYmFzZSA9IHByb2Nlc3MuZW52Lk5PVElPTl9URUFNX0RCO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdHJhY2tWYWxvcmFudFBsYXllcihnYW1lTmFtZSwgdGFnTGluZSwgcmVnaW9uID0gJ25hJykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHBsYXllciBkYXRhXHJcbiAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLnZhbG9yYW50LmdldEFjY291bnQoZ2FtZU5hbWUsIHRhZ0xpbmUpO1xyXG4gICAgICBjb25zdCBtbXJEYXRhID0gYXdhaXQgdGhpcy52YWxvcmFudC5nZXRNTVIoZ2FtZU5hbWUsIHRhZ0xpbmUsIHsgcmVnaW9uIH0pO1xyXG4gICAgICBjb25zdCBwbGF5ZXJTdGF0cyA9IGF3YWl0IHRoaXMudmFsb3JhbnQuZ2V0UGxheWVyU3RhdHMocmVnaW9uLCBnYW1lTmFtZSwgdGFnTGluZSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzdGF0cyA9IHtcclxuICAgICAgICBwdXVpZDogYWNjb3VudC5wdXVpZCxcclxuICAgICAgICBnYW1lTmFtZTogYWNjb3VudC5uYW1lLFxyXG4gICAgICAgIHRhZ0xpbmU6IGFjY291bnQudGFnLFxyXG4gICAgICAgIHJhbms6IG1tckRhdGEuY3VycmVudHRpZXJwYXRjaGVkIHx8ICdVbnJhbmtlZCcsXHJcbiAgICAgICAgcnI6IG1tckRhdGEucmFua2luZ19pbl90aWVyIHx8IDAsXHJcbiAgICAgICAga2Q6IHBhcnNlRmxvYXQocGxheWVyU3RhdHMuY29tYmF0Py5rZCB8fCAnMCcpLFxyXG4gICAgICAgIHdpblJhdGU6IHBhcnNlRmxvYXQoKHBsYXllclN0YXRzLm92ZXJ2aWV3Py53aW5SYXRlIHx8ICcwJScpLnJlcGxhY2UoJyUnLCAnJykpXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9yZSBpbiBOb3Rpb25cclxuICAgICAgYXdhaXQgdGhpcy5zdG9yZVBsYXllclN0YXRzKHN0YXRzKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzXHJcbiAgICAgIGF3YWl0IHRoaXMuY2hlY2tSYW5rQ2hhbmdlcyhzdGF0cyk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gc3RhdHM7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB0cmFja2luZyBwbGF5ZXI6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdlbmVyYXRlTGVhZGVyYm9hcmQodHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICd2YWxvcmFudCcpIHtcclxuICAgICAgY29uc3QgcGxheWVyc0RhdGEgPSBhd2FpdCB0aGlzLm5vdGlvbi5xdWVyeURhdGFiYXNlKHRoaXMucGxheWVyRGF0YWJhc2UsIHtcclxuICAgICAgICBzb3J0czogW3sgcHJvcGVydHk6ICdSUicsIGRpcmVjdGlvbjogJ2Rlc2NlbmRpbmcnIH1dXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbGV0IGxlYWRlcmJvYXJkID0gJ/Cfj4YgKipWYWxvcmFudCBMZWFkZXJib2FyZCoqXFxcXG5cXFxcbic7XHJcbiAgICAgIHBsYXllcnNEYXRhLnJlc3VsdHMuc2xpY2UoMCwgMTApLmZvckVhY2goKHBsYXllciwgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRQcm9wZXJ0eVZhbHVlKHBsYXllci5wcm9wZXJ0aWVzLCAnUGxheWVyIE5hbWUnKTtcclxuICAgICAgICBjb25zdCByYW5rID0gdGhpcy5nZXRQcm9wZXJ0eVZhbHVlKHBsYXllci5wcm9wZXJ0aWVzLCAnUmFuaycpO1xyXG4gICAgICAgIGNvbnN0IHJyID0gdGhpcy5nZXRQcm9wZXJ0eVZhbHVlKHBsYXllci5wcm9wZXJ0aWVzLCAnUlInKTtcclxuICAgICAgICBcclxuICAgICAgICBsZWFkZXJib2FyZCArPSBcXGBcXCR7aW5kZXggKyAxfS4gKipcXCR7bmFtZX0qKiAtIFxcJHtyYW5rfSAoXFwke3JyfSBSUilcXFxcblxcYDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gbGVhZGVyYm9hcmQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBVc2FnZVxyXG5jb25zdCBhbmFseXRpY3MgPSBuZXcgR2FtaW5nQW5hbHl0aWNzRGFzaGJvYXJkKCk7XHJcblxyXG5jb25zdCBzdGF0cyA9IGF3YWl0IGFuYWx5dGljcy50cmFja1ZhbG9yYW50UGxheWVyKCdUZW5aJywgJ05BMScpO1xyXG5jb25zdCBsZWFkZXJib2FyZCA9IGF3YWl0IGFuYWx5dGljcy5nZW5lcmF0ZUxlYWRlcmJvYXJkKCd2YWxvcmFudCcpO1xyXG5cclxuY29uc29sZS5sb2coJ1BsYXllciBTdGF0czonLCBzdGF0cyk7YFxyXG4gIH1cclxuXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNvZGVFeGFtcGxlczsiXSwibmFtZXMiOlsiY29kZUV4YW1wbGVzIiwiaWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiY2F0ZWdvcnkiLCJkaWZmaWN1bHR5Iiwic2VydmljZXMiLCJmZWF0dXJlcyIsInR5cGVzY3JpcHQiLCJqYXZhc2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/data/codeExamples.ts\n"));

/***/ })

});